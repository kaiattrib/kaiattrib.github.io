<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="referrer" content="no-referrer"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>你是怎么收到 TouchEvent 的？ - Keeplooking</title><meta description="基于Android 9 分析 InputEventReceiver框架层可见的点击事件从哪里来？所有的事件都是由InputEventReceiver 先接受再分发出来的，"><meta property="og:type" content="blog"><meta property="og:title" content="你是怎么收到 TouchEvent 的？"><meta property="og:url" content="http://yoursite.com/2020/04/27/Android/touchevent/"><meta property="og:site_name" content="Keeplooking"><meta property="og:description" content="基于Android 9 分析 InputEventReceiver框架层可见的点击事件从哪里来？所有的事件都是由InputEventReceiver 先接受再分发出来的，"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/jpg/501385/1587998958439-9b1b0207-38c7-4971-a4e4-3a5fa937c517.jpg#align=left&amp;display=inline&amp;height=508&amp;margin=%5Bobject%20Object%5D&amp;originHeight=508&amp;originWidth=1002&amp;size=0&amp;status=done&amp;style=none&amp;width=1002"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/jpeg/501385/1587998958340-651a3a37-68b0-4100-b883-49e68458b561.jpeg#align=left&amp;display=inline&amp;height=538&amp;margin=%5Bobject%20Object%5D&amp;originHeight=538&amp;originWidth=1134&amp;size=0&amp;status=done&amp;style=none&amp;width=1134"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/501385/1587998958385-d5d3114d-7b66-4979-844d-c3acb89c2117.png#align=left&amp;display=inline&amp;height=1180&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1180&amp;originWidth=1920&amp;size=0&amp;status=done&amp;style=none&amp;width=1920"><meta property="article:published_time" content="2020-04-27T15:59:39.000Z"><meta property="article:modified_time" content="2023-05-14T07:53:19.958Z"><meta property="article:author" content="Ken Chan"><meta property="article:tag" content="Android"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.nlark.com/yuque/0/2020/jpg/501385/1587998958439-9b1b0207-38c7-4971-a4e4-3a5fa937c517.jpg#align=left&amp;display=inline&amp;height=508&amp;margin=%5Bobject%20Object%5D&amp;originHeight=508&amp;originWidth=1002&amp;size=0&amp;status=done&amp;style=none&amp;width=1002"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2020/04/27/Android/touchevent/"},"headline":"Keeplooking","image":[],"datePublished":"2020-04-27T15:59:39.000Z","dateModified":"2023-05-14T07:53:19.958Z","author":{"@type":"Person","name":"Ken Chan"},"description":"基于Android 9 分析 InputEventReceiver框架层可见的点击事件从哪里来？所有的事件都是由InputEventReceiver 先接受再分发出来的，"}</script><link rel="canonical" href="http://yoursite.com/2020/04/27/Android/touchevent/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/entypo/2.0/entypo.woff"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container {
  overflow: auto hidden;
}

mjx-container + br {
  display: none;
}
</style></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="Keeplooking" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/suibi/suibi.html">随笔</a><a class="navbar-item" href="/comments">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;" style="font-size: 1.5em;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;" style="font-size: 1.5em;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-27T15:59:39.000Z" title="2020-04-27T15:59:39.000Z">2020-04-27</time><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">24 分钟 读完 (大约 3530 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">你是怎么收到 TouchEvent 的？</h1><div class="content"><p>基于Android 9 分析</p>
<h2 id="InputEventReceiver"><a href="#InputEventReceiver" class="headerlink" title="InputEventReceiver"></a>InputEventReceiver</h2><h3 id="框架层可见的点击事件从哪里来？"><a href="#框架层可见的点击事件从哪里来？" class="headerlink" title="框架层可见的点击事件从哪里来？"></a>框架层可见的点击事件从哪里来？</h3><p>所有的事件都是由InputEventReceiver 先接受再分发出来的，</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Called from native code.</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchInputEvent</span><span class="params">(<span class="keyword">int</span> seq, InputEvent event, <span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">    mSeqMap.put(event.getSequenceNumber(), seq);</span><br><span class="line">    onInputEvent(event, displayId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="那native-code-又是怎么才会调上来的呢？"><a href="#那native-code-又是怎么才会调上来的呢？" class="headerlink" title="那native code 又是怎么才会调上来的呢？"></a>那native code 又是怎么才会调上来的呢？</h3><p>那就是在 InputEventReceiver 初始化的时候，需要注册。就是在 nativeInit 方法里面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an input event receiver bound to the specified input channel.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputChannel The input channel.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> looper The looper to use when invoking callbacks.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputEventReceiver</span><span class="params">(InputChannel inputChannel, Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inputChannel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"inputChannel must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"looper must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mInputChannel = inputChannel;</span><br><span class="line">        mMessageQueue = looper.getQueue();</span><br><span class="line">        mReceiverPtr = nativeInit(<span class="keyword">new</span> WeakReference&lt;InputEventReceiver&gt;(<span class="keyword">this</span>),</span><br><span class="line">                inputChannel, mMessageQueue);</span><br><span class="line"></span><br><span class="line">        mCloseGuard.open(<span class="string">"dispose"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>InputChannel</p>
<ul>
<li>An input channel specifies the file descriptors used to send input events to a window in another process.  It is Parcelable so that it can be sent to the process that is to receive events. Only one thread should be reading from an InputChannel at a time.</li>
<li>输入通道指定用于在另一个进程中将输入事件发送到窗口的文件描述符。 它是Parcelable，因此可以将其发送到要接收事件的进程。 一次只能一个线程从InputChannel读取。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">(WeakReference&lt;InputEventReceiver&gt; receiver,</span></span></span><br><span class="line"><span class="function"><span class="params">           InputChannel inputChannel, MessageQueue messageQueue)</span></span>;</span><br></pre></td></tr></table></figure>


<h3 id="先来看一-InputEventReceiver-的初始化-又是谁调用的呢？"><a href="#先来看一-InputEventReceiver-的初始化-又是谁调用的呢？" class="headerlink" title="先来看一 InputEventReceiver 的初始化 又是谁调用的呢？"></a>先来看一 InputEventReceiver 的初始化 又是谁调用的呢？</h3><p>在我们启动App的时候，最先由AMS跨进程传输的一个ClientTransaction，客户端进程ApplicationThread接收，然后发送到主线程ActivityThread，最后由TransactionExecutor统一解析。AMS封装并传输ClientTransaction，统一接口；客户端进程接收ClientTransaction并使用TransactionExecutor解析AMS的请求，再根据ActivityLifecycleItem执行不同的代码。Activity的生命周期就是 transaction.getLifecycleStateRequest() 获取的，然后再执行响应的生命周期回调。</p>
<p>调用栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;(InputChannel, Looper):<span class="number">60</span>, InputEventReceiver (android.view)&lt;init&gt;(ViewRootImpl, InputChannel, Looper):<span class="number">7190</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">//最终调用到 InputEventReceiver 初始化</span></span><br><span class="line">ViewRootImpl$WindowInputEventReceiver (android.view)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里会初始化几个inputStage</span></span><br><span class="line">setView(View, WindowManager$LayoutParams, View):<span class="number">847</span>, </span><br><span class="line"></span><br><span class="line">ViewRootImpl (android.view)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//DecorView 添加 我们自己写的 MainActivity</span></span><br><span class="line">addView(View, ViewGroup$LayoutParams, Display, Window):<span class="number">356</span>, WindowManagerGlobal (android.view)</span><br><span class="line"></span><br><span class="line"><span class="comment">//WindowManagerGlobal 添加 DecorView</span></span><br><span class="line">addView(View, ViewGroup$LayoutParams):<span class="number">93</span>, WindowManagerImpl (android.view)</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行 Resume</span></span><br><span class="line">handleResumeActivity(IBinder, <span class="keyword">boolean</span>, <span class="keyword">boolean</span>, String):<span class="number">3868</span>, ActivityThread (android.app)</span><br><span class="line"></span><br><span class="line">execute(ClientTransactionHandler, IBinder,PendingTransactionActions):<span class="number">51</span>, ResumeActivityItem (android.app.servertransaction)</span><br><span class="line"></span><br><span class="line"><span class="comment">//executeLifecycleState方法是用来改变Activity的生命周期状态的</span></span><br><span class="line"><span class="comment">//transaction.getLifecycleStateRequest() 获取的</span></span><br><span class="line">executeLifecycleState(ClientTransaction):<span class="number">145</span>, </span><br><span class="line"></span><br><span class="line"><span class="comment">//然后交给TransactionExecutor 统一调度</span></span><br><span class="line">TransactionExecutor (android.app.servertransaction)</span><br><span class="line">execute(ClientTransaction):<span class="number">70</span>, TransactionExecutor (android.app.servertransaction)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//首先是ActivityThread 收到一个ClientTransaction的消息</span></span><br><span class="line">handleMessage(Message):<span class="number">1808</span>, ActivityThread$H (android.app)</span><br><span class="line">dispatchMessage(Message):<span class="number">106</span>, Handler (android.os)</span><br><span class="line">loop():<span class="number">193</span>, Looper (android.os)</span><br><span class="line">main(String[]):<span class="number">6669</span>, ActivityThread (android.app)</span><br><span class="line">invoke(Object, Object[]):-<span class="number">1</span>, Method (java.lang.reflect)</span><br><span class="line">run():<span class="number">493</span>, RuntimeInit$MethodAndArgsCaller (com.android.internal.os)</span><br><span class="line">main(String[]):<span class="number">858</span>, ZygoteInit (com.android.internal.os)</span><br></pre></td></tr></table></figure>


<p>我们可以看到 在 android.view.ViewRootImpl#setView当中调用了,这个looper就是主线程的looepr了。这个InputChannel 实际上指向我们自己写的MainActivity (client)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel,</span><br><span class="line">                           Looper.myLooper());</span><br></pre></td></tr></table></figure>


<h3 id="再来看一-nativeInit-又做了什么呢？"><a href="#再来看一-nativeInit-又做了什么呢？" class="headerlink" title="再来看一 nativeInit 又做了什么呢？"></a>再来看一 nativeInit 又做了什么呢？</h3><p>在NativeInputEventReceiver的nativeInit方法中，创建了NativeInputEventReceiver对象，并调用它的initialize方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverWeak,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject inputChannelObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用传过来的inputChannel和messageQueue构建一个NativeInputEventReceiver</span></span><br><span class="line">    sp&lt;NativeInputEventReceiver&gt; receiver = <span class="keyword">new</span> NativeInputEventReceiver(env,</span><br><span class="line">            receiverWeak, inputChannel, messageQueue);</span><br><span class="line">    <span class="comment">//然后调用它的初始化方法        </span></span><br><span class="line">    <span class="keyword">status_t</span> status = receiver-&gt;initialize();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">NativeInputEventReceiver::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setFdEvents(ALOOPER_EVENT_INPUT);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>mMessageQueue-&gt;getLooper()-&gt;addFd(fd, 0, events, this, NULL);</li>
<li>实际上就把JAVA层的Looper关联ALOOPER_EVENT_INPUT</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NativeInputEventReceiver::setFdEvents</span><span class="params">(<span class="keyword">int</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFdEvents != events) &#123;</span><br><span class="line">        mFdEvents = events;</span><br><span class="line">        <span class="keyword">int</span> fd = mInputConsumer.getChannel()-&gt;getFd();</span><br><span class="line">        <span class="keyword">if</span> (events) &#123;</span><br><span class="line">            mMessageQueue-&gt;getLooper()-&gt;addFd(fd, <span class="number">0</span>, events, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessageQueue-&gt;getLooper()-&gt;removeFd(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>fd，fd即inputChannel的socket fd，Looper会侦测该fd的状态</li>
<li>events，即传入的ALOOPER_EVENT_INPUT，只有fd的状态是INPUT的时候才会触发调用LooperCallback中的handleEvent方法</li>
<li>this，即NativeInputEventReceiver，当fd状态为Input时，NativeInputEventReceiver中的handleEvent方法会被调用</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/501385/1587998958439-9b1b0207-38c7-4971-a4e4-3a5fa937c517.jpg#align=left&display=inline&height=508&margin=%5Bobject%20Object%5D&originHeight=508&originWidth=1002&size=0&status=done&style=none&width=1002" alt=""></p>
<p>在consumeEvents内，我们能看到调用了InputConsume::consume来接收InputDispatcher发送过来的事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">NativeInputEventReceiver::consumeEvents</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> consumeBatches, <span class="keyword">nsecs_t</span> frameTime, <span class="keyword">bool</span>* outConsumedBatch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = mInputConsumer.consume(&amp;mInputEventFactory,</span><br><span class="line">                consumeBatches, frameTime, &amp;seq, &amp;inputEvent);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>最终回调到 java 层的 InputEventReceiver#dispatchInputEvent 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env-&gt;CallVoidMethod(receiverObj.<span class="built_in">get</span>(),</span><br><span class="line">       gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj);</span><br></pre></td></tr></table></figure>


<p>通过上述的JNI调用，会调用到WindowInputEventReceiver的dispatchInputEvent方法，不过由于WindowInputEventReceiver并没有自己实现这个方法，因此会调用父类InputEventReceiver::dispatchInputEvent，内部会真正调用到android.view.ViewRootImpl.WindowInputEventReceiver#onInputEvent</p>
<p>接下来就是JAVA层，一层层分发事件了</p>
<p>android.view.ViewRootImpl.WindowInputEventReceiver#onInputEvent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInputEvent</span><span class="params">(InputEvent event, <span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">            enqueueInputEvent(event, <span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


<p>android.view.ViewRootImpl#enqueueInputEvent(android.view.InputEvent, android.view.InputEventReceiver, int, boolean)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueueInputEvent</span><span class="params">(InputEvent event,</span></span></span><br><span class="line"><span class="function"><span class="params">            InputEventReceiver receiver, <span class="keyword">int</span> flags, <span class="keyword">boolean</span> processImmediately)</span> </span>&#123;</span><br><span class="line">        adjustInputEventForCompatibility(event);</span><br><span class="line">        <span class="comment">// 池 包装,类似 obtainMessage</span></span><br><span class="line">        QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags);</span><br><span class="line">        QueuedInputEvent last = mPendingInputEventTail;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//入队到 所有 等候 的InputEvent</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mPendingInputEventHead = q;</span><br><span class="line">            mPendingInputEventTail = q;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last.mNext = q;</span><br><span class="line">            mPendingInputEventTail = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等候的事件+1</span></span><br><span class="line">        mPendingInputEventCount += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打个日志</span></span><br><span class="line">        Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName,</span><br><span class="line">                mPendingInputEventCount);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//是不是立即处理改事件</span></span><br><span class="line">        <span class="keyword">if</span> (processImmediately) &#123;</span><br><span class="line">            doProcessInputEvents();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//还是加到调度器里面</span></span><br><span class="line">            <span class="comment">//这里实际上是发送异步消息  mHandler.sendMessage(msg);</span></span><br><span class="line">            scheduleProcessInputEvents();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>从 enqueueInputEvent(event, this, 0, true) 看 ，这里的事件是processImmediately = true的，所以进一步再追一下  doProcessInputEvents()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessInputEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Deliver all pending input events in the queue.</span></span><br><span class="line">       <span class="comment">// 分发所有的 等候 InputEvent</span></span><br><span class="line">       <span class="keyword">while</span> (mPendingInputEventHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//出队</span></span><br><span class="line">           QueuedInputEvent q = mPendingInputEventHead;</span><br><span class="line">           mPendingInputEventHead = q.mNext;</span><br><span class="line">           <span class="keyword">if</span> (mPendingInputEventHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">               mPendingInputEventTail = <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           q.mNext = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//count--</span></span><br><span class="line">           mPendingInputEventCount -= <span class="number">1</span>;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//打个日志</span></span><br><span class="line">           Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName,</span><br><span class="line">                   mPendingInputEventCount);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">long</span> eventTime = q.mEvent.getEventTimeNano();</span><br><span class="line">           <span class="keyword">long</span> oldestEventTime = eventTime;</span><br><span class="line">           <span class="keyword">if</span> (q.mEvent <span class="keyword">instanceof</span> MotionEvent) &#123;</span><br><span class="line">               MotionEvent me = (MotionEvent)q.mEvent;</span><br><span class="line">               <span class="keyword">if</span> (me.getHistorySize() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   oldestEventTime = me.getHistoricalEventTimeNano(<span class="number">0</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           mChoreographer.mFrameInfo.updateInputEventTime(eventTime, oldestEventTime);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//这里具体 去分发处理该次事件</span></span><br><span class="line">           deliverInputEvent(q);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// We are done processing all input events that we can process right now</span></span><br><span class="line">       <span class="comment">// so we can clear the pending flag immediately.</span></span><br><span class="line">       <span class="comment">// 因为我们已经 分发完了 所有等候 的 InputEvent</span></span><br><span class="line">       <span class="comment">//清除wath = MSG_PROCESS_INPUT_EVENTS 的消息</span></span><br><span class="line">       <span class="keyword">if</span> (mProcessInputEventsScheduled) &#123;</span><br><span class="line">           mProcessInputEventsScheduled = <span class="keyword">false</span>;</span><br><span class="line">           mHandler.removeMessages(MSG_PROCESS_INPUT_EVENTS);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p>接下来再继续追一下 android.view.ViewRootImpl#deliverInputEvent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliverInputEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//又打个日志</span></span><br><span class="line">    Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"deliverInputEvent"</span>,q.mEvent.getSequenceNumber());</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个描述是 方便debug的,不影响后面的处理</span></span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onInputEvent(q.mEvent, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    InputStage stage;</span><br><span class="line">    <span class="keyword">if</span> (q.shouldSendToSynthesizer()) &#123;</span><br><span class="line">        stage = mSyntheticInputStage;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q.mEvent <span class="keyword">instanceof</span> KeyEvent) &#123;</span><br><span class="line">        mUnhandledKeyManager.preDispatch((KeyEvent) q.mEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//上面决定将事件派发到那个InputStage处理</span></span><br><span class="line">    <span class="keyword">if</span> (stage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleWindowFocusChanged();</span><br><span class="line">        stage.deliver(q);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        finishInputEvent(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>deliverInputEvent先判断将事件派发到那个InputStage，然后调用该InputState的deliver方法</p>
<h3 id="那么InputStage-又是-什么？"><a href="#那么InputStage-又是-什么？" class="headerlink" title="那么InputStage 又是 什么？"></a>那么InputStage 又是 什么？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mSyntheticInputStage = <span class="keyword">new</span> SyntheticInputStage();</span><br><span class="line">    </span><br><span class="line">    InputStage viewPostImeStage = <span class="keyword">new</span> ViewPostImeInputStage(mSyntheticInputStage);</span><br><span class="line">    </span><br><span class="line">    InputStage nativePostImeStage = <span class="keyword">new</span> NativePostImeInputStage(viewPostImeStage,</span><br><span class="line">            <span class="string">"aq:native-post-ime:"</span> + counterSuffix);</span><br><span class="line">            </span><br><span class="line">    InputStage earlyPostImeStage = <span class="keyword">new</span> EarlyPostImeInputStage(nativePostImeStage);</span><br><span class="line">    </span><br><span class="line">    InputStage imeStage = <span class="keyword">new</span> ImeInputStage(earlyPostImeStage,</span><br><span class="line">            <span class="string">"aq:ime:"</span> + counterSuffix);</span><br><span class="line">            </span><br><span class="line">    InputStage viewPreImeStage = <span class="keyword">new</span> ViewPreImeInputStage(imeStage);</span><br><span class="line">    </span><br><span class="line">    InputStage nativePreImeStage = <span class="keyword">new</span> NativePreImeInputStage(viewPreImeStage,</span><br><span class="line">            <span class="string">"aq:native-pre-ime:"</span> + counterSuffix);</span><br><span class="line">    mFirstInputStage = nativePreImeStage;</span><br><span class="line">    mFirstPostImeInputStage = earlyPostImeStage;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>InputStage 是在setView()的时候创建的，也就是在Activity的onResume()</p>
<p>通过一路的 forward deliver ，最后走到apply 的 onProcess 方法中去。也就是<br>android.view.ViewRootImpl.ViewPostImeInputStage#onProcess</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">onProcess</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (q.mEvent <span class="keyword">instanceof</span> KeyEvent) &#123;</span><br><span class="line">             <span class="keyword">return</span> processKeyEvent(q);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">int</span> source = q.mEvent.getSource();</span><br><span class="line">             <span class="keyword">if</span> ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">//处理点触摸事件</span></span><br><span class="line">                 <span class="keyword">return</span> processPointerEvent(q);</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((source &amp; InputDevice.SOURCE_CLASS_TRACKBALL) != <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="keyword">return</span> processTrackballEvent(q);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">return</span> processGenericMotionEvent(q);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>


<p>那么再来看下一</p>
<ul>
<li>android.view.ViewRootImpl.ViewPostImeInputStage#processPointerEvent 里面又是怎么发的？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">processPointerEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> MotionEvent event = (MotionEvent)q.mEvent;</span><br><span class="line"></span><br><span class="line">       mAttachInfo.mUnbufferedDispatchRequested = <span class="keyword">false</span>;</span><br><span class="line">       mAttachInfo.mHandlingPointerEvent = <span class="keyword">true</span>;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">       <span class="comment">//mView  就是 android.view.ViewRootImpl#setView 的时候传入的View，也就是 DecorView</span></span><br><span class="line">       <span class="comment">//接下里就是 走到 DecorView的dispatchPointerEvent 中去了</span></span><br><span class="line">       <span class="comment">//标记1，这里第一次 把事件发到 DecorView 中</span></span><br><span class="line">       <span class="keyword">boolean</span> handled = mView.dispatchPointerEvent(event);</span><br><span class="line">       maybeUpdatePointerIcon(event);</span><br><span class="line">       maybeUpdateTooltip(event);</span><br><span class="line">       mAttachInfo.mHandlingPointerEvent = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (mAttachInfo.mUnbufferedDispatchRequested &amp;&amp; !mUnbufferedInputDispatch) &#123;</span><br><span class="line">           mUnbufferedInputDispatch = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">if</span> (mConsumeBatchedInputScheduled) &#123;</span><br><span class="line">               scheduleConsumeBatchedInputImmediately();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> handled ? FINISH_HANDLED : FORWARD;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p>当调用到 DecorView 的 dispatchPointerEvent ，实际上是  android.view.View#dispatchPointerEvent ，接下来的问题实际上就是 view的事件分发了？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">dispatchPointerEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是点击事件,转到dispatchTouchEvent</span></span><br><span class="line">    <span class="keyword">if</span> (event.isTouchEvent()) &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatchTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatchGenericMotionEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>转接到</p>
<ul>
<li>com.android.internal.policy.DecorView#dispatchTouchEvent</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Activity实现了Window.Callback接口 android.app.Activity#attach中  mWindow.setCallback(this); 所以这个callback指向Activity</span></span><br><span class="line">    <span class="comment">// mWindow 就是 PhoneWindow ，在 DecorView 初始化的时候传入的</span></span><br><span class="line">    <span class="keyword">final</span> Window.Callback cb = mWindow.getCallback();</span><br><span class="line">    <span class="comment">// 标记2，这里从DecorView 把事件转发到 Activity 中</span></span><br><span class="line">    <span class="keyword">return</span> cb != <span class="keyword">null</span> &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; <span class="number">0</span></span><br><span class="line">            ? cb.dispatchTouchEvent(ev) : <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>最后cb.dispatchTouchEvent(ev)  就相当于 走入到了</p>
<ul>
<li>android.app.-Activity#dispatchTouchEvent</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//事件又被传递到了PhoneWindow中去分发这个事件</span></span><br><span class="line">    <span class="comment">//如果被消费了，直接return</span></span><br><span class="line">    <span class="comment">//标记3，这里把事件从Activty转发到phoneWindow中去了</span></span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果上面没有被消费，则进入Activity 的 onTouchEvent </span></span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Activity 的 getWindow() 就是 android.app.Activity#attach中的mWindow ，也就是 PhoneWindow。</p>
<ul>
<li>com.android.internal.policy.PhoneWindow#superDispatchTouchEvent</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//纳尼，又 转接到了 DecorView 中去</span></span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>从上面的标记1，2，3 可以看到，首先事件从 android.view.ViewRootImpl.ViewPostImeInputStage#processPointerEvent 发到 DecorView ,DecorView 再分发事件的时候，通过 Window 获取callback 拿到 Activity ,转交给Activity 去发送，但是Activity又通过 getWindow，又把事件转交给Window ，Window 最后又通过mDecor.superDispatchTouchEvent(event) 转交给 了DecorView。<strong>搞半天？最后还是回到 android.view.ViewRootImpl.ViewPostImeInputStage#processPointerEvent 的 mView.dispatchPointerEvent(event)中？</strong></p>
<p>显然不是 第一次调用的是 DecorView.dispatchPointerEvent(event) ，第二次回到 DecorView是调用的 DecorView.superDispatchTouchEvent(event);也就调用到 DecorView 的父类 DispatchTouchEvent ，最后也就是 android.view.ViewGroup#dispatchTouchEvent的了。</p>
<p>一小段调用栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">dispatchTouchEvent(MotionEvent):<span class="number">2543</span>, ViewGroup (android.view)<span class="comment">//ViewGroup 分发事件</span></span><br><span class="line">superDispatchTouchEvent(MotionEvent):<span class="number">440</span>, DecorView (com.android.internal.policy)<span class="comment">//第二次</span></span><br><span class="line">superDispatchTouchEvent(MotionEvent):<span class="number">1830</span>, PhoneWindow (com.android.internal.policy)</span><br><span class="line">dispatchTouchEvent(MotionEvent):<span class="number">3400</span>, Activity (android.app)</span><br><span class="line">dispatchTouchEvent(MotionEvent):<span class="number">398</span>, DecorView (com.android.internal.policy)<span class="comment">//第一次</span></span><br><span class="line">dispatchPointerEvent(MotionEvent):<span class="number">12752</span>, View (android.view)</span><br><span class="line">processPointerEvent(ViewRootImpl$QueuedInputEvent):<span class="number">5106</span>,、</span><br><span class="line">---</span><br></pre></td></tr></table></figure>


<h3 id="辗转的原因？来自-https-www-jianshu-com-p-b7cef3b3e703"><a href="#辗转的原因？来自-https-www-jianshu-com-p-b7cef3b3e703" class="headerlink" title="辗转的原因？来自 https://www.jianshu.com/p/b7cef3b3e703"></a>辗转的原因？来自 <a href="https://www.jianshu.com/p/b7cef3b3e703">https://www.jianshu.com/p/b7cef3b3e703</a></h3><p>为什么在InputStage.processPointerEvent()中不直接把事件传递给Activity，而是这样来回绕一圈。这样DecorView -&gt; Activity -&gt; PhoneWindow -&gt; DecorView的来回绕一圈不是很折腾吗？</p>
<p>首先，为了解耦，ViewRootImpl并不知道有Activity这种东西存在！不知道！它只是持有了DecorView。所以，想要直接把触摸事件送到Activity.dispatchTouchEvent() 是不行的。</p>
<p>那么，既然触摸事件已经到了Activity.dispatchTouchEvent()中了，为什么不直接分发给DecorView ，而是要通过PhoneWindow 来间接发送呢？因为Activity 不知道有DecorView 这种奇怪的东西存在啊！不知道！但是，Activity持有PhoneWindow ，而PhoneWindow当然知道自己的窗口里有些什么了，所以能够把事件派发给DecorView 。你看，在Android中，Activity并不知道自己的Window中有些什么，这样耦合性就很低了。我们换一个Window试试？不管Window里面的内容如何，只要Window任然符合Activity制定的标准，那么它就能在Activity中很好的工作。这就是解耦所带来的扩展性的好处。</p>
<p>作者：CoorChice<br>链接：<a href="https://www.jianshu.com/p/b7cef3b3e703">https://www.jianshu.com/p/b7cef3b3e703</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/501385/1587998958340-651a3a37-68b0-4100-b883-49e68458b561.jpeg#align=left&display=inline&height=538&margin=%5Bobject%20Object%5D&originHeight=538&originWidth=1134&size=0&status=done&style=none&width=1134" alt=""></p>
<h2 id="ViewGroup-的事件分发流程？"><a href="#ViewGroup-的事件分发流程？" class="headerlink" title="ViewGroup 的事件分发流程？"></a>ViewGroup 的事件分发流程？</h2><p>首先分清楚 3个方法</p>
<ul>
<li>dispatchTouchEvent() 分发器，决定事件怎么分发，会先询问onInterceptTouchEvent()，如果拦截了 进一步到 自己的 onTouchEvent() 中去。如果没有拦截，转发到子view的dispatchTouchEvent()</li>
<li>onInterceptTouchEvent() 拦截器 是ViewGroup特有的方法，可以判断和拦截要不要将事件下发到子view去处理。</li>
<li>onTouchEvent() 处理器。最后的一个子view 收到事件将会直接由【分发器】分发到【处理器】中。如果处理了返回true，如果不处理返回false，那么事件将传递到它的父级的【处理器】中。</li>
</ul>
<p>不管个层级的【处理器】，如果处理事件返回true，一次触摸事件就结束了。如果不处理事件，返回false，就是事件还没有被消费，就会传送到上一级的【处理器】中。最终，如果DecorView的【处理器】也不打算处理事件，那么事件将会被发送到Activity的【处理器】中处理。</p>
<p>说白了，就是先交给子view优先消费，消费不了，返回了，我再消费。</p>
<h3 id="那么ViewGroup-dispatchTouchEvent-又是怎么把事件发到child-view中去的呢？"><a href="#那么ViewGroup-dispatchTouchEvent-又是怎么把事件发到child-view中去的呢？" class="headerlink" title="那么ViewGroup dispatchTouchEvent()又是怎么把事件发到child view中去的呢？"></a>那么ViewGroup dispatchTouchEvent()又是怎么把事件发到child view中去的呢？</h3><ul>
<li>android.view.ViewGroup#dispatchTouchEvent</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find a child that can receive the event.</span></span><br><span class="line"><span class="comment">// Scan children from front to back.</span></span><br><span class="line"><span class="comment">// 找一个可以接受这个事件的子view,从后面向前找，找到一个就结束</span></span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line"><span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">            childrenCount, i, customOrder);</span><br><span class="line">    <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">            preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there is a view that has accessibility focus we want it</span></span><br><span class="line">    <span class="comment">// to get the event first and if not handled we will perform a</span></span><br><span class="line">    <span class="comment">// normal dispatch. We may do a double iteration but this is</span></span><br><span class="line">    <span class="comment">// safer given the timeframe.</span></span><br><span class="line">    <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">        i = childrenCount - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//该次点击是不是落在了 子view的 布局范围之中，且子view 可以接受点击，比如可见</span></span><br><span class="line">    <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">            || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>可能存在的问题，就是布局重叠的时候，收不到响应？</li>
</ul>
<p>最后再子view的 android.view.View#onTouchEvent中，包装成一个 mPerformClick ,最后通过  mHandler.post(action) 把这个 action 发到 主线程的looper 里面去处理了，然后looepr 处理消息，调用action ，就是我们set的OnClickListener里面去了。</p>
<ul>
<li>android.os.Handler#dispatchMessage</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// msg.callback  = performClick </span></span><br><span class="line">    <span class="comment">//开始处理 处理 Callback</span></span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>最后 调到 message.callback.run();</li>
<li>然后  在run() 调用 performClick() 中的 mOnClickListener.onClick(this);</li>
</ul>
<p>最后我们 就开始我们的OnClick 逻辑了</p>
<hr>
<h2 id="总结-最后一张大图"><a href="#总结-最后一张大图" class="headerlink" title="总结 最后一张大图"></a>总结 最后一张大图</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/501385/1587998958385-d5d3114d-7b66-4979-844d-c3acb89c2117.png#align=left&display=inline&height=1180&margin=%5Bobject%20Object%5D&originHeight=1180&originWidth=1920&size=0&status=done&style=none&width=1920" alt=""></p>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>[Android] 输入系统（二）] <a href="https://www.cnblogs.com/TaigaCon/p/4750349.html">https://www.cnblogs.com/TaigaCon/p/4750349.html</a></p>
<p>作者：CoorChice<br>链接：<a href="https://www.jianshu.com/p/b7cef3b3e703">https://www.jianshu.com/p/b7cef3b3e703</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Android/">Android</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/04/28/LeetCode/jian-sheng-zi-lcof/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">剪绳子</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/04/27/LeetCode/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/"><span class="level-item">二叉树中和为某一值的路径</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-2-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="/img/myavatar.png" alt="Ken"></figure><p class="title is-size-4 is-block line-height-inherit">Ken</p><p class="is-size-6 is-block">爱于心，鉴于行</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">71</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">16</p></a></div></div></nav></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Android/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%88%86%E4%BA%AB/"><span class="level-start"><span class="level-item">分享</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%A1%86%E6%9E%B6/"><span class="level-start"><span class="level-item">框架</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">计算机基础</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">语言基础</span></span><span class="level-end"><span class="level-item tag">26</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E9%97%AE%E9%A2%98%E4%B8%8E%E7%BB%8F%E9%AA%8C/"><span class="level-start"><span class="level-item">问题与经验</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/"><span class="level-start"><span class="level-item">项目架构</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2023-12-02T10:19:06.000Z">2023-12-02</time></p><p class="title is-6"><a class="link-muted" href="/2023/12/02/Android/android_import_rust/">Android项目接入Rust</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Android/">Android</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2023-11-07T09:30:35.000Z">2023-11-07</time></p><p class="title is-6"><a class="link-muted" href="/2023/11/07/Android/kotlin_name_dup/">Kotlin的变量重名问题</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">语言基础</a> / <a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/Kotlin/">Kotlin</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2023-10-14T10:09:12.000Z">2023-10-14</time></p><p class="title is-6"><a class="link-muted" href="/2023/10/14/Android/kotlin_android_init_no_method/">小心Kotlin下的构造函数NoSuchMethodException</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Android/">Android</a> / <a class="link-muted" href="/categories/Android/Kotlin/">Kotlin</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2023-09-09T08:44:08.000Z">2023-09-09</time></p><p class="title is-6"><a class="link-muted" href="/2023/09/09/Android/seq_point_trace_report/">一种事件流埋点的实现方案</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E9%97%AE%E9%A2%98%E4%B8%8E%E7%BB%8F%E9%AA%8C/">问题与经验</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2023-08-12T07:45:13.000Z">2023-08-12</time></p><p class="title is-6"><a class="link-muted" href="/2023/08/12/Android/compose_inspector/">解决 Compose Layout Inspector 不能用</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Android/">Android</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag is-grey-lightest">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bug/"><span class="tag">Bug</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Compose/"><span class="tag">Compose</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Gradle/"><span class="tag">Gradle</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JNI/"><span class="tag">JNI</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag is-grey-lightest">23</span></a></div><div class="control"><a class="tags has-addons" href="/tags/K8S/"><span class="tag">K8S</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kotlin/"><span class="tag">Kotlin</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LeetCode/"><span class="tag">LeetCode</span><span class="tag is-grey-lightest">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spark/"><span class="tag">Spark</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E4%BA%AB/"><span class="tag">分享</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%89%E8%A3%85/"><span class="tag">安装</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%BB%84/"><span class="tag">计组</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-2-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget toc-scroll" id="toc"><div class="card-content"><div class="menu" style="max-height: 600px; overflow: auto;"><h3 class="menu-label">目录</h3><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-InputEventReceiver" href="#InputEventReceiver"><span>InputEventReceiver</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-框架层可见的点击事件从哪里来？" href="#框架层可见的点击事件从哪里来？"><span>框架层可见的点击事件从哪里来？</span></a></li><li><a class="is-flex toc-item" id="toc-item-那native-code-又是怎么才会调上来的呢？" href="#那native-code-又是怎么才会调上来的呢？"><span>那native code 又是怎么才会调上来的呢？</span></a></li><li><a class="is-flex toc-item" id="toc-item-先来看一-InputEventReceiver-的初始化-又是谁调用的呢？" href="#先来看一-InputEventReceiver-的初始化-又是谁调用的呢？"><span>先来看一 InputEventReceiver 的初始化 又是谁调用的呢？</span></a></li><li><a class="is-flex toc-item" id="toc-item-再来看一-nativeInit-又做了什么呢？" href="#再来看一-nativeInit-又做了什么呢？"><span>再来看一 nativeInit 又做了什么呢？</span></a></li><li><a class="is-flex toc-item" id="toc-item-那么InputStage-又是-什么？" href="#那么InputStage-又是-什么？"><span>那么InputStage 又是 什么？</span></a></li><li><a class="is-flex toc-item" id="toc-item-辗转的原因？来自-https-www-jianshu-com-p-b7cef3b3e703" href="#辗转的原因？来自-https-www-jianshu-com-p-b7cef3b3e703"><span>辗转的原因？来自 https:&amp;#x2F;&amp;#x2F;www.jianshu.com&amp;#x2F;p&amp;#x2F;b7cef3b3e703</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-ViewGroup-的事件分发流程？" href="#ViewGroup-的事件分发流程？"><span>ViewGroup 的事件分发流程？</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-那么ViewGroup-dispatchTouchEvent-又是怎么把事件发到child-view中去的呢？" href="#那么ViewGroup-dispatchTouchEvent-又是怎么把事件发到child-view中去的呢？"><span>那么ViewGroup dispatchTouchEvent()又是怎么把事件发到child view中去的呢？</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-总结-最后一张大图" href="#总结-最后一张大图"><span>总结 最后一张大图</span></a></li><li><a class="is-flex toc-item" id="toc-item-感谢" href="#感谢"><span>感谢</span></a></li></ul></div></div><script type="text/javascript" async>
        $(document).ready(function () { //参考自 https://github.com/ppoffice/hexo-theme-icarus/pull/616/files
            var observerTopMargin;
            var scrollObserver;
            var headerElems = $(".headerlink");
            var activeTocItem;
        
            function initIntersectionObserver(docHeight) {
                observerTopMargin = docHeight;
                scrollObserver = new IntersectionObserver(scrollCallBack,
                    {
                        root: null,  // viewpoint
                        rootMargin: docHeight + "px 0px -80% 0px"  // cover top 30% of viewport to the top of document
                    })
            }
        
            function scrollCallBack(entries, observer) {
                if ($(window).scrollTop() > observerTopMargin * 0.7) { 
                    // User somehow scroll to 70% of observerTopMargin (which is inited as 200% document height)
                    // Observer top margin need to extend to cover all the space to the top of the document
                    initIntersectionObserver(observerTopMargin * 2)
                    observer.disconnect();
                    return;
                }
                let toActive;
                if (entries[0].intersectionRatio == 1) {  // enter viewed area
                    let entry = entries.reduce((u, v) => (u.target.toc_id > v.target.toc_id ? u : v));  // get the lowest item
                    toActive = $("#toc-item-" + $(entry.target).attr("href").substr(1));
                } else {
                    let entry = entries.reduce((u, v) => (u.target.toc_id < v.target.toc_id ? u : v));  // get the highest item
                    let idx = Math.max(entry.target.toc_id - 1, 0);
                    toActive = $("#toc-item-" + $(headerElems[idx]).attr("href").substr(1));
                }
                if (activeTocItem) activeTocItem.removeClass("is-current");
                activeTocItem = toActive
                activeTocItem.addClass("is-current");
            }
        
            initIntersectionObserver($(document).height() * 2);
            headerElems.each(function (index, obj) {
                obj.toc_id = index;
                scrollObserver.observe(obj);
            })
        });</script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="Keeplooking" height="28"></a><p class="size-small"><span>&copy; 2019 - 2024  Ken Chan</span>  </p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Fllow GitHub" href="https://github.com/kaiattrib"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>