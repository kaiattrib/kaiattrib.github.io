<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="referrer" content="no-referrer"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>深入理解Handler原理 - Keeplooking</title><meta description="一. Handler初始化Handler–&amp;gt; Looper &amp;lt;– MessageQueue &amp;lt;– MessageHandler需要Looper，Looperl里包含构建的MessageQueue。 可以在构造的时候，通过参数传入。 1. Handler 构造12345678910111213141516171819202122232425public Handler(Callba"><meta property="og:type" content="blog"><meta property="og:title" content="深入理解Handler原理"><meta property="og:url" content="http://yoursite.com/2020/04/18/Android/hander/"><meta property="og:site_name" content="Keeplooking"><meta property="og:description" content="一. Handler初始化Handler–&amp;gt; Looper &amp;lt;– MessageQueue &amp;lt;– MessageHandler需要Looper，Looperl里包含构建的MessageQueue。 可以在构造的时候，通过参数传入。 1. Handler 构造12345678910111213141516171819202122232425public Handler(Callba"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/jpeg/501385/1586956920650-584b7b4d-8387-4f6f-9887-255e1d5a4618.jpeg#align=left&amp;display=inline&amp;height=550&amp;margin=%5Bobject%20Object%5D&amp;originHeight=550&amp;originWidth=902&amp;size=0&amp;status=done&amp;style=none&amp;width=902"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/501385/1586956918477-d2250519-d8d1-4a5a-8a67-f6c0ad101f21.png#align=left&amp;display=inline&amp;height=650&amp;margin=%5Bobject%20Object%5D&amp;originHeight=650&amp;originWidth=710&amp;size=0&amp;status=done&amp;style=none&amp;width=710"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/501385/1586956918564-08b3b13e-ec46-44f0-a60b-97b0cdb2b86e.png#align=left&amp;display=inline&amp;height=709&amp;margin=%5Bobject%20Object%5D&amp;originHeight=709&amp;originWidth=725&amp;size=0&amp;status=done&amp;style=none&amp;width=725"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/501385/1586956919035-0575e298-b9eb-44a5-bd36-c285f28195a0.png#align=left&amp;display=inline&amp;height=717&amp;margin=%5Bobject%20Object%5D&amp;originHeight=717&amp;originWidth=728&amp;size=0&amp;status=done&amp;style=none&amp;width=728"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/501385/1586956918546-eab719a0-e18e-4d65-8f1f-768ed2a35469.png#align=left&amp;display=inline&amp;height=422&amp;margin=%5Bobject%20Object%5D&amp;originHeight=422&amp;originWidth=947&amp;size=0&amp;status=done&amp;style=none&amp;width=947"><meta property="article:published_time" content="2020-04-18T15:54:44.000Z"><meta property="article:modified_time" content="2023-05-14T07:53:19.957Z"><meta property="article:author" content="Ken Chan"><meta property="article:tag" content="Android"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.nlark.com/yuque/0/2020/jpeg/501385/1586956920650-584b7b4d-8387-4f6f-9887-255e1d5a4618.jpeg#align=left&amp;display=inline&amp;height=550&amp;margin=%5Bobject%20Object%5D&amp;originHeight=550&amp;originWidth=902&amp;size=0&amp;status=done&amp;style=none&amp;width=902"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2020/04/18/Android/hander/"},"headline":"Keeplooking","image":[],"datePublished":"2020-04-18T15:54:44.000Z","dateModified":"2023-05-14T07:53:19.957Z","author":{"@type":"Person","name":"Ken Chan"},"description":"一. Handler初始化Handler–&gt; Looper &lt;– MessageQueue &lt;– MessageHandler需要Looper，Looperl里包含构建的MessageQueue。 可以在构造的时候，通过参数传入。 1. Handler 构造12345678910111213141516171819202122232425public Handler(Callba"}</script><link rel="canonical" href="http://yoursite.com/2020/04/18/Android/hander/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/entypo/2.0/entypo.woff"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container {
  overflow: auto hidden;
}

mjx-container + br {
  display: none;
}
</style></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="Keeplooking" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/suibi/suibi.html">随笔</a><a class="navbar-item" href="/comments">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;" style="font-size: 1.5em;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;" style="font-size: 1.5em;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-18T15:54:44.000Z" title="2020-04-18T15:54:44.000Z">2020-04-18</time><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">1 小时 读完 (大约 7311 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">深入理解Handler原理</h1><div class="content"><h2 id="一-Handler初始化"><a href="#一-Handler初始化" class="headerlink" title="一. Handler初始化"></a>一. Handler初始化</h2><h3 id="Handler–-gt-Looper-lt-–-MessageQueue-lt-–-Message"><a href="#Handler–-gt-Looper-lt-–-MessageQueue-lt-–-Message" class="headerlink" title="Handler–&gt; Looper &lt;– MessageQueue &lt;– Message"></a>Handler–&gt; Looper &lt;– MessageQueue &lt;– Message</h3><p><br />Handler需要Looper，Looperl里包含构建的MessageQueue。 可以在构造的时候，通过参数传入。<br /></p>
<h3 id="1-Handler-构造"><a href="#1-Handler-构造" class="headerlink" title="1. Handler 构造"></a>1. Handler 构造</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检查潜在的泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前线程的Looper</span></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="comment">//Handler需要Looper,如果为null，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread "</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">" that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置当前Handler的MessageQueue 等于Looper的MessageQueue</span></span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="2-上面的mLooper-为什么可能为空？要调用-Looper-prepare"><a href="#2-上面的mLooper-为什么可能为空？要调用-Looper-prepare" class="headerlink" title="2. 上面的mLooper 为什么可能为空？要调用 Looper.prepare()?"></a>2. 上面的mLooper 为什么可能为空？要调用 Looper.prepare()?</h3><p><br />先看一下mLooper = Looper.myLooper()<br /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里可以看到是通过ThreadLocal线程持有的一个 Looper</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前线程的map,并返回looper</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前线程的map还没有，就在这个方法里面创建</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br />再看一下 Looper.prepare()，这里解释了为什么只能调用一次<br /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果有了，就抛错，一个线程保证了只能有一个Looper</span></span><br><span class="line">       <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//没有就new一个 set</span></span><br><span class="line">       sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-为什么有什么需要手动调用Looper-prepare-？"><a href="#3-为什么有什么需要手动调用Looper-prepare-？" class="headerlink" title="3. 为什么有什么需要手动调用Looper.prepare() ？"></a>3. 为什么有什么需要手动调用Looper.prepare() ？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前线程有了looper就不需要手动调用。如果是在主线程ActivityThread，主线程已经默认有了一个Looper了，这个Looper会处理界面的各种事件。</span><br></pre></td></tr></table></figure>

<p><br />在ActivityThread的main方法中<br /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里就对主线程，调用了Looper.prepare()，所以在主线程启动的时候，就拥有了Looper,后面的是在主线程中的Handler默认共享该Looepr</span></span><br><span class="line">Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line"><span class="comment">//展开就是Looper下的这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里就是Looper.prepare()</span></span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个Handler只能对应一个Looepr,一个Looper 持有MessageQueue。一个Looper可以对应多个Hander。那么Message是怎么和Handler联系起来的呢，在加入消息的时候 通过  msg.target &#x3D; this; this就是handler本身联系起来的。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二-Handder-发送消息-—-gt-入队"><a href="#二-Handder-发送消息-—-gt-入队" class="headerlink" title="二. Handder 发送消息 —&gt; 入队"></a>二. Handder 发送消息 —&gt; 入队</h2><p><br />通常我们新建消息的时候 通过 Message obtain = Message.obtain();获取，主要是复用里面的Message对象。<br />通常我们调用<br /></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sendMessage(Message msg)&#x2F;&#x2F;发送消息</span><br><span class="line">——&gt; sendMessageDelayed(msg, 0)&#x2F;&#x2F;延时为0</span><br><span class="line">——&gt; sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis)&#x2F;&#x2F;转换成绝对时间</span><br><span class="line">——&gt; enqueueMessage(queue, msg, uptimeMillis)&#x2F;&#x2F;开始入队</span><br></pre></td></tr></table></figure>

<p><br />下面的就是MeaageQueue入队的逻辑了，类似链表<br /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//target 就是发送消息的Hander 如果message的handelr为null，抛错</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//msg是不是正在被使用,比如说这个消息已经入队了。就不能再加入</span></span><br><span class="line">    <span class="comment">// 连续sendMessage同一个msg对象就会抛错,当然msg复用obtian和new的时候FLAG_IN_USE会重置</span></span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//保证线程安全</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//当前队列是不是调用了quit</span></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//标记为Use状态</span></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先保留之前的节点，准备插入现在的msg</span></span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//p = null 现在队列是空的 </span></span><br><span class="line">        <span class="comment">// 为什么 会有 when = 0 ？Handler提供了一个sendMessageAtFrontOfQueue 方法,保证某个消息插到消息头，及时处理</span></span><br><span class="line">        <span class="comment">//when &lt; p.when 当前插入的消息 比前一个节点的时间更小，意味着要先执行消息</span></span><br><span class="line">        <span class="comment">//其实就是头插入  类似 null&lt;--msg   或者   null&lt;--.&lt;--p&lt;--msg</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            <span class="comment">//根据当前的MessageQueue 状态,确定是否要唤醒队列起来处理消息</span></span><br><span class="line">            <span class="comment">//为什么要唤醒？因为队列为空了，或者队列里面的消息都是明天才要处理的，那么今晚可以睡觉。但是睡梦中又有新的(bug)消息来了，就是这次要插入的消息，必须起来处理(bug)消息</span></span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            <span class="comment">//以上情况不满足，就是要把当前这个消息插入到队列中间去了</span></span><br><span class="line">            <span class="comment">// 就按时间when的顺序插入</span></span><br><span class="line">            <span class="comment">//当前 消息队列是否阻塞 &amp;&amp; 队头的消息target=null &amp;&amp; 是否支持异步</span></span><br><span class="line">            <span class="comment">//target == null 为什么可以为null？不是不能为null吗？见后面</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="comment">//寻找插入点</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//插入消息</span></span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="comment">//是否需要唤醒？mPtr used by native code</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="target-null-为什么可以为null？不是不能为null吗？"><a href="#target-null-为什么可以为null？不是不能为null吗？" class="headerlink" title="target == null 为什么可以为null？不是不能为null吗？"></a>target == null 为什么可以为null？不是不能为null吗？</h3><p><br />因为提供了骚操作，还有这种打开方式。<br />postSyncBarrier。 以前叫enqueueSyncBarrier 网上找的其它有写到这个<br />Barrier 可以联想到JUC的CyclicBarrier。<br />就是插入一下Barrier消息,这个消息之后的所有消息会阻塞在这个消息之后。<br /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//添加现在的时间</span></span><br><span class="line">        <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息入队</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">        <span class="comment">// We don't need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">            <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            msg.arg1 = token;</span><br><span class="line">            <span class="comment">//这里没有setTarget ，所以是null的</span></span><br><span class="line">            Message prev = <span class="keyword">null</span>;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="comment">//寻找插入点</span></span><br><span class="line">            <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//插入这个Barrier消息</span></span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> token;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="异步消息？"><a href="#异步消息？" class="headerlink" title="异步消息？"></a>异步消息？</h4><p><br />作者：AngelDevil<br /><br><br />出处：<a href="https://www.cnblogs.com/angeldevil/p/3340644.html">https://www.cnblogs.com/angeldevil/p/3340644.html</a><br /><br><br />转载请注明出处！<br /><br><br />所谓的异步消息其实就是这样的，我们可以通过enqueueBarrier往消息队列中插入一个Barrier，那么队列中执行时间在这个Barrier以后的同步消息都会被这个Barrier拦截住无法执行，直到我们调用removeBarrier移除了这个Barrier，而异步消息则没有影响，消息默认就是同步消息，除非我们调用了Message的setAsynchronous，这个方法是隐藏的。只有在初始化Handler时通过参数指定往这个Handler发送的消息都是异步的，这样在Handler的enqueueMessage中就会调用Message的setAsynchronous设置消息是异步的，从上面Handler.enqueueMessage的代码中可以看到。<br /><br><br />所谓异步消息，其实只有一个作用，就是在设置Barrier时仍可以不受Barrier的影响被正常处理，如果没有设置Barrier，异步消息就与同步消息没有区别，可以通过removeSyncBarrier移除Barrier：</p>
<hr>
<h3 id="nativeWake唤醒-nativePollOnce-睡眠"><a href="#nativeWake唤醒-nativePollOnce-睡眠" class="headerlink" title="nativeWake唤醒 ?  nativePollOnce?睡眠"></a>nativeWake唤醒 ?  nativePollOnce?睡眠</h3><p><br />native方法。轮询利用epoll机制<br />有点类似wait 与 notify。<br />具体见后面的native分析<br /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWake</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativePollOnce</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> timeoutMillis)</span></span>; <span class="comment">/*non-static for callbacks*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三-Handler-处理消息及延时消息-—-gt-出队"><a href="#三-Handler-处理消息及延时消息-—-gt-出队" class="headerlink" title="三. Handler 处理消息及延时消息 —&gt;  出队"></a>三. Handler 处理消息及延时消息 —&gt;  出队</h2><p><br />消息是怎么处理的呢？<br /><br><br />通过调用Looper.loop()方法，开始处理消息<br /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//获取当前线程的Looper</span></span><br><span class="line">      <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">      <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">      <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">      <span class="comment">//清空远程调用端的uid和pid，用当前本地进程的uid和pid替代；</span></span><br><span class="line">      Binder.clearCallingIdentity();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">      <span class="comment">// adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start'</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> thresholdOverride =</span><br><span class="line">              SystemProperties.getInt(<span class="string">"log.looper."</span></span><br><span class="line">                      + Process.myUid() + <span class="string">"."</span></span><br><span class="line">                      + Thread.currentThread().getName()</span><br><span class="line">                      + <span class="string">".slow"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//这里开始处理消息，死循环</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">//这里可能阻塞,现在没有消息需要处理的消息</span></span><br><span class="line">          Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">          <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">              <span class="comment">//msg = null，消息队列退出了，退出死循环</span></span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">          <span class="comment">//每次更新log，防止被set了最新的了，打印分发log</span></span><br><span class="line">          <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">          <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">              logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                      msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">          <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line">          <span class="keyword">long</span> slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;</span><br><span class="line">          <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">              slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDelivery = (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.when &gt; <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDispatch = (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">boolean</span> needStartTime = logSlowDelivery || logSlowDispatch;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">boolean</span> needEndTime = logSlowDispatch;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">              Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> dispatchStart = needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> dispatchEnd;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//这里开始调用 target来处理消息，tartget就是Hander</span></span><br><span class="line">              <span class="comment">// 转而调用到我们重写的dispatchMessage 方法里面去</span></span><br><span class="line">              msg.target.dispatchMessage(msg);</span><br><span class="line">              dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                  Trace.traceEnd(traceTag);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//下面主要是打印log，消息处理可能延时</span></span><br><span class="line">          <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">              <span class="keyword">if</span> (slowDeliveryDetected) &#123;</span><br><span class="line">                  <span class="keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                      Slog.w(TAG, <span class="string">"Drained"</span>);</span><br><span class="line">                      slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="string">"delivery"</span>,</span><br><span class="line">                          msg)) &#123;</span><br><span class="line">                      <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                      slowDeliveryDetected = <span class="keyword">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">              showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">"dispatch"</span>, msg);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">              logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">          <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">          <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">              Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                      + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                      + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                      + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                      + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//回收消息</span></span><br><span class="line">          msg.recycleUnchecked();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><br />回收消息，标记清空，添加缓存池<br /><br><br />android.os.Message#recycleUnchecked<br /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recycles a Message that may be in-use.</span></span><br><span class="line"><span class="comment"> * Used internally by the MessageQueue and Looper when disposing of queued Messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">    <span class="comment">// Clear out all other details.</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = -<span class="number">1</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br />主要来看一下怎么取的消息？<br /><br><br />android.os.MessageQueue#next<br /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">     <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">     <span class="comment">// which is not supported.</span></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">     <span class="comment">//mPtr 退出了, return null，前面的 Looper.loop 收到null消息就退出死循环了</span></span><br><span class="line">     <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//什么是 IdleHandler ？见后面</span></span><br><span class="line">     <span class="comment">//这个现在主要做标记</span></span><br><span class="line">     <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">     <span class="comment">// 休息时间</span></span><br><span class="line">     <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">             Binder.flushPendingCommands();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//本地方法</span></span><br><span class="line">         nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">             <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">             <span class="comment">//取消息</span></span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">             Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">             Message msg = mMessages;</span><br><span class="line">             <span class="comment">//msg ！= null，但是target = null，前面说了这个是barrier消息</span></span><br><span class="line">             <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                 <span class="comment">//继续寻找下一个barrier消息,找到一个不是异步的消息退出</span></span><br><span class="line">                 <span class="comment">//为什么不处理这个barrier？barrier 就是一个时间界限，且没有Handler，消息队列就是按时间排序的，处理到了当前这个barrier消息，说明时间满足</span></span><br><span class="line">                 <span class="keyword">do</span> &#123;</span><br><span class="line">                     prevMsg = msg;</span><br><span class="line">                     msg = msg.next;</span><br><span class="line">                 &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">//若果现在的时间还小于这个消息设置的执行时间</span></span><br><span class="line">                 <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                     <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                     <span class="comment">//计算一下可以休息多久时间</span></span><br><span class="line">                     nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">//如果时间满足,就是这个消息了，返回这个消息给loop</span></span><br><span class="line">                     <span class="comment">// Got a message.</span></span><br><span class="line">                     mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                     <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         prevMsg.next = msg.next;</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         mMessages = msg.next;</span><br><span class="line">                     &#125;</span><br><span class="line">                     msg.next = <span class="keyword">null</span>;</span><br><span class="line">                     <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                     msg.markInUse();</span><br><span class="line">                     <span class="keyword">return</span> msg;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// No more messages.</span></span><br><span class="line">                 nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">             <span class="comment">//可能在这个时间，退出了</span></span><br><span class="line">             <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                 dispose();</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">             <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">             <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">// pendingIdleHandlerCount = -1 标记没有被改。有空闲了，处理IdleHandler</span></span><br><span class="line">             <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                     &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                 pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//居然没有IdleHandler？那就可以休息了 </span></span><br><span class="line">             <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                 <span class="comment">//标记我要休息了,发送消息的时候，可以判断是否需要唤醒我</span></span><br><span class="line">                 mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                 <span class="comment">// 直接continue ，在上面的   nativePollOnce(ptr, nextPollTimeoutMillis)就是睡眠了</span></span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//把 mIdleHandlers 转化到 mPendingIdleHandlers </span></span><br><span class="line">             <span class="comment">//mIdleHandlers 是会变化的</span></span><br><span class="line">             <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">             &#125;</span><br><span class="line">             mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="comment">// Run the idle handlers.</span></span><br><span class="line">         <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">         <span class="comment">//下面就是处理IdleHandler了</span></span><br><span class="line">         <span class="comment">// 显然这里面不能做耗时操作，不然会影响消息的及时处理</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">             <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">             mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 keep = idler.queueIdle();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                 Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                 <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                     mIdleHandlers.remove(idler);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//处理完了，标记复位</span></span><br><span class="line">         <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">         pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">         <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">         <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">         <span class="comment">//在处理IdleHandler的过程中，没有睡眠，可能有新的消息来了，不能睡眠</span></span><br><span class="line">         nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<h3 id="什么是-IdleHandler-？"><a href="#什么是-IdleHandler-？" class="headerlink" title="什么是 IdleHandler ？"></a>什么是 IdleHandler ？</h3><p><br />IdleHandler 可以用来提升性能，主要用在我们希望能够在当前线程消息队列空闲时做些事情（譬如 UI 线程在显示完成后，如果线程空闲我们就可以提前准备其他内容）的情况下，不过最好不要做耗时操作。具体用法如下。<br /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getMainLooper().myQueue()或者Looper.myQueue()</span></span><br><span class="line">Looper.myQueue().addIdleHandler(<span class="keyword">new</span> IdleHandler() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//你要处理的事情</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="可能存在的问题？"><a href="#可能存在的问题？" class="headerlink" title="可能存在的问题？"></a>可能存在的问题？</h3><ul>
<li><p>消息不是及时处理的，及时性不保证。</p>
</li>
<li><p>我发送了一个延时MSG，这个MSG在没有被处理的情况下，这个MSG可能持有了其它引用导致内存泄漏。所以在在Activity退出的时候，clear一下msg，清掉handler。</p>
</li>
<li><p>类似 <a href="https://www.dazhuanlan.com/2019/09/29/5d907aee90758/">Dialog引发的内存泄漏</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">//假设这是循环的第10次,然后这里阻塞了。然后其它地方刚好从线程池里面取走了一个消息，但是没有被发送。</span></span><br><span class="line">    <span class="comment">// 想一想这个msg依然持有对第9次消息的引用,并在读到消息的时候覆盖。间接的这个msg就保持其它引用。</span></span><br><span class="line">    Message msg = queue.next();</span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    msg.target.dispatchMessage(msg);</span><br><span class="line">    <span class="comment">//第9次取的消息，在这里标记复位了，表示回收了</span></span><br><span class="line">    msg.recycleUnchecked();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里可以加一句</span></span><br><span class="line">    msg = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后用一张图，来表示整个消息机制<br /><br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/501385/1586956920650-584b7b4d-8387-4f6f-9887-255e1d5a4618.jpeg#align=left&display=inline&height=550&margin=%5Bobject%20Object%5D&originHeight=550&originWidth=902&size=0&status=done&style=none&width=902" alt=""></p>
</li>
</ul>
<hr>
<h2 id="四-Native层"><a href="#四-Native层" class="headerlink" title="四. Native层"></a>四. Native层</h2><p><br />主要分析 nativeWake（）  nativePollOnce() 方法 实现<br /><br><br />够着MessageQueue的时候调用了nativeInit();<br /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">        mQuitAllowed = quitAllowed;</span><br><span class="line">        <span class="comment">// 通过JNI调用了Native层的相关函数，导致了NativeMessageQueue的创建</span></span><br><span class="line">        mPtr = nativeInit();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><br />对应的 C++ 层的实现<br /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在Native层又创建了NativeMessageQueue</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();</span><br><span class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Unable to allocate native queue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nativeMessageQueue-&gt;incStrong(env);</span><br><span class="line">     <span class="comment">// 这里返回值是Java层的mPtr，因此mPtr实际上是Java层MessageQueue与NativeMessesageQueue的桥梁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此时Java层和Native层的MessageQueue被mPtr连接起来了，NativeMessageQueue只是Java层MessageQueue在Native层的体现，其本身并没有实现Queue的数据结构，而是从其父类MessageQueue中继承mLooper变量。与Java层类型，这个Looper也是线程级别的单列。</span><br></pre></td></tr></table></figure>

<p><br />NativeMessageQueue无参构造函数<br /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NativeMessageQueue::NativeMessageQueue() : mPollEnv(<span class="literal">NULL</span>), mPollObj(<span class="literal">NULL</span>), mExceptionObj(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取TLS中的Looper对象</span></span><br><span class="line">    mLooper = Looper::getForThread(); </span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建native层的Looper对象</span></span><br><span class="line">        mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>); </span><br><span class="line">         <span class="comment">// 保存native 层的Looper到TLS中(线程级单例)</span></span><br><span class="line">        Looper::setForThread(mLooper); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>Looper::getForThread()：功能类比于Java层的Looper.myLooper();</li>
<li>Looper::setForThread(mLooper)：功能类比于Java层的ThreadLocal.set()</li>
</ul>
<p><br />通过上述代码我们知道：<br /></p>
<ul>
<li>1、Java层的Looper的创建导致了MessageQueue的创建，而在Native层则刚刚相反，NativeMessageQueue的创建导致了Looper的创建</li>
<li>2、MessageQueue是在Java层与Native层有着紧密的联系，但是此次Native层的Looper与Java层的Looper没有任何关系。</li>
<li>3、Native层的Looper创建和Java层的也完全不一样，它利用了Linux的epoll机制检测了Input的fd和唤醒fd。从功能上来讲，这个唤醒fd才是真正处理Java Message和Native Message的钥匙。</li>
</ul>
<p><br />所以创建MessageQueue的流程如图<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/501385/1586956918477-d2250519-d8d1-4a5a-8a67-f6c0ad101f21.png#align=left&display=inline&height=650&margin=%5Bobject%20Object%5D&originHeight=650&originWidth=710&size=0&status=done&style=none&width=710" alt=""><br /></p>
<h4 id="为什么要关联一个Native-MessageQueue"><a href="#为什么要关联一个Native-MessageQueue" class="headerlink" title="为什么要关联一个Native MessageQueue ???"></a>为什么要关联一个Native MessageQueue ???</h4><p><br />首先Native 层也提供了 sendMesage,其它地方可以向这个消息队列发送消息。比如响应点击事件，WMS中接收到消息后，会调用ViewRootImpl中的dispatchInputEvent<br /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Looper::sendMessage</span><span class="params">(<span class="keyword">const</span> sp&lt;MessageHandler&gt;&amp; handler, <span class="keyword">const</span> Message&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">    sendMessageAtTime(now, handler, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Looper::sendMessageAtTime</span><span class="params">(<span class="keyword">nsecs_t</span> uptime, <span class="keyword">const</span> sp&lt;MessageHandler&gt;&amp; handler,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> Message&amp; message)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_CALLBACKS</span></span><br><span class="line">    ALOGD(<span class="string">"%p ~ sendMessageAtTime - uptime=%"</span> PRId64 <span class="string">", handler=%p, what=%d"</span>,</span><br><span class="line">            <span class="keyword">this</span>, uptime, handler.<span class="built_in">get</span>(), message.what);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">       <span class="comment">// 请求锁</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> messageCount = mMessageEnvelopes.<span class="built_in">size</span>();</span><br><span class="line">       <span class="comment">// 找到message应该插入的位置i</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">MessageEnvelope <span class="title">messageEnvelope</span><span class="params">(uptime, handler, message)</span></span>;</span><br><span class="line">        mMessageEnvelopes.insertAt(messageEnvelope, i, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Optimization: If the Looper is currently sending a message, then we can skip</span></span><br><span class="line">        <span class="comment">// the call to wake() because the next thing the Looper will do after processing</span></span><br><span class="line">        <span class="comment">// messages is to decide when the next wakeup time should be.  In fact, it does</span></span><br><span class="line">        <span class="comment">// not even matter whether this code is running on the Looper thread.</span></span><br><span class="line">        <span class="comment">// 如果当前正在发送消息，那么不再调用wake()，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (mSendingMessage) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="comment">// Wake the poll loop only when we enqueue a new message at the head.</span></span><br><span class="line">    <span class="comment">// 当消息加入到消息队列的头部时，需要唤醒poll循环</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>sendMessage()和sendMessageDelayed()都是调用sendMessageAtTime()来完成消息插</li>
<li>sendMessageAtTime() 和上面Java层类似</li>
<li>MessageQueue成为Java层和Native层的枢纽，既能处理上层消息，也能处理Native消息，当然Native层消息是Native层Hanlder处理。</li>
<li><br />



</li>
</ul>
<h4 id="感觉自己写一个Handler-根本用不到native-的-MessageQueue-？？？"><a href="#感觉自己写一个Handler-根本用不到native-的-MessageQueue-？？？" class="headerlink" title="感觉自己写一个Handler 根本用不到native 的 MessageQueue ？？？"></a>感觉自己写一个Handler 根本用不到native 的 MessageQueue ？？？</h4><h4 id="为什么主线程android-app-ActivityThread-main-里面明明有个-Looper-loop-却不会卡UI主线程？"><a href="#为什么主线程android-app-ActivityThread-main-里面明明有个-Looper-loop-却不会卡UI主线程？" class="headerlink" title="为什么主线程android.app.ActivityThread#main  里面明明有个        Looper.loop() 却不会卡UI主线程？"></a>为什么主线程android.app.ActivityThread#main  里面明明有个        Looper.loop() 却不会卡UI主线程？</h4><p><br />因为UI事件本身也是通过主线程的Handelr机制去处理的。当前主线程loop了，还有消息从其它地方过来。当前Activity的可以响应回调事件和 广播事件。<br />引用 <a href="https://stackoverflow.com/questions/35931899/why-main-threads-looper-loop-doesnt-block-ui-thread">https://stackoverflow.com/questions/35931899/why-main-threads-looper-loop-doesnt-block-ui-thread</a><br /></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If there is no message, it means that no updates are required. All of our code is just a callback, such as Application onCreate, Activit onCreate, BroadcastReceiver onReceive.</span><br><span class="line"></span><br><span class="line">All update callbacks are caused by the message, and these messages are from the system services, such as ActivityManagerService, InputManagerService, WindowMangerService. If you need to update the UI, the android service will send a message to the loop via the IPC.</span><br></pre></td></tr></table></figure>


<h4 id="nativePollOnce"><a href="#nativePollOnce" class="headerlink" title="nativePollOnce()"></a>nativePollOnce()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将Java层传递下来的mPtr转换为nativeMessageQueue</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>首先，将Java层传递下来的mPtr转换为nativeMessageQueue</li>
<li>其次，nativeMessageQueue调用pollOnce(env, obj, timeoutMillis)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NativeMessageQueue::pollOnce</span><span class="params">(JNIEnv* env, jobject pollObj, <span class="keyword">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    mPollEnv = env;</span><br><span class="line">    mPollObj = pollObj;</span><br><span class="line">    <span class="comment">// 重点函数</span></span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">    mPollObj = <span class="literal">NULL</span>;</span><br><span class="line">    mPollEnv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mExceptionObj) &#123;</span><br><span class="line">        env-&gt;Throw(mExceptionObj);</span><br><span class="line">        env-&gt;DeleteLocalRef(mExceptionObj);</span><br><span class="line">        mExceptionObj = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>调用pollOnce(timeoutMillis),最后调用到 Looper::pollOnce(int, int, int, void**)函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Looper::pollOnce</span><span class="params">(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 对fd对应的Responses进行处理，后面发现Response里都是活动fd</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 先处理没有Callback的Response事件</span></span><br><span class="line">        <span class="keyword">while</span> (mResponseIndex &lt; mResponses.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">const</span> Response&amp; response = mResponses.itemAt(mResponseIndex++);</span><br><span class="line">            <span class="keyword">int</span> ident = response.request.ident;</span><br><span class="line">            <span class="keyword">if</span> (ident &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// ident&gt;=0则表示没有callback，因为POLL_CALLBACK=-2</span></span><br><span class="line">                <span class="keyword">int</span> fd = response.request.fd;</span><br><span class="line">                <span class="keyword">int</span> events = response.events;</span><br><span class="line">                <span class="keyword">void</span>* data = response.request.data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">                ALOGD(<span class="string">"%p ~ pollOnce - returning signalled identifier %d: "</span></span><br><span class="line">                        <span class="string">"fd=%d, events=0x%x, data=%p"</span>,</span><br><span class="line">                        <span class="keyword">this</span>, ident, fd, events, data);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                <span class="keyword">if</span> (outFd != <span class="literal">NULL</span>) *outFd = fd;</span><br><span class="line">                <span class="keyword">if</span> (outEvents != <span class="literal">NULL</span>) *outEvents = events;</span><br><span class="line">                <span class="keyword">if</span> (outData != <span class="literal">NULL</span>) *outData = data;</span><br><span class="line">                <span class="keyword">return</span> ident;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 注意这里处于循环内部，改变result的值在后面的pollInner</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">            ALOGD(<span class="string">"%p ~ pollOnce - returning result %d"</span>, <span class="keyword">this</span>, result);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">if</span> (outFd != <span class="literal">NULL</span>) *outFd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outEvents != <span class="literal">NULL</span>) *outEvents = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outData != <span class="literal">NULL</span>) *outData = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再处理内部轮训</span></span><br><span class="line">        result = pollInner(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br />Looper::pollInner()函数<br /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">Looper::pollInner</span><span class="params">(<span class="keyword">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">    ALOGD(<span class="string">"%p ~ pollOnce - waiting: timeoutMillis=%d"</span>, <span class="keyword">this</span>, timeoutMillis);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adjust the timeout based on when the next message is due.</span></span><br><span class="line">    <span class="keyword">if</span> (timeoutMillis != <span class="number">0</span> &amp;&amp; mNextMessageUptime != LLONG_MAX) &#123;</span><br><span class="line">        <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        <span class="keyword">int</span> messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);</span><br><span class="line">        <span class="keyword">if</span> (messageTimeoutMillis &gt;= <span class="number">0</span></span><br><span class="line">                &amp;&amp; (timeoutMillis &lt; <span class="number">0</span> || messageTimeoutMillis &lt; timeoutMillis)) &#123;</span><br><span class="line">            timeoutMillis = messageTimeoutMillis;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">        ALOGD(<span class="string">"%p ~ pollOnce - next message in %"</span> PRId64 <span class="string">"ns, adjusted timeout: timeoutMillis=%d"</span>,</span><br><span class="line">                <span class="keyword">this</span>, mNextMessageUptime - now, timeoutMillis);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Poll.</span></span><br><span class="line">    <span class="keyword">int</span> result = POLL_WAKE;</span><br><span class="line">    mResponses.<span class="built_in">clear</span>();</span><br><span class="line">    mResponseIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are about to idle.</span></span><br><span class="line">     <span class="comment">// 即将处于idle状态</span></span><br><span class="line">    mPolling = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// fd最大的个数是16</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="comment">// 等待时间发生或者超时，在nativeWake()方法，向管道写端写入字符，则方法会返回。</span></span><br><span class="line">    <span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No longer idling.</span></span><br><span class="line">    <span class="comment">// 不再处于idle状态</span></span><br><span class="line">    mPolling = <span class="literal">false</span>;</span><br><span class="line">     <span class="comment">// 请求锁 ，因为在Native Message的处理和添加逻辑上需要同步</span></span><br><span class="line">    <span class="comment">// Acquire lock.</span></span><br><span class="line">    mLock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rebuild epoll set if needed.</span></span><br><span class="line">    <span class="comment">// 如果需要，重建epoll</span></span><br><span class="line">    <span class="keyword">if</span> (mEpollRebuildRequired) &#123;</span><br><span class="line">        mEpollRebuildRequired = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// epoll重建，直接跳转到Done</span></span><br><span class="line">        rebuildEpollLocked();</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for poll error.</span></span><br><span class="line">    <span class="keyword">if</span> (eventCount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">            <span class="keyword">goto</span> Done;</span><br><span class="line">        &#125;</span><br><span class="line">        ALOGW(<span class="string">"Poll failed with an unexpected error, errno=%d"</span>, errno);</span><br><span class="line">        <span class="comment">// epoll事件个数小于0，发生错误，直接跳转Done</span></span><br><span class="line">        result = POLL_ERROR;</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for poll timeout.</span></span><br><span class="line">    <span class="comment">//如果需要，重建epoll</span></span><br><span class="line">    <span class="keyword">if</span> (eventCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//epoll事件个数等于0，发生超时，直接跳转Done</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">        ALOGD(<span class="string">"%p ~ pollOnce - timeout"</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        result = POLL_TIMEOUT;</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle all events.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">    ALOGD(<span class="string">"%p ~ pollOnce - handling events from %d fds"</span>, <span class="keyword">this</span>, eventCount);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   <span class="comment">// 循环处理所有的事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">        <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">        <span class="comment">//首先处理mWakeEventFd</span></span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeEventFd) &#123;</span><br><span class="line">            <span class="comment">//如果是唤醒mWakeEventFd有反应</span></span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="comment">/**重点代码*/</span></span><br><span class="line">                <span class="comment">// 已经唤醒了，则读取并清空管道数据</span></span><br><span class="line">                awoken();  <span class="comment">// 该函数内部就是read，从而使FD可读状态被清除</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on wake event fd."</span>, epollEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他input fd处理，其实就是将活动放入response队列，等待处理</span></span><br><span class="line">            <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">            <span class="keyword">if</span> (requestIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> events = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</span><br><span class="line">                 <span class="comment">// 处理request，生成对应的response对象，push到响应数组</span></span><br><span class="line">                pushResponse(events, mRequests.valueAt(requestIndex));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on fd %d that is "</span></span><br><span class="line">                        <span class="string">"no longer registered."</span>, epollEvents, fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Done: ;</span><br><span class="line">    <span class="comment">// Invoke pending message callbacks.</span></span><br><span class="line">    <span class="comment">// 再处理Native的Message，调用相应回调方法</span></span><br><span class="line">    mNextMessageUptime = LLONG_MAX;</span><br><span class="line">    <span class="keyword">while</span> (mMessageEnvelopes.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        <span class="keyword">const</span> MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (messageEnvelope.uptime &lt;= now) &#123;</span><br><span class="line">            <span class="comment">// Remove the envelope from the list.</span></span><br><span class="line">            <span class="comment">// We keep a strong reference to the handler until the call to handleMessage</span></span><br><span class="line">            <span class="comment">// finishes.  Then we drop it so that the handler can be deleted *before*</span></span><br><span class="line">            <span class="comment">// we reacquire our lock.</span></span><br><span class="line">            &#123; <span class="comment">// obtain handler</span></span><br><span class="line">                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</span><br><span class="line">                Message message = messageEnvelope.message;</span><br><span class="line">                mMessageEnvelopes.removeAt(<span class="number">0</span>);</span><br><span class="line">                mSendingMessage = <span class="literal">true</span>;</span><br><span class="line">                 <span class="comment">// 释放锁</span></span><br><span class="line">                mLock.unlock();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS</span></span><br><span class="line">                ALOGD(<span class="string">"%p ~ pollOnce - sending message: handler=%p, what=%d"</span>,</span><br><span class="line">                        <span class="keyword">this</span>, handler.<span class="built_in">get</span>(), message.what);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                <span class="comment">// 处理消息事件</span></span><br><span class="line">                handler-&gt;handleMessage(message);</span><br><span class="line">            &#125; <span class="comment">// release handler</span></span><br><span class="line">            <span class="comment">// 请求锁</span></span><br><span class="line">            mLock.lock();</span><br><span class="line">            mSendingMessage = <span class="literal">false</span>;</span><br><span class="line">             <span class="comment">// 发生回调</span></span><br><span class="line">            result = POLL_CALLBACK;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The last message left at the head of the queue determines the next wakeup time.</span></span><br><span class="line">            mNextMessageUptime = messageEnvelope.uptime;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release lock.</span></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    mLock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke all response callbacks.</span></span><br><span class="line">    <span class="comment">// 处理带有Callback()方法的response事件，执行Response相应的回调方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mResponses.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        Response&amp; response = mResponses.editItemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class="line">            <span class="keyword">int</span> fd = response.request.fd;</span><br><span class="line">            <span class="keyword">int</span> events = response.events;</span><br><span class="line">            <span class="keyword">void</span>* data = response.request.data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS</span></span><br><span class="line">            ALOGD(<span class="string">"%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p"</span>,</span><br><span class="line">                    <span class="keyword">this</span>, response.request.callback.<span class="built_in">get</span>(), fd, events, data);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="comment">// Invoke the callback.  Note that the file descriptor may be closed by</span></span><br><span class="line">            <span class="comment">// the callback (and potentially even reused) before the function returns so</span></span><br><span class="line">            <span class="comment">// we need to be a little careful when removing the file descriptor afterwards.</span></span><br><span class="line">            <span class="comment">// 处理请求的回调方法</span></span><br><span class="line">            <span class="keyword">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br><span class="line">            <span class="keyword">if</span> (callbackResult == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 移除fd</span></span><br><span class="line">                removeFd(fd, response.request.seq);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Clear the callback reference in the response structure promptly because we</span></span><br><span class="line">            <span class="comment">// will not clear the response vector itself until the next poll.</span></span><br><span class="line">             <span class="comment">// 清除response引用的回调方法</span></span><br><span class="line">            response.request.callback.<span class="built_in">clear</span>();</span><br><span class="line">             <span class="comment">// 发生回调</span></span><br><span class="line">            result = POLL_CALLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br />pollOnce返回值说明<br /></p>
<ul>
<li>POLL_WAKE： 表示由wake()出发，即pipe写端的write事件触发</li>
<li>POLL_CALLBACK：表示某个被监听fd被触发</li>
<li>POLL_TIMEOUT：表示等待超时</li>
<li>POLL_ERROR：表示等待期间发生错误</li>
</ul>
<p><br />pollInner()方法的处理流程：<br /></p>
<ul>
<li>1、先调用epoll_wait()，这是阻塞方法，用于等待事件发生或者超时。</li>
<li>2、对于epoll_wait()返回，当且仅当以下3种情况出现<ul>
<li>POLL_ERROR：发生错误，直接跳转Done</li>
<li>POLL_TIMEOUT：发生超时，直接跳转到Done</li>
<li>检测到管道有事情发生，则再根据情况做相应处理：<ul>
<li>如果检测到管道产生事件，则直接读取管道的数据</li>
<li>如果是其他事件，则处理request，生成对应的response对象，push到response数组</li>
</ul>
</li>
</ul>
</li>
<li>3、进入Done标记位的代码：<ul>
<li>先处理Native的Message，调用Native的Handler来处理该Message</li>
<li>再处理Resposne数组，POLL_CALLBACK类型的事件</li>
</ul>
</li>
</ul>
<p><br />总结一下 nativePollOnce() 的流程就是<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/501385/1586956918564-08b3b13e-ec46-44f0-a60b-97b0cdb2b86e.png#align=left&display=inline&height=709&margin=%5Bobject%20Object%5D&originHeight=709&originWidth=725&size=0&status=done&style=none&width=725" alt=""><br /></p>
<h4 id="nativeWake"><a href="#nativeWake" class="headerlink" title="nativeWake()"></a>nativeWake()</h4><p><br />android_os_MessageQueue_nativeWake()<br /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将Java层传递下来的mPtr转换为nativeMessageQueue</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    <span class="comment">//调用wake函数</span></span><br><span class="line">    nativeMessageQueue-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NativeMessageQueue::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Looper::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">    ALOGD(<span class="string">"%p ~ wake"</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> inc = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 向管道mWakeEventFd写入字符1</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite = TEMP_FAILURE_RETRY(<span class="built_in">write</span>(mWakeEventFd, &amp;inc, <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)));</span><br><span class="line">    <span class="keyword">if</span> (nWrite != <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Could not write wake signal, errno=%d"</span>, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Looper类的 wake()函数只是往mWakeEventfd中写了一些内容，这个fd只是通知而已，类似于pipi，最后会把epoll_wai唤醒，线程就不阻塞了继续发送</span><br><span class="line">Native层的消息，然后处理之前的addFd事件，然后处理Java层的消息。</span><br></pre></td></tr></table></figure>

<p><br />总结一下 nativeWake() 的流程就是<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/501385/1586956919035-0575e298-b9eb-44a5-bd36-c285f28195a0.png#align=left&display=inline&height=717&margin=%5Bobject%20Object%5D&originHeight=717&originWidth=728&size=0&status=done&style=none&width=728" alt=""><br /></p>
<h3 id="Native与Java的对应关系"><a href="#Native与Java的对应关系" class="headerlink" title="Native与Java的对应关系"></a>Native与Java的对应关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue通过mPtr变量保存了NativeMessageQueue对象，从而使得MessageQueue成为Java层和Native层的枢纽，既能处理上层消息，也能处理Native消息，下图列举了Java层与Native层的对应图</span><br></pre></td></tr></table></figure>

<p><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/501385/1586956918546-eab719a0-e18e-4d65-8f1f-768ed2a35469.png#align=left&display=inline&height=422&margin=%5Bobject%20Object%5D&originHeight=422&originWidth=947&size=0&status=done&style=none&width=947" alt=""><br /></p>
<ul>
<li>1、红色虚线关系：Java层和Native层的MessageQueue通过JNI建立关联，彼此之间能相互调用，搞明白这个互调关系，也就搞明白Java如何调用C代码，C代码如何调用Java代码</li>
<li>2、蓝色虚线关系：Handler/Looper/Message这三大类Java层与Native层并没有任何真正的关系，只是分别在Java层和Native层的handler消息模型中具有相似的功能。都是彼此独立的，各自实现相应的逻辑。</li>
<li>3、WeakMessageHandler继承与MessageHandler类，NativeMessageQueue继承于MessageQueue类。</li>
</ul>
<p><br />另外，消息处理流程是先处理NativeMessage，再处理Native Request，最后处理Java Message。理解了该流程也就明白了有时上层消息很少，但响应时间却比较长的真正原因。<br /></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>1、<strong>NativeMessageQueue</strong>：在MessageQueue.java的构造函数中，调用了nativeInit创建了NativeMessageQueue对象，并且把指针变量返回给Java层的mPtr。而在NativeMessageQueue的构造函数中，会在当前线程中创建C++的Looper对象。</li>
<li>2、<strong>Looper</strong>：控制eventfd的读写，通过epoll监听eventfd的变化，来阻塞调用pollOnce和恢复调用wake当前线程<ul>
<li>通过 epoll监听其他文件描述符的变化</li>
<li>通过 epoll处理C++层的消息机制，当调用Looper::sendMessageAtTime后，调用wake触发epoll</li>
<li>Looper的构造函数，创建一个eventfd(以前版本是pipe)，eventfd它的主要用于进程或者线程间的通信，然后创建epoll来监听该eventfd的变化</li>
<li>Looper::pollOnce(int timeoutMillis) 内部调用了pollInner，再调用epoll_wait(mEpollFd, …, timeoutMillis)阻塞timeoutMills时间，并监听文件描述符mEpollFd的变化，当时间到了或者消息到了，即eventfd被写入内容后，从epoll_wait继续往下执行，处理epoll_wait返回的消息，该消息既有可能是eventfd产生的，也可能是其他文件描述符产生的。处理顺序是，先处理普通的C++消息队列mMessageEnvelopes，然后处理之前addFd的事件，最后从pollOnce返回，会继续MessageQueue.java的next()函数，取得Java层的消息来处理；</li>
<li>Looper类的wake，函数只是往mWakeEventfd中写了一些内容，这个fd只是通知而已，类似pipe，最后会把epoll_wait唤醒，线程就不阻塞了，继续先发送C层消息，然后处理之前addFd事件，然后处理Java层消息</li>
</ul>
</li>
</ul>
<hr>
<h2 id="五-感谢"><a href="#五-感谢" class="headerlink" title="五 . 感谢"></a>五 . 感谢</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;gityuan.com&#x2F;2015&#x2F;12&#x2F;26&#x2F;handler-message-framework&#x2F;</span><br><span class="line"></span><br><span class="line">作者：隔壁老李头</span><br><span class="line">链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;91a4b797553d</span><br><span class="line">来源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line">作者：Little丶Jerry</span><br><span class="line">链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;a1d945c4f5a6</span><br><span class="line">来源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Android/">Android</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/04/20/LeetCode/zhong-jian-er-cha-shu-lcof/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">重建二叉树</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/04/18/Java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%BC%95%E8%B5%B7%E7%9A%84Bug/"><span class="level-item">记一次类加载引起的Bug</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-2-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="/img/myavatar.png" alt="Ken"></figure><p class="title is-size-4 is-block line-height-inherit">Ken</p><p class="is-size-6 is-block">爱于心，鉴于行</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">70</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">16</p></a></div></div></nav></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Android/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%88%86%E4%BA%AB/"><span class="level-start"><span class="level-item">分享</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%A1%86%E6%9E%B6/"><span class="level-start"><span class="level-item">框架</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">计算机基础</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">语言基础</span></span><span class="level-end"><span class="level-item tag">26</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E9%97%AE%E9%A2%98%E4%B8%8E%E7%BB%8F%E9%AA%8C/"><span class="level-start"><span class="level-item">问题与经验</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/"><span class="level-start"><span class="level-item">项目架构</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2023-12-02T10:19:06.000Z">2023-12-02</time></p><p class="title is-6"><a class="link-muted" href="/2023/12/02/Android/android_import_rust/">Android项目接入Rust</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Android/">Android</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2023-11-07T09:30:35.000Z">2023-11-07</time></p><p class="title is-6"><a class="link-muted" href="/2023/11/07/Android/kotlin_name_dup/">Kotlin的变量重名问题</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">语言基础</a> / <a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/Kotlin/">Kotlin</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2023-10-14T10:09:12.000Z">2023-10-14</time></p><p class="title is-6"><a class="link-muted" href="/2023/10/14/Android/kotlin_android_init_no_method/">小心Kotlin下的构造函数NoSuchMethodException</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Android/">Android</a> / <a class="link-muted" href="/categories/Android/Kotlin/">Kotlin</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2023-08-12T07:45:13.000Z">2023-08-12</time></p><p class="title is-6"><a class="link-muted" href="/2023/08/12/Android/compose_inspector/">解决 Compose Layout Inspector 不能用</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Android/">Android</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2023-05-14T12:39:42.000Z">2023-05-14</time></p><p class="title is-6"><a class="link-muted" href="/2023/05/14/%E9%97%AE%E9%A2%98%E4%B8%8E%E7%BB%8F%E9%AA%8C/typetojson/">泛型的反序列化</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E9%97%AE%E9%A2%98%E4%B8%8E%E7%BB%8F%E9%AA%8C/">问题与经验</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag is-grey-lightest">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bug/"><span class="tag">Bug</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Compose/"><span class="tag">Compose</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Gradle/"><span class="tag">Gradle</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JNI/"><span class="tag">JNI</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag is-grey-lightest">23</span></a></div><div class="control"><a class="tags has-addons" href="/tags/K8S/"><span class="tag">K8S</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kotlin/"><span class="tag">Kotlin</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LeetCode/"><span class="tag">LeetCode</span><span class="tag is-grey-lightest">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spark/"><span class="tag">Spark</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E4%BA%AB/"><span class="tag">分享</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%89%E8%A3%85/"><span class="tag">安装</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%BB%84/"><span class="tag">计组</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-2-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget toc-scroll" id="toc"><div class="card-content"><div class="menu" style="max-height: 600px; overflow: auto;"><h3 class="menu-label">目录</h3><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-一-Handler初始化" href="#一-Handler初始化"><span>一. Handler初始化</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-Handler–-gt-Looper-lt-–-MessageQueue-lt-–-Message" href="#Handler–-gt-Looper-lt-–-MessageQueue-lt-–-Message"><span>Handler–&amp;gt; Looper &amp;lt;– MessageQueue &amp;lt;– Message</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-Handler-构造" href="#1-Handler-构造"><span>1. Handler 构造</span></a></li><li><a class="is-flex toc-item" id="toc-item-2-上面的mLooper-为什么可能为空？要调用-Looper-prepare" href="#2-上面的mLooper-为什么可能为空？要调用-Looper-prepare"><span>2. 上面的mLooper 为什么可能为空？要调用 Looper.prepare()?</span></a></li><li><a class="is-flex toc-item" id="toc-item-3-为什么有什么需要手动调用Looper-prepare-？" href="#3-为什么有什么需要手动调用Looper-prepare-？"><span>3. 为什么有什么需要手动调用Looper.prepare() ？</span></a></li><li><a class="is-flex toc-item" id="toc-item-总结" href="#总结"><span>总结</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-二-Handder-发送消息-—-gt-入队" href="#二-Handder-发送消息-—-gt-入队"><span>二. Handder 发送消息 —&amp;gt; 入队</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-target-null-为什么可以为null？不是不能为null吗？" href="#target-null-为什么可以为null？不是不能为null吗？"><span>target &amp;#x3D;&amp;#x3D; null 为什么可以为null？不是不能为null吗？</span></a></li><li><a class="is-flex toc-item" id="toc-item-nativeWake唤醒-nativePollOnce-睡眠" href="#nativeWake唤醒-nativePollOnce-睡眠"><span>nativeWake唤醒 ?  nativePollOnce?睡眠</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-三-Handler-处理消息及延时消息-—-gt-出队" href="#三-Handler-处理消息及延时消息-—-gt-出队"><span>三. Handler 处理消息及延时消息 —&amp;gt;  出队</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-什么是-IdleHandler-？" href="#什么是-IdleHandler-？"><span>什么是 IdleHandler ？</span></a></li><li><a class="is-flex toc-item" id="toc-item-可能存在的问题？" href="#可能存在的问题？"><span>可能存在的问题？</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-四-Native层" href="#四-Native层"><span>四. Native层</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-Native与Java的对应关系" href="#Native与Java的对应关系"><span>Native与Java的对应关系</span></a></li><li><a class="is-flex toc-item" id="toc-item-总结-1" href="#总结-1"><span>总结</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-五-感谢" href="#五-感谢"><span>五 . 感谢</span></a></li></ul></div></div><script type="text/javascript" async>
        $(document).ready(function () { //参考自 https://github.com/ppoffice/hexo-theme-icarus/pull/616/files
            var observerTopMargin;
            var scrollObserver;
            var headerElems = $(".headerlink");
            var activeTocItem;
        
            function initIntersectionObserver(docHeight) {
                observerTopMargin = docHeight;
                scrollObserver = new IntersectionObserver(scrollCallBack,
                    {
                        root: null,  // viewpoint
                        rootMargin: docHeight + "px 0px -80% 0px"  // cover top 30% of viewport to the top of document
                    })
            }
        
            function scrollCallBack(entries, observer) {
                if ($(window).scrollTop() > observerTopMargin * 0.7) { 
                    // User somehow scroll to 70% of observerTopMargin (which is inited as 200% document height)
                    // Observer top margin need to extend to cover all the space to the top of the document
                    initIntersectionObserver(observerTopMargin * 2)
                    observer.disconnect();
                    return;
                }
                let toActive;
                if (entries[0].intersectionRatio == 1) {  // enter viewed area
                    let entry = entries.reduce((u, v) => (u.target.toc_id > v.target.toc_id ? u : v));  // get the lowest item
                    toActive = $("#toc-item-" + $(entry.target).attr("href").substr(1));
                } else {
                    let entry = entries.reduce((u, v) => (u.target.toc_id < v.target.toc_id ? u : v));  // get the highest item
                    let idx = Math.max(entry.target.toc_id - 1, 0);
                    toActive = $("#toc-item-" + $(headerElems[idx]).attr("href").substr(1));
                }
                if (activeTocItem) activeTocItem.removeClass("is-current");
                activeTocItem = toActive
                activeTocItem.addClass("is-current");
            }
        
            initIntersectionObserver($(document).height() * 2);
            headerElems.each(function (index, obj) {
                obj.toc_id = index;
                scrollObserver.observe(obj);
            })
        });</script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="Keeplooking" height="28"></a><p class="size-small"><span>&copy; 2019 - 2024  Ken Chan</span>  </p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Fllow GitHub" href="https://github.com/kaiattrib"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>