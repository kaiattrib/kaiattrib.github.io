{"pages":[{"title":"关于","text":"写本博客的初心 一为备忘，感觉自己很健忘 二为探索，探索技术宽度与深度 三为分享，幸于有帮助到别人 欢迎指教","link":"/comments/index.html"},{"title":"种草计划","text":"过程同样重要 gradle项目管理 设计模式$$","link":"/suibi/studyplan.html"},{"title":"随笔，技术之外","text":"But I don’t know enough, I get some kinda of lazy day 种草计划 &nbsp;&nbsp;&nbsp;&nbsp;最近摊了一段时间，没有找到学习的方向，给自己立个Flag，输出学习笔记，偏向底层，通用的技术。 阅读更多","link":"/suibi/suibi.html"}],"posts":[{"title":"Android 幽灵设备 emulator-5554 offline","text":"遇到的问题：adb devices 出现了个 emulator-5554设置，导致插入安卓设备的时候，执行命令经常遇到 more than one devices错误。 排查过程：在stackoverflow上找了下，先尝试关闭了所有模拟器，都重启了好多次，还是没效果，排除了是模拟器搞鬼。于是按照网上找到查找5555端口的程序，netstate 和 lsof 过滤下5555端口，定位下pid，最后htop里面去查pid，查到是我之前安装的一个插件导致的。在我的mac上面tabnine插件默认占用了5555端口，导致adb认为是个模拟器，一直在尝试链接。找到一篇文档http://t.zoukankan.com/jiangu66-p-3184790.html adb 启动就连接5555端口 为何连接叫 emulator-5554 而不是 emulator-5555？这是因为缺省emulator的 console 端口是 5554 ( 应该可以用 telnet 连接与 emulator 交互(还没有试验)) , 而adb 的端口是console端口 +1 就是 5555 后面去tabbnie的github上看了看，原来之前就有人遇到过这个问题 https://github.com/codota/TabNine/issues/422 (Why bind port on 5555)，tabbnie后面也提供了修改端口的接口，Under tabnine_config.json, set tabnine_hub_port 解决方案:修改tabbnie的配置文件 tabnine_config.json里面的tabnine_hub_port 默认端口，例如4555。如果你找不到tabnine_config，请搜索。","link":"/2022/11/20/Android/android-emulator-5554/"},{"title":"JNI为什么要调用AttachCurrentThread？","text":"我们写JNI的时候，通常要通过 如果需要反调java层的代码，是需要通过jvm-&gt;AttachCurrentThread 将当前线程注册到虚拟机中，为什么一定要调用这个方法呢？我们追一下这个方法里面到底做了什么？ JNI AttachCurrentThread 采用的ART debug。所有方法里面的代码均有省略，并不是全部代码 我们可以在 jni.h，找到改方法的声明 123jint AttachCurrentThread(JNIEnv **p_env, void *thr_args) { return functions-&gt;AttachCurrentThread(this, p_env, thr_args);} 具体实现就要转到runtime了 继续找 art/runtime/check_jni.cc 的实现 12345678910static jint AttachCurrentThread(JavaVM* vm, JNIEnv** p_env, void* thr_args) { ScopedCheck sc(kFlag_Invocation, __FUNCTION__); JniValueType args[3] = {{.v = vm}, {.p = p_env}, {.p = thr_args}}; sc.CheckNonHeap(reinterpret_cast&lt;JavaVMExt*&gt;(vm), true, \"vpp\", args); JniValueType result; //这里转到 result.i = BaseVm(vm)-&gt;AttachCurrentThread(vm, p_env, thr_args); sc.CheckNonHeap(reinterpret_cast&lt;JavaVMExt*&gt;(vm), false, \"i\", &amp;result); return result.i;} 继续追 BaseVm(vm)-&gt;AttachCurrentThread 在 art/runtime/java_vm_ext.cc 中找到 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 static jint AttachCurrentThreadInternal(JavaVM* vm, JNIEnv** p_env, void* raw_args, bool as_daemon) { if (vm == nullptr || p_env == nullptr) { return JNI_ERR; } // Return immediately if we're already attached. Thread* self = Thread::Current(); if (self != nullptr) { *p_env = self-&gt;GetJniEnv(); return JNI_OK; } Runtime* runtime = reinterpret_cast&lt;JavaVMExt*&gt;(vm)-&gt;GetRuntime(); // No threads allowed in zygote mode. if (runtime-&gt;IsZygote()) { LOG(ERROR) &lt;&lt; \"Attempt to attach a thread in the zygote\"; return JNI_ERR; } JavaVMAttachArgs* args = static_cast&lt;JavaVMAttachArgs*&gt;(raw_args); const char* thread_name = nullptr; jobject thread_group = nullptr; if (args != nullptr) { if (JavaVMExt::IsBadJniVersion(args-&gt;version)) { LOG(ERROR) &lt;&lt; \"Bad JNI version passed to \" &lt;&lt; (as_daemon ? \"AttachCurrentThreadAsDaemon\" : \"AttachCurrentThread\") &lt;&lt; \": \" &lt;&lt; args-&gt;version; return JNI_EVERSION; } thread_name = args-&gt;name; thread_group = args-&gt;group; } //这里真实的调用了 runtime-&gt;AttachCurrentThread if (!runtime-&gt;AttachCurrentThread(thread_name, as_daemon, thread_group, !runtime-&gt;IsAotCompiler())) { *p_env = nullptr; return JNI_ERR; } else { //如果成功 *p_env = Thread::Current()-&gt;GetJniEnv(); return JNI_OK; } }}; 继续找 runtime-&gt;AttachCurrentThread art/runtime/runtime.cc 123456789101112 bool Runtime::AttachCurrentThread(const char* thread_name, bool as_daemon, jobject thread_group, bool create_peer) { ScopedTrace trace(__FUNCTION__); //实际上最终是在这里，在JVM层面包装成了一个 JVM 的 Thread，然后再返回 Thread* self = Thread::Attach(thread_name, as_daemon, thread_group, create_peer); // Run ThreadGroup.add to notify the group that this thread is now started. if (self != nullptr &amp;&amp; create_peer &amp;&amp; !IsAotCompiler()) { ScopedObjectAccess soa(self); self-&gt;NotifyThreadGroup(soa, thread_group); } return self != nullptr;} 继续再追一下 Thread::Attach的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 Thread* Thread::Attach(const char* thread_name, bool as_daemon, PeerAction peer_action) { Runtime* runtime = Runtime::Current(); if (runtime == nullptr) { LOG(ERROR) &lt;&lt; \"Thread attaching to non-existent runtime: \" &lt;&lt; ((thread_name != nullptr) ? thread_name : \"(Unnamed)\"); return nullptr; } Thread* self; { MutexLock mu(nullptr, *Locks::runtime_shutdown_lock_); if (runtime-&gt;IsShuttingDownLocked()) { LOG(WARNING) &lt;&lt; \"Thread attaching while runtime is shutting down: \" &lt;&lt; ((thread_name != nullptr) ? thread_name : \"(Unnamed)\"); return nullptr; } else { //开始初始化 Runtime::Current()-&gt;StartThreadBirth(); self = new Thread(as_daemon); //这里进行了初始化 bool init_success = self-&gt;Init(runtime-&gt;GetThreadList(), runtime-&gt;GetJavaVM()); //结束 Runtime::Current()-&gt;EndThreadBirth(); if (!init_success) { delete self; return nullptr; } } } self-&gt;InitStringEntryPoints(); CHECK_NE(self-&gt;GetState(), kRunnable); self-&gt;SetState(kNative); // Run the action that is acting on the peer. if (!peer_action(self)) { runtime-&gt;GetThreadList()-&gt;Unregister(self); // Unregister deletes self, no need to do this here. return nullptr; } if (VLOG_IS_ON(threads)) { if (thread_name != nullptr) { VLOG(threads) &lt;&lt; \"Attaching thread \" &lt;&lt; thread_name; } else { VLOG(threads) &lt;&lt; \"Attaching unnamed thread.\"; } ScopedObjectAccess soa(self); self-&gt;Dump(LOG_STREAM(INFO)); } { ScopedObjectAccess soa(self); runtime-&gt;GetRuntimeCallbacks()-&gt;ThreadStart(self); } return self;} 转接到 init 12345678910111213141516171819202122232425 bool Thread::Init(ThreadList* thread_list, JavaVMExt* java_vm, JNIEnvExt* jni_env_ext) { //该函数执行所有必须由其应用的本机线程运行的初始化 //当我们从managed code 创建新线程时，在Thread :: Create中分配Thread *，这样可以在准备好时与相应的本机线程握手 CHECK(Thread::Current() == nullptr); //将pthread_self_设置在pthread_setspecific之前， tlsPtr_.pthread_self = pthread_self(); CHECK(is_started_); //各种init InitCpu(); InitTlsEntryPoints(); RemoveSuspendTrigger(); InitCardTable(); InitTid(); interpreter::InitInterpreterTls(this); //各种CHECK //把当前线程注册，实际就是push到thread_list thread_list-&gt;Register(this); //直接return true return true;} 可以看到 ThreadList::Register(Thread* self) 1234567891011121314151617181920212223 void ThreadList::Register(Thread* self) { //省略不看 //以原子方式将self添加到线程列表 MutexLock mu(self, *Locks::thread_list_lock_); MutexLock mu2(self, *Locks::thread_suspend_count_lock_); CHECK_GE(suspend_all_count_, debug_suspend_all_count_); for (int delta = debug_suspend_all_count_; delta &gt; 0; delta--) { bool updated = self-&gt;ModifySuspendCount(self, +1, nullptr, SuspendReason::kForDebugger); DCHECK(updated); } for (int delta = suspend_all_count_ - debug_suspend_all_count_; delta &gt; 0; delta--) { bool updated = self-&gt;ModifySuspendCount(self, +1, nullptr, SuspendReason::kInternal); DCHECK(updated); } CHECK(!Contains(self)); //加入 list_.push_back(self); //省略不看} Java层的Thread初始化,以及是怎么启动的？我们在java层面new thread 的时候，就会在jvm层面对应一个Thread，也会做很多和native相关的初始化。Android Thread做了些改动是在线程start的时候，我们以Android的为列 123456// Android-changed: Use Android specific nativeCreate() method to create/start thread. // The upstream native method start0() only takes a reference to this object and so must obtain // the stack size and daemon status directly from the field whereas Android supplies the values // explicitly on the method call. // private native void start0(); private native static void nativeCreate(Thread t, long stackSize, boolean daemon); 对应到native art/runtime/native/java_lang_Thread.cc 实现 1234567891011121314 static void Thread_nativeCreate(JNIEnv* env, jclass, jobject java_thread, jlong stack_size, jboolean daemon) { // 检查 // There are sections in the zygote that forbid thread creation. Runtime* runtime = Runtime::Current(); if (runtime-&gt;IsZygote() &amp;&amp; runtime-&gt;IsZygoteNoThreadSection()) { jclass internal_error = env-&gt;FindClass(\"java/lang/InternalError\"); CHECK(internal_error != nullptr); env-&gt;ThrowNew(internal_error, \"Cannot create threads in zygote\"); return; } //这里去创建 Thread::CreateNativeThread(env, java_thread, stack_size, daemon == JNI_TRUE);} 重要的实现就是在CreateNativeThread里面了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 void Thread::CreateNativeThread(JNIEnv* env, jobject java_peer, size_t stack_size, bool is_daemon) { CHECK(java_peer != nullptr); Thread* self = static_cast&lt;JNIEnvExt*&gt;(env)-&gt;GetSelf(); //省略CHECK Runtime* runtime = Runtime::Current(); //以原子方式启动线程的诞生 bool thread_start_during_shutdown = false; { MutexLock mu(self, *Locks::runtime_shutdown_lock_); if (runtime-&gt;IsShuttingDownLocked()) { thread_start_during_shutdown = true; } else { //熟悉的线程初始化 StartThreadBirth( runtime-&gt;StartThreadBirth(); // 那么end 呢？？？？ } } if (thread_start_during_shutdown) { ScopedLocalRef&lt;jclass&gt; error_class(env, env-&gt;FindClass(\"java/lang/InternalError\")); env-&gt;ThrowNew(error_class.get(), \"Thread starting during runtime shutdown\"); return; } Thread* child_thread = new Thread(is_daemon); // Use global JNI ref to hold peer live while child thread starts. child_thread-&gt;tlsPtr_.jpeer = env-&gt;NewGlobalRef(java_peer); stack_size = FixStackSize(stack_size); // 改变 nativePeer // Thread.start is synchronized, so we know that nativePeer is 0, and know that we're not racing // to assign it. env-&gt;SetLongField(java_peer, WellKnownClasses::java_lang_Thread_nativePeer, reinterpret_cast&lt;jlong&gt;(child_thread)); // Try to allocate a JNIEnvExt for the thread. We do this here as we might be out of memory and // do not have a good way to report this on the child's side. std::string error_msg; std::unique_ptr&lt;JNIEnvExt&gt; child_jni_env_ext( JNIEnvExt::Create(child_thread, Runtime::Current()-&gt;GetJavaVM(), &amp;error_msg)); int pthread_create_result = 0; if (child_jni_env_ext.get() != nullptr) { pthread_t new_pthread; pthread_attr_t attr; child_thread-&gt;tlsPtr_.tmp_jni_env = child_jni_env_ext.get(); CHECK_PTHREAD_CALL(pthread_attr_init, (&amp;attr), \"new thread\"); CHECK_PTHREAD_CALL(pthread_attr_setdetachstate, (&amp;attr, PTHREAD_CREATE_DETACHED), \"PTHREAD_CREATE_DETACHED\"); CHECK_PTHREAD_CALL(pthread_attr_setstacksize, (&amp;attr, stack_size), stack_size); //看到没有，这里对应了一个pthread_create，是在JAVA层调用thread start创建 pthread_create_result = pthread_create(&amp;new_pthread, &amp;attr, Thread::CreateCallback,//线程启动执行的函数 child_thread); CHECK_PTHREAD_CALL(pthread_attr_destroy, (&amp;attr), \"new thread\"); //创建成功 if (pthread_create_result == 0) { // pthread_create started the new thread. The child is now responsible for managing the // JNIEnvExt we created. // Note: we can't check for tmp_jni_env == nullptr, as that would require synchronization // between the threads. child_jni_env_ext.release(); return; } } //其它创建失败的情况} Runtime::Current()-&gt;EndThreadBirth();在Thread::CreateCallback,里面 所以pthread启动后，才是EndThreadBirth() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 void* Thread::CreateCallback(void* arg) { Thread* self = reinterpret_cast&lt;Thread*&gt;(arg); Runtime* runtime = Runtime::Current(); if (runtime == nullptr) { LOG(ERROR) &lt;&lt; \"Thread attaching to non-existent runtime: \" &lt;&lt; *self; return nullptr; } { // TODO: pass self to MutexLock - requires self to equal Thread::Current(), which is only true // after self-&gt;Init(). MutexLock mu(nullptr, *Locks::runtime_shutdown_lock_); // Check that if we got here we cannot be shutting down (as shutdown should never have started // while threads are being born). CHECK(!runtime-&gt;IsShuttingDownLocked()); // Note: given that the JNIEnv is created in the parent thread, the only failure point here is // a mess in InitStackHwm. We do not have a reasonable way to recover from that, so abort // the runtime in such a case. In case this ever changes, we need to make sure here to // delete the tmp_jni_env, as we own it at this point. CHECK(self-&gt;Init(runtime-&gt;GetThreadList(), runtime-&gt;GetJavaVM(), self-&gt;tlsPtr_.tmp_jni_env)); self-&gt;tlsPtr_.tmp_jni_env = nullptr; //这里end Runtime::Current()-&gt;EndThreadBirth(); } { ScopedObjectAccess soa(self); self-&gt;InitStringEntryPoints(); // Copy peer into self, deleting global reference when done. CHECK(self-&gt;tlsPtr_.jpeer != nullptr); self-&gt;tlsPtr_.opeer = soa.Decode&lt;mirror::Object&gt;(self-&gt;tlsPtr_.jpeer).Ptr(); self-&gt;GetJniEnv()-&gt;DeleteGlobalRef(self-&gt;tlsPtr_.jpeer); self-&gt;tlsPtr_.jpeer = nullptr; self-&gt;SetThreadName(self-&gt;GetThreadName()-&gt;ToModifiedUtf8().c_str()); ArtField* priorityField = jni::DecodeArtField(WellKnownClasses::java_lang_Thread_priority); self-&gt;SetNativePriority(priorityField-&gt;GetInt(self-&gt;tlsPtr_.opeer)); runtime-&gt;GetRuntimeCallbacks()-&gt;ThreadStart(self); // Invoke the 'run' method of our java.lang.Thread. 真实调用thread 的 run 方法 ObjPtr&lt;mirror::Object&gt; receiver = self-&gt;tlsPtr_.opeer; jmethodID mid = WellKnownClasses::java_lang_Thread_run; ScopedLocalRef&lt;jobject&gt; ref(soa.Env(), soa.AddLocalReference&lt;jobject&gt;(receiver)); InvokeVirtualOrInterfaceWithJValues(soa, ref.get(), mid, nullptr); } // Detach and delete self. 这里是解注册 Runtime::Current()-&gt;GetThreadList()-&gt;Unregister(self); return nullptr;} 简单总结 我们通过javaThread 创建线程的时候，JVM会包装成一个JVM的Thread，然后启动pthread，调用run方法，但我们通过pthread独立创建的线程，是没有和JVM里面的线程对象Thread建立关联的，JVM不认你这个线程，你独立在这个线程里面做和JVM不相关的事情是可以的，但是你要访问java，这就得需要JVM帮忙，所以需要把我们自己创建的线程warp成一个JVM层面的Thread对象，然后添加到JVM的thread list 里面去，这样在jvm层面就感知到了一个Thread的了。 我们类比的话，一个先做了1然后做2 ，后一个先做了2，后面补做了1","link":"/2020/05/19/Android/AttachCurrentThread/"},{"title":"JsonObject.optLong 导致的Bug","text":"问题背景 业务场景存在一个JSB，FE同学传了个JSON到端上，端上测试的时候都是正确的，有天调试Server反馈说id值找不到，端上id值回传错了，开始排查代码。发现Jsb传输过来的Json都是String to String的格式, 类似这样 1234{ \"id1\":\"123456789087979797\", \"id2\":\"123456789087979798\"} 断点发现，FE传过来的值是123456789087979797，但是端上取了之后，传给server的值是123456789087979792，于是排查转换过程。端上在取id的时候，使用了org.json.JSONObject#optLong(java.lang.String) 方法，造成整数转换错误。 源码分析1234567891011121314151617181920212223242526org.json.JSONObject#optLong(java.lang.String)public long optLong(@Nullable String name) { return optLong(name, 0L);}public long optLong(@Nullable String name, long fallback) { Object object = opt(name); Long result = JSON.toLong(object); return result != null ? result : fallback;}static Long toLong(Object value) { if (value instanceof Long) { return (Long) value; } else if (value instanceof Number) { return ((Number) value).longValue(); } else if (value instanceof String) { try { // 留意这里会造成bug return (long) Double.parseDouble((String) value); } catch (NumberFormatException ignored) { } } return null;} 原理分析为什么Long转Double会失真，我们先复习一下Double的表示方式, 那就是IEEE754标准，所有的浮点数都要表示成 尾数和指数的形式，这里就会有一个问题，尾数保留的精度。我们以前面的Long值123456789087979797举例，转换二进制, 总共有57位 1110110110100110110100101110101010101100110000100100010101 换成标准形式，尾数只能存52位，后面的得丢掉，整数就在这里失真了 11.1011011010011011010010111010101010110011000010010001|0101(丢掉) 再转换成Long值就是 123456789087979792源码中，并不是double转long造成的精度丢失，而是double表示long的时候，尾数精度丢失 1return (long) Double.parseDouble((String) value); double的尾数精度只有52位，2^(52)&lt; 16个9，所以十进制下，double能准确表示小数的精度在15位，还有个经问题0.1+0.2 = 0.30000…4也是尾数精度导致的。本质上计算机存储的数都是离散的，不是连续的。 总结每次使用 org.json.JSONObject#optLong的时候，留意一下目标值的类型，你可能恰好取对了值，但不总是对的，一旦值过大的case, 就会触发bug。","link":"/2022/08/14/Android/bug-json-opt-long/"},{"title":"如何用AndroidStudio动态调试ART虚拟机？","text":"1.前言之前有debug过jvm, 开发anroid 临时起意想能不能动态debug art虚拟机，代码是看不下去的，还是跑起来直观。其实调试其他native lib 的原理是一样的。网上也看到一些，受启发比较大的是这位大佬17年写的https://zhuanlan.zhihu.com/p/24867284, 在此先感谢一下他，自己也算是做一个较的，记录一下自己踩过的坑。以下全部基于Android 9 。 2. 编译Android 9 系统这个有门槛，毕竟AOSP 超大。有个在64核服务器当然好，大概半个小时，全目录60GB左右，但是自己笔记本还是吃不消的，怎么拉下自己编译，还请google。如果只是想要原生这里有https://ci.android.com/，AOSP google编译的，可以在里面直接下载AOSP编译文件，也比较大，且需要联网。如果你还有个pixel, 还可以用来刷机。 自己有条件，可以编译 从AOSP下载 用别人给的，比如我android_framework_native_debug 不管怎么，当然要有目标库的源码最好，（哦，你不要的的话，😂 可以直接指令级debug，其实可以不用这么麻烦了，可以直接return ） 3.准备一台手机 可以刷机，那就刷自己编译的系统 不能刷机 ，但可以root，看你是需要调试那个库，如果是其它库，你可能需要自己把编译好的so库push到手机 不能root，同用的基础库才可以，比如本次我尝试的art库，libart.so 在2台手机 root和非root，刷机和不刷机的情况下都是可以的。想想厂商还是很少改动art的 4. 新建一个AS工程 我们需要 编译出来好的 目标so文件 AOSP 工程里面源码 编译出来的symbol 目录，里面对应的就是相应库的 debug标记文件，调试中需要用到。找到对应的libart.so。对比大小你就会发现，一个是7mb，一个是150mb。拷贝出来，可以放到工程目录下 当然也可以用你现在的工程，只要是方便debug，查看源码，进行native debug。可以先导入 art 源码到工程里面，可以参考android_framework_native_debug样式。主要是通过AS里面的debug attach 到选择的进程，就可以进行相应的进程debug了。 5.将目标库PUSH到手机 当然也可以不用，比如我在另外一台其它品牌不能root的手机上测试，art库可以直接使用。如果你其它库，建议可以尝试。 6.Attach到目标进程Debug本[android_framework_native_debug](https://github.com/kaiattrib/android_framework_native_debug)工程先写了一个native code ，方便打上断掉，寻找入库，你也可以不用，直接pause也是可以的。&lt;br /&gt;选择带native，可以是dual，等待lldb连接成功。&lt;br /&gt; ![](https://cdn.nlark.com/yuque/0/2020/png/501385/1589559645183-3d9e2d39-a854-4685-9621-b12d9ac860d2.png#align=left&amp;display=inline&amp;height=643&amp;margin=%5Bobject%20Object%5D&amp;name=Xnip2020-05-16_00-20-07.png&amp;originHeight=1134&amp;originWidth=772&amp;size=112011&amp;status=done&amp;style=none&amp;width=438) 等待lldb连接成功，点击触发 但是现在看到，栈还没有行号信息，我们自己写的native代码，才有 123456::Java_com_test_CustomizeThread_start(JNIEnv , jobject) native-lib.cpp:38 //这里有行号，art_quick_generic_jni_trampoline 0x0000006f4bb9b9e4 //这里只有地址art_quick_invoke_stub 0x0000006f4bb9298cart::ArtMethod::Invoke(art::Thread, unsigned int, unsigned int, art::JValue, char const) 0x0000006f4b70c6ccart::interpreter::ArtInterpreterToCompiledCodeBridge(art::Thread, art::ArtMethod, art::ShadowFrame, unsigned short, art::JValue) 0x0000006f4b8bcab8bool art::interpreter::DoCall&lt;false, false&gt;(art::ArtMethod, art::Thread, art::ShadowFrame&amp;, 我们继续进入，force step into 123456art::(anonymous namespace)::CheckJNI::FindClass(_JNIEnv*, char const*) 0x0000006f4b71e728_JNIEnv::FindClass(char const*) jni.h:504::Java_com_test_CustomizeThread_start(JNIEnv *, jobject) native-lib.cpp:38art_quick_generic_jni_trampoline 0x0000006f4bb9b9e4art_quick_invoke_stub 0x0000006f4bb9298c--- 可以看到，又没有源码信息了,接下来我们手动加入符号信息库 通过 d -p 反编译，可以知道我们当前pc所在的库和函数 123456(lldb) d -plibart.so`art::(anonymous namespace)::CheckJNI::FindClass:-&gt; 0x6f4b71e728 &lt;+4&gt;: stp x28, x27, [sp, #0x70] 0x6f4b71e72c &lt;+8&gt;: stp x26, x25, [sp, #0x80] 0x6f4b71e730 &lt;+12&gt;: stp x24, x23, [sp, #0x90] 0x6f4b71e734 &lt;+16&gt;: stp x22, x21, [sp, #0xa0] 手动加入符号信息库, 有下面信息，说明ok 报错就是目标so不符合 12(lldb) add-dsym /Users/kenchan/GitHub/android_framework_native_debug/symbol/libart.sosymbol file '/Users/kenchan/GitHub/android_framework_native_debug/symbol/libart.so' has been added to '/Users/kenchan/.lldb/module_cache/remote-android/.cache/88B6A7B4-8B23-9260-2988-33B24671013C/libart.so' 通过souce info 查看一下 对应的源码信息 123(lldb) source infoLines found in module `libart.so[0x0000006f4b71e714-0x0000006f4b71e750): art/runtime/scoped_thread_state_change-inl.h:38:5 可以看到目录信息，这里linux下是绝对路径。所以我们要做一下映射 1(lldb) settings set target.source-map art/ /Users/kenchan/GitHub/android_framework_native_debug/art 你再点击一下 setp，就会发现调用栈里面有 源码文件信息了 我们点击某一个调用栈，就是发现 跳转了源码文件了 现在的调用栈是 123456789std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp; std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt; &gt;(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;, char const*) 0x0000006f4b71e750art::ScopedThreadStateChange::ScopedThreadStateChange(art::Thread*, art::ThreadState) scoped_thread_state_change-inl.h:38art::ScopedObjectAccessUnchecked::ScopedObjectAccessUnchecked(_JNIEnv*) scoped_thread_state_change-inl.h:108art::ScopedObjectAccess::ScopedObjectAccess(_JNIEnv*) scoped_thread_state_change-inl.h:119art::(anonymous namespace)::CheckJNI::DefineClass(_JNIEnv*, char const*, _jobject*, signed char const*, int) check_jni.cc:1824_JNIEnv::FindClass(char const*) jni.h:504::Java_com_test_CustomizeThread_start(JNIEnv *, jobject) native-lib.cpp:38art_quick_alloc_array_resolved32_tlab 0x0000006f4bb9b9e4art_quick_throw_string_bounds 0x0000006f4bb9298c 接下来就是正常debug了 7. 你可以用本android_framework_native_debug工程做什么？ 如果你的手机也是 anroid 9.0 如果你也是想debug art 你可以直接下载运行本工程，按步骤即可，不需要root，不需要push 我编译的是arm平台的，所以在模拟器里面不行参考https://zhuanlan.zhihu.com/p/24867284","link":"/2020/05/16/Android/android-native-debug/"},{"title":"深入理解Handler原理","text":"一. Handler初始化Handler–&gt; Looper &lt;– MessageQueue &lt;– MessageHandler需要Looper，Looperl里包含构建的MessageQueue。 可以在构造的时候，通过参数传入。 1. Handler 构造12345678910111213141516171819202122232425public Handler(Callback callback, boolean async) { //检查潜在的泄漏 if (FIND_POTENTIAL_LEAKS) { final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) { Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); } } //获取当前线程的Looper mLooper = Looper.myLooper(); //Handler需要Looper,如果为null，抛出异常 if (mLooper == null) { throw new RuntimeException( \"Can't create handler inside thread \" + Thread.currentThread() + \" that has not called Looper.prepare()\"); } //设置当前Handler的MessageQueue 等于Looper的MessageQueue mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;} 2. 上面的mLooper 为什么可能为空？要调用 Looper.prepare()?先看一下mLooper = Looper.myLooper() 1234567891011121314151617181920//这里可以看到是通过ThreadLocal线程持有的一个 Looper public static @Nullable Looper myLooper() { return sThreadLocal.get();}//获取当前线程的map,并返回looperpublic T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } //如果当前线程的map还没有，就在这个方法里面创建 return setInitialValue();} 再看一下 Looper.prepare()，这里解释了为什么只能调用一次 12345678private static void prepare(boolean quitAllowed) { //如果有了，就抛错，一个线程保证了只能有一个Looper if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } //没有就new一个 set sThreadLocal.set(new Looper(quitAllowed)); } 3. 为什么有什么需要手动调用Looper.prepare() ？1当前线程有了looper就不需要手动调用。如果是在主线程ActivityThread，主线程已经默认有了一个Looper了，这个Looper会处理界面的各种事件。 在ActivityThread的main方法中 1234567891011121314//这里就对主线程，调用了Looper.prepare()，所以在主线程启动的时候，就拥有了Looper,后面的是在主线程中的Handler默认共享该LooeprLooper.prepareMainLooper();//展开就是Looper下的这个方法public static void prepareMainLooper() { //这里就是Looper.prepare() prepare(false); synchronized (Looper.class) { if (sMainLooper != null) { throw new IllegalStateException(\"The main Looper has already been prepared.\"); } sMainLooper = myLooper(); }} 总结1一个Handler只能对应一个Looepr,一个Looper 持有MessageQueue。一个Looper可以对应多个Hander。那么Message是怎么和Handler联系起来的呢，在加入消息的时候 通过 msg.target = this; this就是handler本身联系起来的。 二. Handder 发送消息 —&gt; 入队通常我们新建消息的时候 通过 Message obtain = Message.obtain();获取，主要是复用里面的Message对象。通常我们调用 1234sendMessage(Message msg)//发送消息——&gt; sendMessageDelayed(msg, 0)//延时为0——&gt; sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis)//转换成绝对时间——&gt; enqueueMessage(queue, msg, uptimeMillis)//开始入队 下面的就是MeaageQueue入队的逻辑了，类似链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677boolean enqueueMessage(Message msg, long when) { //target 就是发送消息的Hander 如果message的handelr为null，抛错 if (msg.target == null) { throw new IllegalArgumentException(\"Message must have a target.\"); } //msg是不是正在被使用,比如说这个消息已经入队了。就不能再加入 // 连续sendMessage同一个msg对象就会抛错,当然msg复用obtian和new的时候FLAG_IN_USE会重置 if (msg.isInUse()) { throw new IllegalStateException(msg + \" This message is already in use.\"); } //保证线程安全 synchronized (this) { //当前队列是不是调用了quit if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } //标记为Use状态 msg.markInUse(); msg.when = when; //先保留之前的节点，准备插入现在的msg Message p = mMessages; boolean needWake; //p = null 现在队列是空的 // 为什么 会有 when = 0 ？Handler提供了一个sendMessageAtFrontOfQueue 方法,保证某个消息插到消息头，及时处理 //when &lt; p.when 当前插入的消息 比前一个节点的时间更小，意味着要先执行消息 //其实就是头插入 类似 null&lt;--msg 或者 null&lt;--.&lt;--p&lt;--msg if (p == null || when == 0 || when &lt; p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; //根据当前的MessageQueue 状态,确定是否要唤醒队列起来处理消息 //为什么要唤醒？因为队列为空了，或者队列里面的消息都是明天才要处理的，那么今晚可以睡觉。但是睡梦中又有新的(bug)消息来了，就是这次要插入的消息，必须起来处理(bug)消息 needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. //以上情况不满足，就是要把当前这个消息插入到队列中间去了 // 就按时间when的顺序插入 //当前 消息队列是否阻塞 &amp;&amp; 队头的消息target=null &amp;&amp; 是否支持异步 //target == null 为什么可以为null？不是不能为null吗？见后面 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; //寻找插入点 for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } //插入消息 msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. //是否需要唤醒？mPtr used by native code if (needWake) { nativeWake(mPtr); } } return true;} target == null 为什么可以为null？不是不能为null吗？因为提供了骚操作，还有这种打开方式。postSyncBarrier。 以前叫enqueueSyncBarrier 网上找的其它有写到这个Barrier 可以联想到JUC的CyclicBarrier。就是插入一下Barrier消息,这个消息之后的所有消息会阻塞在这个消息之后。 12345678910111213141516171819202122232425262728293031323334353637public int postSyncBarrier() { //添加现在的时间 return postSyncBarrier(SystemClock.uptimeMillis()); } //消息入队 private int postSyncBarrier(long when) { // Enqueue a new sync barrier token. // We don't need to wake the queue because the purpose of a barrier is to stall it. synchronized (this) { final int token = mNextBarrierToken++; final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; //这里没有setTarget ，所以是null的 Message prev = null; Message p = mMessages; //寻找插入点 if (when != 0) { while (p != null &amp;&amp; p.when &lt;= when) { prev = p; p = p.next; } } //插入这个Barrier消息 if (prev != null) { // invariant: p == prev.next msg.next = p; prev.next = msg; } else { msg.next = p; mMessages = msg; } return token; } } 异步消息？作者：AngelDevil出处：https://www.cnblogs.com/angeldevil/p/3340644.html转载请注明出处！所谓的异步消息其实就是这样的，我们可以通过enqueueBarrier往消息队列中插入一个Barrier，那么队列中执行时间在这个Barrier以后的同步消息都会被这个Barrier拦截住无法执行，直到我们调用removeBarrier移除了这个Barrier，而异步消息则没有影响，消息默认就是同步消息，除非我们调用了Message的setAsynchronous，这个方法是隐藏的。只有在初始化Handler时通过参数指定往这个Handler发送的消息都是异步的，这样在Handler的enqueueMessage中就会调用Message的setAsynchronous设置消息是异步的，从上面Handler.enqueueMessage的代码中可以看到。所谓异步消息，其实只有一个作用，就是在设置Barrier时仍可以不受Barrier的影响被正常处理，如果没有设置Barrier，异步消息就与同步消息没有区别，可以通过removeSyncBarrier移除Barrier： nativeWake唤醒 ? nativePollOnce?睡眠native方法。轮询利用epoll机制有点类似wait 与 notify。具体见后面的native分析 123private native static void nativeWake(long ptr);private native void nativePollOnce(long ptr, int timeoutMillis); /*non-static for callbacks*/ 三. Handler 处理消息及延时消息 —&gt; 出队消息是怎么处理的呢？通过调用Looper.loop()方法，开始处理消息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public static void loop() { //获取当前线程的Looper final Looper me = myLooper(); if (me == null) { throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); } final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. //清空远程调用端的uid和pid，用当前本地进程的uid和pid替代； Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // Allow overriding a threshold with a system prop. e.g. // adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start' final int thresholdOverride = SystemProperties.getInt(\"log.looper.\" + Process.myUid() + \".\" + Thread.currentThread().getName() + \".slow\", 0); boolean slowDeliveryDetected = false; //这里开始处理消息，死循环 for (;;) { //这里可能阻塞,现在没有消息需要处理的消息 Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. //msg = null，消息队列退出了，退出死循环 return; } // This must be in a local variable, in case a UI event sets the logger //每次更新log，防止被set了最新的了，打印分发log final Printer logging = me.mLogging; if (logging != null) { logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); } final long traceTag = me.mTraceTag; long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs; if (thresholdOverride &gt; 0) { slowDispatchThresholdMs = thresholdOverride; slowDeliveryThresholdMs = thresholdOverride; } final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0); final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0); final boolean needStartTime = logSlowDelivery || logSlowDispatch; final boolean needEndTime = logSlowDispatch; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) { Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); } final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; try { //这里开始调用 target来处理消息，tartget就是Hander // 转而调用到我们重写的dispatchMessage 方法里面去 msg.target.dispatchMessage(msg); dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; } finally { if (traceTag != 0) { Trace.traceEnd(traceTag); } } //下面主要是打印log，消息处理可能延时 if (logSlowDelivery) { if (slowDeliveryDetected) { if ((dispatchStart - msg.when) &lt;= 10) { Slog.w(TAG, \"Drained\"); slowDeliveryDetected = false; } } else { if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, \"delivery\", msg)) { // Once we write a slow delivery log, suppress until the queue drains. slowDeliveryDetected = true; } } } if (logSlowDispatch) { showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, \"dispatch\", msg); } if (logging != null) { logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); } // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) { Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); } //回收消息 msg.recycleUnchecked(); } } 回收消息，标记清空，添加缓存池android.os.Message#recycleUnchecked 123456789101112131415161718192021222324252627/** * Recycles a Message that may be in-use. * Used internally by the MessageQueue and Looper when disposing of queued Messages. */void recycleUnchecked() { // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) { if (sPoolSize &lt; MAX_POOL_SIZE) { next = sPool; sPool = this; sPoolSize++; } }} 主要来看一下怎么取的消息？android.os.MessageQueue#next 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128Message next() { // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; //mPtr 退出了, return null，前面的 Looper.loop 收到null消息就退出死循环了 if (ptr == 0) { return null; } //什么是 IdleHandler ？见后面 //这个现在主要做标记 int pendingIdleHandlerCount = -1; // -1 only during first iteration // 休息时间 int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } //本地方法 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { // Try to retrieve the next message. Return if found. //取消息 final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; //msg ！= null，但是target = null，前面说了这个是barrier消息 if (msg != null &amp;&amp; msg.target == null) { // Stalled by a barrier. Find the next asynchronous message in the queue. //继续寻找下一个barrier消息,找到一个不是异步的消息退出 //为什么不处理这个barrier？barrier 就是一个时间界限，且没有Handler，消息队列就是按时间排序的，处理到了当前这个barrier消息，说明时间满足 do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) { //若果现在的时间还小于这个消息设置的执行时间 if (now &lt; msg.when) { // Next message is not ready. Set a timeout to wake up when it is ready. //计算一下可以休息多久时间 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { //如果时间满足,就是这个消息了，返回这个消息给loop // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); msg.markInUse(); return msg; } } else { // No more messages. nextPollTimeoutMillis = -1; } // Process the quit message now that all pending messages have been handled. //可能在这个时间，退出了 if (mQuitting) { dispose(); return null; } // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. // pendingIdleHandlerCount = -1 标记没有被改。有空闲了，处理IdleHandler if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } //居然没有IdleHandler？那就可以休息了 if (pendingIdleHandlerCount &lt;= 0) { // No idle handlers to run. Loop and wait some more. //标记我要休息了,发送消息的时候，可以判断是否需要唤醒我 mBlocked = true; // 直接continue ，在上面的 nativePollOnce(ptr, nextPollTimeoutMillis)就是睡眠了 continue; } //把 mIdleHandlers 转化到 mPendingIdleHandlers //mIdleHandlers 是会变化的 if (mPendingIdleHandlers == null) { mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; } mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); } // Run the idle handlers. // We only ever reach this code block during the first iteration. //下面就是处理IdleHandler了 // 显然这里面不能做耗时操作，不然会影响消息的及时处理 for (int i = 0; i &lt; pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try { keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(TAG, \"IdleHandler threw exception\", t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } //处理完了，标记复位 // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. //在处理IdleHandler的过程中，没有睡眠，可能有新的消息来了，不能睡眠 nextPollTimeoutMillis = 0; } } 什么是 IdleHandler ？IdleHandler 可以用来提升性能，主要用在我们希望能够在当前线程消息队列空闲时做些事情（譬如 UI 线程在显示完成后，如果线程空闲我们就可以提前准备其他内容）的情况下，不过最好不要做耗时操作。具体用法如下。 12345678//getMainLooper().myQueue()或者Looper.myQueue()Looper.myQueue().addIdleHandler(new IdleHandler() { @Override public boolean queueIdle() { //你要处理的事情 return false; } }); 可能存在的问题？ 消息不是及时处理的，及时性不保证。 我发送了一个延时MSG，这个MSG在没有被处理的情况下，这个MSG可能持有了其它引用导致内存泄漏。所以在在Activity退出的时候，clear一下msg，清掉handler。 类似 Dialog引发的内存泄漏 123456789101112131415for (;;) { //假设这是循环的第10次,然后这里阻塞了。然后其它地方刚好从线程池里面取走了一个消息，但是没有被发送。 // 想一想这个msg依然持有对第9次消息的引用,并在读到消息的时候覆盖。间接的这个msg就保持其它引用。 Message msg = queue.next(); if (msg == null) { return; } msg.target.dispatchMessage(msg); //第9次取的消息，在这里标记复位了，表示回收了 msg.recycleUnchecked(); //这里可以加一句 msg = null;} 最后用一张图，来表示整个消息机制 四. Native层主要分析 nativeWake（） nativePollOnce() 方法 实现够着MessageQueue的时候调用了nativeInit(); 12345MessageQueue(boolean quitAllowed) { mQuitAllowed = quitAllowed; // 通过JNI调用了Native层的相关函数，导致了NativeMessageQueue的创建 mPtr = nativeInit(); } 对应的 C++ 层的实现 123456789101112static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) { // 在Native层又创建了NativeMessageQueue NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (!nativeMessageQueue) { jniThrowRuntimeException(env, \"Unable to allocate native queue\"); return 0; } nativeMessageQueue-&gt;incStrong(env); // 这里返回值是Java层的mPtr，因此mPtr实际上是Java层MessageQueue与NativeMessesageQueue的桥梁 return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);} 1此时Java层和Native层的MessageQueue被mPtr连接起来了，NativeMessageQueue只是Java层MessageQueue在Native层的体现，其本身并没有实现Queue的数据结构，而是从其父类MessageQueue中继承mLooper变量。与Java层类型，这个Looper也是线程级别的单列。 NativeMessageQueue无参构造函数 12345678910NativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) { // 获取TLS中的Looper对象 mLooper = Looper::getForThread(); if (mLooper == NULL) { // 创建native层的Looper对象 mLooper = new Looper(false); // 保存native 层的Looper到TLS中(线程级单例) Looper::setForThread(mLooper); }} Looper::getForThread()：功能类比于Java层的Looper.myLooper(); Looper::setForThread(mLooper)：功能类比于Java层的ThreadLocal.set() 通过上述代码我们知道： 1、Java层的Looper的创建导致了MessageQueue的创建，而在Native层则刚刚相反，NativeMessageQueue的创建导致了Looper的创建 2、MessageQueue是在Java层与Native层有着紧密的联系，但是此次Native层的Looper与Java层的Looper没有任何关系。 3、Native层的Looper创建和Java层的也完全不一样，它利用了Linux的epoll机制检测了Input的fd和唤醒fd。从功能上来讲，这个唤醒fd才是真正处理Java Message和Native Message的钥匙。 所以创建MessageQueue的流程如图 为什么要关联一个Native MessageQueue ???首先Native 层也提供了 sendMesage,其它地方可以向这个消息队列发送消息。比如响应点击事件，WMS中接收到消息后，会调用ViewRootImpl中的dispatchInputEvent 1234 void Looper::sendMessage(const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message) { nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); sendMessageAtTime(now, handler, message);} 12345678910111213141516171819202122232425262728293031323334353637 void Looper::sendMessageAtTime(nsecs_t uptime, const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message) {#if DEBUG_CALLBACKS ALOGD(\"%p ~ sendMessageAtTime - uptime=%\" PRId64 \", handler=%p, what=%d\", this, uptime, handler.get(), message.what);#endif size_t i = 0; { // acquire lock // 请求锁 AutoMutex _l(mLock); size_t messageCount = mMessageEnvelopes.size(); // 找到message应该插入的位置i while (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) { i += 1; } MessageEnvelope messageEnvelope(uptime, handler, message); mMessageEnvelopes.insertAt(messageEnvelope, i, 1); // Optimization: If the Looper is currently sending a message, then we can skip // the call to wake() because the next thing the Looper will do after processing // messages is to decide when the next wakeup time should be. In fact, it does // not even matter whether this code is running on the Looper thread. // 如果当前正在发送消息，那么不再调用wake()，直接返回 if (mSendingMessage) { return; } } // release lock // 释放锁 // Wake the poll loop only when we enqueue a new message at the head. // 当消息加入到消息队列的头部时，需要唤醒poll循环 if (i == 0) { wake(); }} sendMessage()和sendMessageDelayed()都是调用sendMessageAtTime()来完成消息插 sendMessageAtTime() 和上面Java层类似 MessageQueue成为Java层和Native层的枢纽，既能处理上层消息，也能处理Native消息，当然Native层消息是Native层Hanlder处理。 感觉自己写一个Handler 根本用不到native 的 MessageQueue ？？？为什么主线程android.app.ActivityThread#main 里面明明有个 Looper.loop() 却不会卡UI主线程？因为UI事件本身也是通过主线程的Handelr机制去处理的。当前主线程loop了，还有消息从其它地方过来。当前Activity的可以响应回调事件和 广播事件。引用 https://stackoverflow.com/questions/35931899/why-main-threads-looper-loop-doesnt-block-ui-thread 123If there is no message, it means that no updates are required. All of our code is just a callback, such as Application onCreate, Activit onCreate, BroadcastReceiver onReceive.All update callbacks are caused by the message, and these messages are from the system services, such as ActivityManagerService, InputManagerService, WindowMangerService. If you need to update the UI, the android service will send a message to the loop via the IPC. nativePollOnce()12345static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) { //将Java层传递下来的mPtr转换为nativeMessageQueue NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis); } 首先，将Java层传递下来的mPtr转换为nativeMessageQueue 其次，nativeMessageQueue调用pollOnce(env, obj, timeoutMillis) 1234567891011121314void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) { mPollEnv = env; mPollObj = pollObj; // 重点函数 mLooper-&gt;pollOnce(timeoutMillis); mPollObj = NULL; mPollEnv = NULL; if (mExceptionObj) { env-&gt;Throw(mExceptionObj); env-&gt;DeleteLocalRef(mExceptionObj); mExceptionObj = NULL; }} 调用pollOnce(timeoutMillis),最后调用到 Looper::pollOnce(int, int, int, void**)函数 1234567891011121314151617181920212223242526272829303132333435363738int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) { int result = 0; // 对fd对应的Responses进行处理，后面发现Response里都是活动fd for (;;) { // 先处理没有Callback的Response事件 while (mResponseIndex &lt; mResponses.size()) { const Response&amp; response = mResponses.itemAt(mResponseIndex++); int ident = response.request.ident; if (ident &gt;= 0) { // ident&gt;=0则表示没有callback，因为POLL_CALLBACK=-2 int fd = response.request.fd; int events = response.events; void* data = response.request.data;#if DEBUG_POLL_AND_WAKE ALOGD(\"%p ~ pollOnce - returning signalled identifier %d: \" \"fd=%d, events=0x%x, data=%p\", this, ident, fd, events, data);#endif if (outFd != NULL) *outFd = fd; if (outEvents != NULL) *outEvents = events; if (outData != NULL) *outData = data; return ident; } } // 注意这里处于循环内部，改变result的值在后面的pollInner if (result != 0) {#if DEBUG_POLL_AND_WAKE ALOGD(\"%p ~ pollOnce - returning result %d\", this, result);#endif if (outFd != NULL) *outFd = 0; if (outEvents != NULL) *outEvents = 0; if (outData != NULL) *outData = NULL; return result; } // 再处理内部轮训 result = pollInner(timeoutMillis); }} Looper::pollInner()函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180 int Looper::pollInner(int timeoutMillis) {#if DEBUG_POLL_AND_WAKE ALOGD(\"%p ~ pollOnce - waiting: timeoutMillis=%d\", this, timeoutMillis);#endif // Adjust the timeout based on when the next message is due. if (timeoutMillis != 0 &amp;&amp; mNextMessageUptime != LLONG_MAX) { nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime); if (messageTimeoutMillis &gt;= 0 &amp;&amp; (timeoutMillis &lt; 0 || messageTimeoutMillis &lt; timeoutMillis)) { timeoutMillis = messageTimeoutMillis; }#if DEBUG_POLL_AND_WAKE ALOGD(\"%p ~ pollOnce - next message in %\" PRId64 \"ns, adjusted timeout: timeoutMillis=%d\", this, mNextMessageUptime - now, timeoutMillis);#endif } // Poll. int result = POLL_WAKE; mResponses.clear(); mResponseIndex = 0; // We are about to idle. // 即将处于idle状态 mPolling = true; // fd最大的个数是16 struct epoll_event eventItems[EPOLL_MAX_EVENTS]; // 等待时间发生或者超时，在nativeWake()方法，向管道写端写入字符，则方法会返回。 int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); // No longer idling. // 不再处于idle状态 mPolling = false; // 请求锁 ，因为在Native Message的处理和添加逻辑上需要同步 // Acquire lock. mLock.lock(); // Rebuild epoll set if needed. // 如果需要，重建epoll if (mEpollRebuildRequired) { mEpollRebuildRequired = false; // epoll重建，直接跳转到Done rebuildEpollLocked(); goto Done; } // Check for poll error. if (eventCount &lt; 0) { if (errno == EINTR) { goto Done; } ALOGW(\"Poll failed with an unexpected error, errno=%d\", errno); // epoll事件个数小于0，发生错误，直接跳转Done result = POLL_ERROR; goto Done; } // Check for poll timeout. //如果需要，重建epoll if (eventCount == 0) { //epoll事件个数等于0，发生超时，直接跳转Done#if DEBUG_POLL_AND_WAKE ALOGD(\"%p ~ pollOnce - timeout\", this);#endif result = POLL_TIMEOUT; goto Done; } // Handle all events.#if DEBUG_POLL_AND_WAKE ALOGD(\"%p ~ pollOnce - handling events from %d fds\", this, eventCount);#endif // 循环处理所有的事件 for (int i = 0; i &lt; eventCount; i++) { int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; //首先处理mWakeEventFd if (fd == mWakeEventFd) { //如果是唤醒mWakeEventFd有反应 if (epollEvents &amp; EPOLLIN) { /**重点代码*/ // 已经唤醒了，则读取并清空管道数据 awoken(); // 该函数内部就是read，从而使FD可读状态被清除 } else { ALOGW(\"Ignoring unexpected epoll events 0x%x on wake event fd.\", epollEvents); } } else { // 其他input fd处理，其实就是将活动放入response队列，等待处理 ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &gt;= 0) { int events = 0; if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT; if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT; if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR; if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP; // 处理request，生成对应的response对象，push到响应数组 pushResponse(events, mRequests.valueAt(requestIndex)); } else { ALOGW(\"Ignoring unexpected epoll events 0x%x on fd %d that is \" \"no longer registered.\", epollEvents, fd); } } }Done: ; // Invoke pending message callbacks. // 再处理Native的Message，调用相应回调方法 mNextMessageUptime = LLONG_MAX; while (mMessageEnvelopes.size() != 0) { nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0); if (messageEnvelope.uptime &lt;= now) { // Remove the envelope from the list. // We keep a strong reference to the handler until the call to handleMessage // finishes. Then we drop it so that the handler can be deleted *before* // we reacquire our lock. { // obtain handler sp&lt;MessageHandler&gt; handler = messageEnvelope.handler; Message message = messageEnvelope.message; mMessageEnvelopes.removeAt(0); mSendingMessage = true; // 释放锁 mLock.unlock();#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS ALOGD(\"%p ~ pollOnce - sending message: handler=%p, what=%d\", this, handler.get(), message.what);#endif // 处理消息事件 handler-&gt;handleMessage(message); } // release handler // 请求锁 mLock.lock(); mSendingMessage = false; // 发生回调 result = POLL_CALLBACK; } else { // The last message left at the head of the queue determines the next wakeup time. mNextMessageUptime = messageEnvelope.uptime; break; } } // Release lock. // 释放锁 mLock.unlock(); // Invoke all response callbacks. // 处理带有Callback()方法的response事件，执行Response相应的回调方法 for (size_t i = 0; i &lt; mResponses.size(); i++) { Response&amp; response = mResponses.editItemAt(i); if (response.request.ident == POLL_CALLBACK) { int fd = response.request.fd; int events = response.events; void* data = response.request.data;#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS ALOGD(\"%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p\", this, response.request.callback.get(), fd, events, data);#endif // Invoke the callback. Note that the file descriptor may be closed by // the callback (and potentially even reused) before the function returns so // we need to be a little careful when removing the file descriptor afterwards. // 处理请求的回调方法 int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data); if (callbackResult == 0) { // 移除fd removeFd(fd, response.request.seq); } // Clear the callback reference in the response structure promptly because we // will not clear the response vector itself until the next poll. // 清除response引用的回调方法 response.request.callback.clear(); // 发生回调 result = POLL_CALLBACK; } } return result;} pollOnce返回值说明 POLL_WAKE： 表示由wake()出发，即pipe写端的write事件触发 POLL_CALLBACK：表示某个被监听fd被触发 POLL_TIMEOUT：表示等待超时 POLL_ERROR：表示等待期间发生错误 pollInner()方法的处理流程： 1、先调用epoll_wait()，这是阻塞方法，用于等待事件发生或者超时。 2、对于epoll_wait()返回，当且仅当以下3种情况出现 POLL_ERROR：发生错误，直接跳转Done POLL_TIMEOUT：发生超时，直接跳转到Done 检测到管道有事情发生，则再根据情况做相应处理： 如果检测到管道产生事件，则直接读取管道的数据 如果是其他事件，则处理request，生成对应的response对象，push到response数组 3、进入Done标记位的代码： 先处理Native的Message，调用Native的Handler来处理该Message 再处理Resposne数组，POLL_CALLBACK类型的事件 总结一下 nativePollOnce() 的流程就是 nativeWake()android_os_MessageQueue_nativeWake() 123456static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) { // 将Java层传递下来的mPtr转换为nativeMessageQueue NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); //调用wake函数 nativeMessageQueue-&gt;wake();} 123void NativeMessageQueue::wake() { mLooper-&gt;wake();} 1234567891011121314void Looper::wake() {#if DEBUG_POLL_AND_WAKE ALOGD(\"%p ~ wake\", this);#endif uint64_t inc = 1; // 向管道mWakeEventFd写入字符1 ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t))); if (nWrite != sizeof(uint64_t)) { if (errno != EAGAIN) { ALOGW(\"Could not write wake signal, errno=%d\", errno); } }} 12Looper类的 wake()函数只是往mWakeEventfd中写了一些内容，这个fd只是通知而已，类似于pipi，最后会把epoll_wai唤醒，线程就不阻塞了继续发送Native层的消息，然后处理之前的addFd事件，然后处理Java层的消息。 总结一下 nativeWake() 的流程就是 Native与Java的对应关系1MessageQueue通过mPtr变量保存了NativeMessageQueue对象，从而使得MessageQueue成为Java层和Native层的枢纽，既能处理上层消息，也能处理Native消息，下图列举了Java层与Native层的对应图 1、红色虚线关系：Java层和Native层的MessageQueue通过JNI建立关联，彼此之间能相互调用，搞明白这个互调关系，也就搞明白Java如何调用C代码，C代码如何调用Java代码 2、蓝色虚线关系：Handler/Looper/Message这三大类Java层与Native层并没有任何真正的关系，只是分别在Java层和Native层的handler消息模型中具有相似的功能。都是彼此独立的，各自实现相应的逻辑。 3、WeakMessageHandler继承与MessageHandler类，NativeMessageQueue继承于MessageQueue类。 另外，消息处理流程是先处理NativeMessage，再处理Native Request，最后处理Java Message。理解了该流程也就明白了有时上层消息很少，但响应时间却比较长的真正原因。 总结 1、NativeMessageQueue：在MessageQueue.java的构造函数中，调用了nativeInit创建了NativeMessageQueue对象，并且把指针变量返回给Java层的mPtr。而在NativeMessageQueue的构造函数中，会在当前线程中创建C++的Looper对象。 2、Looper：控制eventfd的读写，通过epoll监听eventfd的变化，来阻塞调用pollOnce和恢复调用wake当前线程 通过 epoll监听其他文件描述符的变化 通过 epoll处理C++层的消息机制，当调用Looper::sendMessageAtTime后，调用wake触发epoll Looper的构造函数，创建一个eventfd(以前版本是pipe)，eventfd它的主要用于进程或者线程间的通信，然后创建epoll来监听该eventfd的变化 Looper::pollOnce(int timeoutMillis) 内部调用了pollInner，再调用epoll_wait(mEpollFd, …, timeoutMillis)阻塞timeoutMills时间，并监听文件描述符mEpollFd的变化，当时间到了或者消息到了，即eventfd被写入内容后，从epoll_wait继续往下执行，处理epoll_wait返回的消息，该消息既有可能是eventfd产生的，也可能是其他文件描述符产生的。处理顺序是，先处理普通的C++消息队列mMessageEnvelopes，然后处理之前addFd的事件，最后从pollOnce返回，会继续MessageQueue.java的next()函数，取得Java层的消息来处理； Looper类的wake，函数只是往mWakeEventfd中写了一些内容，这个fd只是通知而已，类似pipe，最后会把epoll_wait唤醒，线程就不阻塞了，继续先发送C层消息，然后处理之前addFd事件，然后处理Java层消息 五 . 感谢1234567891011http://gityuan.com/2015/12/26/handler-message-framework/作者：隔壁老李头链接：https://www.jianshu.com/p/91a4b797553d来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。作者：Little丶Jerry链接：https://www.jianshu.com/p/a1d945c4f5a6来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2020/04/18/Android/hander/"},{"title":"finish()和onDestroy() 区别什么？","text":"1.finish 做了什么？finsh 是我们主动调用的。起点源于 android.app.Activity#finish() 主要是把当前Activity从Task栈中移除。 1234public void finish() { //关闭Activity,但是不关闭task栈 finish(DONT_FINISH_TASK_WITH_ACTIVITY);} android.app.Activity#finish(int) 12345678910111213141516171819202122232425262728private void finish(int finishTask) { if (mParent == null) { int resultCode; Intent resultData; synchronized (this) { resultCode = mResultCode; resultData = mResultData; } try { if (resultData != null) { // 有数据需要返回给调用方,比如startActivityForResult resultData.prepareToLeaveProcess(this); } //这里实际实际上是通过android.app.IActivityManager$Stub$Proxy, 也就AIDL Binder 机制 //把mToken发送到AMS if (ActivityManager.getService() .finishActivity(mToken, resultCode, resultData, finishTask)) { mFinished = true; } } catch (RemoteException e) { // Empty } } else { mParent.finishFromChild(this); } --- } com.android.server.am.ActivityManagerService#finishActivity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * This is the internal entry point for handling Activity.finish(). * * @param token The Binder token referencing the Activity we want to finish. * @param resultCode Result code, if any, from this Activity. * @param resultData Result data (Intent), if any, from this Activity. * @param finishTask Whether to finish the task associated with this Activity. * * @return Returns true if the activity successfully finished, or false if it is still running. */ @Override public final boolean finishActivity(IBinder token, int resultCode, Intent resultData, int finishTask) { // Refuse possible leaked file descriptors if (resultData != null &amp;&amp; resultData.hasFileDescriptors() == true) { throw new IllegalArgumentException(\"File descriptors passed in Intent\"); } synchronized(this) { ActivityRecord r = ActivityRecord.isInStackLocked(token); if (r == null) { return true; } // Keep track of the root activity of the task before we finish it TaskRecord tr = r.getTask(); ActivityRecord rootR = tr.getRootActivity(); if (rootR == null) { Slog.w(TAG, \"Finishing task with all activities already finished\"); } // Do not allow task to finish if last task in lockTask mode. Launchable priv-apps can // finish. if (mLockTaskController.activityBlockedFromFinish(r)) { return false; } if (mController != null) { // Find the first activity that is not finishing. ActivityRecord next = r.getStack().topRunningActivityLocked(token, 0); if (next != null) { // ask watcher if this is allowed boolean resumeOK = true; try { resumeOK = mController.activityResuming(next.packageName); } catch (RemoteException e) { mController = null; Watchdog.getInstance().setActivityController(null); } if (!resumeOK) { Slog.i(TAG, \"Not finishing activity because controller resumed\"); return false; } } } final long origId = Binder.clearCallingIdentity(); try { boolean res; final boolean finishWithRootActivity = finishTask == Activity.FINISH_TASK_WITH_ROOT_ACTIVITY; if (finishTask == Activity.FINISH_TASK_WITH_ACTIVITY || (finishWithRootActivity &amp;&amp; r == rootR)) { // If requested, remove the task that is associated to this activity only if it // was the root activity in the task. The result code and data is ignored // because we don't support returning them across task boundaries. Also, to // keep backwards compatibility we remove the task from recents when finishing // task with root activity. res = mStackSupervisor.removeTaskByIdLocked(tr.taskId, false, finishWithRootActivity, \"finish-activity\"); if (!res) { Slog.i(TAG, \"Removing task failed to finish activity\"); } } else { //走这里 res = tr.getStack().requestFinishActivityLocked(token, resultCode, resultData, \"app-request\", true); if (!res) { Slog.i(TAG, \"Failed to finish by app-request\"); } } return res; } finally { Binder.restoreCallingIdentity(origId); } } } com.android.server.am.ActivityStack#requestFinishActivityLocked 123456789101112131415161718/** * @return Returns true if the activity is being finished, false if for * some reason it is being left as-is. */final boolean requestFinishActivityLocked(IBinder token, int resultCode, Intent resultData, String reason, boolean oomAdj) { ActivityRecord r = isInStackLocked(token); if (DEBUG_RESULTS || DEBUG_STATES) Slog.v(TAG_STATES, \"Finishing activity token=\" + token + \" r=\" + \", result=\" + resultCode + \", data=\" + resultData + \", reason=\" + reason); if (r == null) { return false; } finishActivityLocked(r, resultCode, resultData, reason, oomAdj); return true;} ActivityStack#finishActivityLocked 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * @return Returns true if this activity has been removed from the history * list, or false if it is still in the list and will be removed later. */final boolean finishActivityLocked(ActivityRecord r, int resultCode, Intent resultData, String reason, boolean oomAdj, boolean pauseImmediately) { if (r.finishing) { Slog.w(TAG, \"Duplicate finish request for \" + r); return false; } mWindowManager.deferSurfaceLayout(); try { r.makeFinishingLocked(); //将Ativity对应的finishing属性置为true final TaskRecord task = r.getTask(); EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY, r.app != null ? r.app.pid : 0, System.identityHashCode(r), task.taskId, r.shortComponentName, reason); //打印event log final ArrayList&lt;ActivityRecord&gt; activities = task.mActivities; final int index = activities.indexOf(r); if (index &lt; (activities.size() - 1)) { //如果要finish的Activity不是task顶部的Activity task.setFrontOfTask(); if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0) { // If the caller asked that this activity (and all above it) // be cleared when the task is reset, don't lose that information, // but propagate it up to the next activity. ActivityRecord next = activities.get(index+1); next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET); } } r.pauseKeyDispatchingLocked(); adjustFocusedActivityStack(r, \"finishActivity\"); //调整focus activityStack(当前stack 调用topRunningActivityLocked为null，即当前stack中的所有task中的Activity没有正在running的，那么此Activity不能再做前台，要移到后面) finishActivityResultsLocked(r, resultCode, resultData); //如果要finish的Activity有resultTo，向其传递result final boolean endTask = index &lt;= 0 &amp;&amp; !task.isClearingToReuseTask(); //是否要销毁task(当要销毁的Activity在task中的index&lt;=0) final int transit = endTask ? TRANSIT_TASK_CLOSE : TRANSIT_ACTIVITY_CLOSE; if (mResumedActivity == r) { if (DEBUG_VISIBILITY || DEBUG_TRANSITION) Slog.v(TAG_TRANSITION, \"Prepare close transition: finishing \" + r); if (endTask) { mService.mTaskChangeNotificationController.notifyTaskRemovalStarted( task.taskId); } mWindowManager.prepareAppTransition(transit, false); // Tell window manager to prepare for this one to be removed. r.setVisibility(false); if (mPausingActivity == null) { if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, \"Finish needs to pause: \" + r); if (DEBUG_USER_LEAVING) Slog.v(TAG_USER_LEAVING, \"finish() =&gt; pause with userLeaving=false\"); startPausingLocked(false, false, null, pauseImmediately); //调用startPausingLocked，finish之前需要先pause，注意resuming为null } if (endTask) { mService.getLockTaskController().clearLockedTask(task); } } else if (!r.isState(PAUSING)) { //这种情况是finish的不是resumed Activity的情况 // If the activity is PAUSING, we will complete the finish once // it is done pausing; else we can just directly finish it here. if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, \"Finish not pausing: \" + r); if (r.visible) { prepareActivityHideTransitionAnimation(r, transit); } final int finishMode = (r.visible || r.nowVisible) ? FINISH_AFTER_VISIBLE : FINISH_AFTER_PAUSE; final boolean removedActivity = finishCurrentActivityLocked(r, finishMode, oomAdj, \"finishActivityLocked\") == null; //也是调用finishCurrentActivityLocked // The following code is an optimization. When the last non-task overlay activity // is removed from the task, we remove the entire task from the stack. However, // since that is done after the scheduled destroy callback from the activity, that // call to change the visibility of the task overlay activities would be out of // sync with the activitiy visibility being set for this finishing activity above. // In this case, we can set the visibility of all the task overlay activities when // we detect the last one is finishing to keep them in sync. if (task.onlyHasTaskOverlayActivities(true /* excludeFinishing */)) { for (ActivityRecord taskOverlay : task.mActivities) { if (!taskOverlay.mTaskOverlay) { continue; } prepareActivityHideTransitionAnimation(taskOverlay, transit); } } return removedActivity; } else { if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, \"Finish waiting for pause of: \" + r); } return false; } finally { mWindowManager.continueSurfaceLayout(); }} 总的流程 2.onDestory 做了什么？onDestory主要是进行资源回收，把还在占用的资源释放，里面有很多close。 onDestory 回调方法也是由AMS发出 的 ClientTransaction 消息，然后主线程的looper处理这个消息，通过 transaction.getLifecycleStateRequest() 获知是 DestroyActivityItem ,最后就一步步调用到onDestory了。 调用过程如下 1234567891011121314151617181920212223242526272829onDestroy():95, MainActivityperformDestroy():7395, Activity (android.app)// 转发callActivityOnDestroy(Activity):1306, Instrumentation (android.app)performDestroyActivity(IBinder, boolean, int, boolean, String):4443, ActivityThread (android.app)handleDestroyActivity(IBinder, boolean, int, boolean, String):4476, ActivityThread (android.app)execute(ClientTransactionHandler, IBinder, PendingTransactionActions):39, DestroyActivityItem (android.app.servertransaction)// 获取是 DestroyActivityItem ，然后交给上面处理executeLifecycleState(ClientTransaction):145, TransactionExecutor (android.app.servertransaction)//处理execute(ClientTransaction):70, TransactionExecutor (android.app.servertransaction)//这个是由主线程默认的内部Hander H 来处理的handleMessage(Message):1808, ActivityThread$H (android.app)// 分发到目标Hander处理dispatchMessage(Message):106, Handler (android.os)//looper在这里死循环 ，等到一个AMS发出 的 ClientTransaction 消息//是怎么收到了呢？是AMS跨进程发送的，然后native收到消息，向上发送。//在MessagQueue的nativeInit会关联native层的NativeLooper和NativeMessagQueueloop():193, Looper (android.os)main(String[]):6669, ActivityThread (android.app)invoke(Object, Object[]):-1, Method (java.lang.reflect)run():493, RuntimeInit$MethodAndArgsCaller (com.android.internal.os)main(String[]):858, ZygoteInit (com.android.internal.os) 再来看下 android.app.Activity#onDestroy 1234567891011121314151617181920212223242526272829303132333435363738394041424344protected void onDestroy() { if (DEBUG_LIFECYCLE) Slog.v(TAG, \"onDestroy \" + this); mCalled = true; // dismiss any dialogs we are managing. // 取消所有的 dialogs if (mManagedDialogs != null) { final int numDialogs = mManagedDialogs.size(); for (int i = 0; i &lt; numDialogs; i++) { final ManagedDialog md = mManagedDialogs.valueAt(i); if (md.mDialog.isShowing()) { md.mDialog.dismiss(); } } mManagedDialogs = null; } // close any cursors we are managing. // 关闭所有的cursors synchronized (mManagedCursors) { int numCursors = mManagedCursors.size(); for (int i = 0; i &lt; numCursors; i++) { ManagedCursor c = mManagedCursors.get(i); if (c != null) { c.mCursor.close(); } } mManagedCursors.clear(); } // Close any open search dialog // 关闭 if (mSearchManager != null) { mSearchManager.stopSearch(); } if (mActionBar != null) { // 有ActionBar,调用onDestroy mActionBar.onDestroy(); } //最后交给Application dispatch getApplication().dispatchActivityDestroyed(this); } android.app.Application#dispatchActivityDestroyed 123456789void dispatchActivityDestroyed(Activity activity) { // 通知和回调所有的 callbacks。如果有注册了ActivityLifecycleCallbacks Object[] callbacks = collectActivityLifecycleCallbacks(); if (callbacks != null) { for (int i=0; i&lt;callbacks.length; i++) { ((ActivityLifecycleCallbacks)callbacks[i]).onActivityDestroyed(activity); } } } 可以通过 android.app.Application#registerActivityLifecycleCallbacks 注册destroye callbacks 基本到这里onDestroy 就是已经做完了。 再次总结 finish 主动调用，activity栈中就没有这个了，再也不能返回到这个activity。但是这个activity实例对象还在堆中 onDestory AMS回调,调用，比如上滑关闭Activity，比如手动调用finish引发onDestory。onDestroy只是关闭这个Activity对象 持有的一些系统资源。但是这个activity实例对象还在堆中 存在内存泄漏问题？就是上面的finish和onDestory 做完之后，这个activity实例对象还在堆中，还要等待GC的到来，但是，但是, 如果我们在其它地方错误的保留了一个对该activity实例的引用，间接或直接的引用，就会发生内存泄漏。就算你走完了finish和onDestory。最常见错误的就是 在Activity 中 保留了某一个单列的引用 来源及感谢Activity相关学习-finish activity https://www.jianshu.com/p/f3dbf635f2c4","link":"/2020/04/29/Android/finishandestroy/"},{"title":"Json转Map的后出现ClassCastException","text":"运行错误测试代码 12345678910import com.google.gson.Gsonfun main() { val map = HashMap&lt;String, Int&gt;() map[\"key1\"] = 111111 val jsonString = Gson().toJson(map) println(map::class.java) val hashMap = Gson().fromJson(jsonString, map::class.java) val key1:Int? = hashMap[\"key1\"] println(key1)} 运行的时候，会抛类型转换错误 1234class java.util.HashMapException in thread \"main\" java.lang.ClassCastException: java.lang.Double cannot be cast to java.lang.Integer at MainTestKt.main(MainTest.kt:9) at MainTestKt.main(MainTest.kt) 源码分析追踪调用栈，发现Gson里面处理number的逻辑,走到 MapTypeAdapterFactory 里面 1234567read:161, MapTypeAdapterFactory$Adapter (com.google.gson.internal.bind)read:145, MapTypeAdapterFactory$Adapter (com.google.gson.internal.bind)fromJson:888, Gson (com.google.gson)fromJson:853, Gson (com.google.gson)fromJson:802, Gson (com.google.gson)fromJson:774, Gson (com.google.gson)main:8, MainTestKt com.google.gson.internal.bind.ObjectTypeAdapter#read1234567891011121314151617181920212223242526272829303132333435363738@Override public Object read(JsonReader in) throws IOException { JsonToken token = in.peek(); switch (token) { case BEGIN_ARRAY: List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); in.beginArray(); while (in.hasNext()) { list.add(read(in)); } in.endArray(); return list; case BEGIN_OBJECT: Map&lt;String, Object&gt; map = new LinkedTreeMap&lt;String, Object&gt;(); in.beginObject(); while (in.hasNext()) { map.put(in.nextName(), read(in)); } in.endObject(); return map; case STRING: return in.nextString(); case NUMBER: return in.nextDouble(); case BOOLEAN: return in.nextBoolean(); case NULL: in.nextNull(); return null; default: throw new IllegalStateException(); } } 上面👆🏻源码可以看到，这里只针对处理了STRING，NUMBER，BOOLEAN，NULL的4中类型，其中对NUMBER类型，都是用Double去接受的。为什么编译的时候OK？ 类型擦除所有的泛型都是编译期间概念，在编译之后，运行的时候，是感知不到泛型的。泛型在编译的时候被擦除了，也就是输出class name的时候，还是map本身。泛型会在编译的时候，做检查。例如我们用double去接受，编译器会抛错，尽管运行的时候是double类型。编译之后再反编译回来, 运行时的逻辑就是这样的，并没有泛型信息。可以看到这里有个强转，而Integer是包装类型，不是基本类型，无法强转，导致抛错。 12345678910public static final void main() { HashMap map = new HashMap(); ((Map)map).put(\"key1\", 111111); String jsonString = (new Gson()).toJson(map); Class var2 = map.getClass(); System.out.println(var2); HashMap hashMap = (HashMap)(new Gson()).fromJson(jsonString, map.getClass()); Integer key1 = (Integer)hashMap.get(\"key1\"); System.out.println(key1);} JS number类型JSON（JavaScript Object Notation, JS对象简谱），和其他语言有多种数值类型不同，int/longint/float/double等，JS 不分整数和浮点型，所有数字都使用浮点型来储存。 总结可以成功运行 123456789fun main() { val map = HashMap&lt;String, Int&gt;() map[\"key1\"] = 111111 val jsonString = Gson().toJson(map) println(map::class.java) val hashMap = Gson().fromJson(jsonString, map::class.java) val key1:Any? = hashMap[\"key1\"] println(key1)} 1234class java.util.HashMap111111.0Process finished with exit code 0 我的理解是Gson和Json 表示对齐，默认number类型也是用double去解析的，当一个string json转换成map的时候，是感知不到泛型的，实际上的map是map&lt;string,object&gt;类型，而写代码的时候存在泛型过了编译，导致运行的时候抛错","link":"/2022/08/20/Android/json2map-cast-error/"},{"title":"你是怎么收到 TouchEvent 的？","text":"基于Android 9 分析 InputEventReceiver框架层可见的点击事件从哪里来？所有的事件都是由InputEventReceiver 先接受再分发出来的， 123456 // Called from native code.@SuppressWarnings(\"unused\")private void dispatchInputEvent(int seq, InputEvent event, int displayId) { mSeqMap.put(event.getSequenceNumber(), seq); onInputEvent(event, displayId);} 那native code 又是怎么才会调上来的呢？那就是在 InputEventReceiver 初始化的时候，需要注册。就是在 nativeInit 方法里面 123456789101112131415161718192021/** * Creates an input event receiver bound to the specified input channel. * * @param inputChannel The input channel. * @param looper The looper to use when invoking callbacks. */ public InputEventReceiver(InputChannel inputChannel, Looper looper) { if (inputChannel == null) { throw new IllegalArgumentException(\"inputChannel must not be null\"); } if (looper == null) { throw new IllegalArgumentException(\"looper must not be null\"); } mInputChannel = inputChannel; mMessageQueue = looper.getQueue(); mReceiverPtr = nativeInit(new WeakReference&lt;InputEventReceiver&gt;(this), inputChannel, mMessageQueue); mCloseGuard.open(\"dispose\"); } InputChannel An input channel specifies the file descriptors used to send input events to a window in another process. It is Parcelable so that it can be sent to the process that is to receive events. Only one thread should be reading from an InputChannel at a time. 输入通道指定用于在另一个进程中将输入事件发送到窗口的文件描述符。 它是Parcelable，因此可以将其发送到要接收事件的进程。 一次只能一个线程从InputChannel读取。 12private static native long nativeInit(WeakReference&lt;InputEventReceiver&gt; receiver, InputChannel inputChannel, MessageQueue messageQueue); 先来看一 InputEventReceiver 的初始化 又是谁调用的呢？在我们启动App的时候，最先由AMS跨进程传输的一个ClientTransaction，客户端进程ApplicationThread接收，然后发送到主线程ActivityThread，最后由TransactionExecutor统一解析。AMS封装并传输ClientTransaction，统一接口；客户端进程接收ClientTransaction并使用TransactionExecutor解析AMS的请求，再根据ActivityLifecycleItem执行不同的代码。Activity的生命周期就是 transaction.getLifecycleStateRequest() 获取的，然后再执行响应的生命周期回调。 调用栈 123456789101112131415161718192021222324252627282930313233343536373839&lt;init&gt;(InputChannel, Looper):60, InputEventReceiver (android.view)&lt;init&gt;(ViewRootImpl, InputChannel, Looper):7190, //最终调用到 InputEventReceiver 初始化ViewRootImpl$WindowInputEventReceiver (android.view)//这里会初始化几个inputStagesetView(View, WindowManager$LayoutParams, View):847, ViewRootImpl (android.view)//DecorView 添加 我们自己写的 MainActivityaddView(View, ViewGroup$LayoutParams, Display, Window):356, WindowManagerGlobal (android.view)//WindowManagerGlobal 添加 DecorViewaddView(View, ViewGroup$LayoutParams):93, WindowManagerImpl (android.view)//执行 ResumehandleResumeActivity(IBinder, boolean, boolean, String):3868, ActivityThread (android.app)execute(ClientTransactionHandler, IBinder,PendingTransactionActions):51, ResumeActivityItem (android.app.servertransaction)//executeLifecycleState方法是用来改变Activity的生命周期状态的//transaction.getLifecycleStateRequest() 获取的executeLifecycleState(ClientTransaction):145, //然后交给TransactionExecutor 统一调度TransactionExecutor (android.app.servertransaction)execute(ClientTransaction):70, TransactionExecutor (android.app.servertransaction)//首先是ActivityThread 收到一个ClientTransaction的消息handleMessage(Message):1808, ActivityThread$H (android.app)dispatchMessage(Message):106, Handler (android.os)loop():193, Looper (android.os)main(String[]):6669, ActivityThread (android.app)invoke(Object, Object[]):-1, Method (java.lang.reflect)run():493, RuntimeInit$MethodAndArgsCaller (com.android.internal.os)main(String[]):858, ZygoteInit (com.android.internal.os) 我们可以看到 在 android.view.ViewRootImpl#setView当中调用了,这个looper就是主线程的looepr了。这个InputChannel 实际上指向我们自己写的MainActivity (client) 12mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); 再来看一 nativeInit 又做了什么呢？在NativeInputEventReceiver的nativeInit方法中，创建了NativeInputEventReceiver对象，并调用它的initialize方法 1234567891011121314151617static jint nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak, jobject inputChannelObj, jobject messageQueueObj) { ... //用传过来的inputChannel和messageQueue构建一个NativeInputEventReceiver sp&lt;NativeInputEventReceiver&gt; receiver = new NativeInputEventReceiver(env, receiverWeak, inputChannel, messageQueue); //然后调用它的初始化方法 status_t status = receiver-&gt;initialize(); ...}status_t NativeInputEventReceiver::initialize() { setFdEvents(ALOOPER_EVENT_INPUT); return OK;} mMessageQueue-&gt;getLooper()-&gt;addFd(fd, 0, events, this, NULL); 实际上就把JAVA层的Looper关联ALOOPER_EVENT_INPUT 1234567891011void NativeInputEventReceiver::setFdEvents(int events) { if (mFdEvents != events) { mFdEvents = events; int fd = mInputConsumer.getChannel()-&gt;getFd(); if (events) { mMessageQueue-&gt;getLooper()-&gt;addFd(fd, 0, events, this, NULL); } else { mMessageQueue-&gt;getLooper()-&gt;removeFd(fd); } }} fd，fd即inputChannel的socket fd，Looper会侦测该fd的状态 events，即传入的ALOOPER_EVENT_INPUT，只有fd的状态是INPUT的时候才会触发调用LooperCallback中的handleEvent方法 this，即NativeInputEventReceiver，当fd状态为Input时，NativeInputEventReceiver中的handleEvent方法会被调用 在consumeEvents内，我们能看到调用了InputConsume::consume来接收InputDispatcher发送过来的事件 1234567status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env, bool consumeBatches, nsecs_t frameTime, bool* outConsumedBatch) { for (;;) { status_t status = mInputConsumer.consume(&amp;mInputEventFactory, consumeBatches, frameTime, &amp;seq, &amp;inputEvent); }} 最终回调到 java 层的 InputEventReceiver#dispatchInputEvent 。 12env-&gt;CallVoidMethod(receiverObj.get(), gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj); 通过上述的JNI调用，会调用到WindowInputEventReceiver的dispatchInputEvent方法，不过由于WindowInputEventReceiver并没有自己实现这个方法，因此会调用父类InputEventReceiver::dispatchInputEvent，内部会真正调用到android.view.ViewRootImpl.WindowInputEventReceiver#onInputEvent 接下来就是JAVA层，一层层分发事件了 android.view.ViewRootImpl.WindowInputEventReceiver#onInputEvent 123public void onInputEvent(InputEvent event, int displayId) { enqueueInputEvent(event, this, 0, true); } android.view.ViewRootImpl#enqueueInputEvent(android.view.InputEvent, android.view.InputEventReceiver, int, boolean) 1234567891011121314151617181920212223242526272829303132void enqueueInputEvent(InputEvent event, InputEventReceiver receiver, int flags, boolean processImmediately) { adjustInputEventForCompatibility(event); // 池 包装,类似 obtainMessage QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags); QueuedInputEvent last = mPendingInputEventTail; //入队到 所有 等候 的InputEvent if (last == null) { mPendingInputEventHead = q; mPendingInputEventTail = q; } else { last.mNext = q; mPendingInputEventTail = q; } //等候的事件+1 mPendingInputEventCount += 1; //打个日志 Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName, mPendingInputEventCount); //是不是立即处理改事件 if (processImmediately) { doProcessInputEvents(); } else { //还是加到调度器里面 //这里实际上是发送异步消息 mHandler.sendMessage(msg); scheduleProcessInputEvents(); } } 从 enqueueInputEvent(event, this, 0, true) 看 ，这里的事件是processImmediately = true的，所以进一步再追一下 doProcessInputEvents() 12345678910111213141516171819202122232425262728293031323334353637383940414243void doProcessInputEvents() { // Deliver all pending input events in the queue. // 分发所有的 等候 InputEvent while (mPendingInputEventHead != null) { //出队 QueuedInputEvent q = mPendingInputEventHead; mPendingInputEventHead = q.mNext; if (mPendingInputEventHead == null) { mPendingInputEventTail = null; } q.mNext = null; //count-- mPendingInputEventCount -= 1; //打个日志 Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName, mPendingInputEventCount); long eventTime = q.mEvent.getEventTimeNano(); long oldestEventTime = eventTime; if (q.mEvent instanceof MotionEvent) { MotionEvent me = (MotionEvent)q.mEvent; if (me.getHistorySize() &gt; 0) { oldestEventTime = me.getHistoricalEventTimeNano(0); } } mChoreographer.mFrameInfo.updateInputEventTime(eventTime, oldestEventTime); //这里具体 去分发处理该次事件 deliverInputEvent(q); } // We are done processing all input events that we can process right now // so we can clear the pending flag immediately. // 因为我们已经 分发完了 所有等候 的 InputEvent //清除wath = MSG_PROCESS_INPUT_EVENTS 的消息 if (mProcessInputEventsScheduled) { mProcessInputEventsScheduled = false; mHandler.removeMessages(MSG_PROCESS_INPUT_EVENTS); } } 接下来再继续追一下 android.view.ViewRootImpl#deliverInputEvent 12345678910111213141516171819202122232425262728293031 private void deliverInputEvent(QueuedInputEvent q) { //又打个日志 Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, \"deliverInputEvent\",q.mEvent.getSequenceNumber()); // 这个描述是 方便debug的,不影响后面的处理 if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onInputEvent(q.mEvent, 0); } InputStage stage; if (q.shouldSendToSynthesizer()) { stage = mSyntheticInputStage; } else { stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage; } if (q.mEvent instanceof KeyEvent) { mUnhandledKeyManager.preDispatch((KeyEvent) q.mEvent); } //上面决定将事件派发到那个InputStage处理 if (stage != null) { handleWindowFocusChanged(); stage.deliver(q); } else { finishInputEvent(q); }} deliverInputEvent先判断将事件派发到那个InputStage，然后调用该InputState的deliver方法 那么InputStage 又是 什么？12345678910111213141516171819202122public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) { ... mSyntheticInputStage = new SyntheticInputStage(); InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage); InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage, \"aq:native-post-ime:\" + counterSuffix); InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage); InputStage imeStage = new ImeInputStage(earlyPostImeStage, \"aq:ime:\" + counterSuffix); InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage); InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage, \"aq:native-pre-ime:\" + counterSuffix); mFirstInputStage = nativePreImeStage; mFirstPostImeInputStage = earlyPostImeStage; ...} InputStage 是在setView()的时候创建的，也就是在Activity的onResume() 通过一路的 forward deliver ，最后走到apply 的 onProcess 方法中去。也就是android.view.ViewRootImpl.ViewPostImeInputStage#onProcess 123456789101112131415protected int onProcess(QueuedInputEvent q) { if (q.mEvent instanceof KeyEvent) { return processKeyEvent(q); } else { final int source = q.mEvent.getSource(); if ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) { //处理点触摸事件 return processPointerEvent(q); } else if ((source &amp; InputDevice.SOURCE_CLASS_TRACKBALL) != 0) { return processTrackballEvent(q); } else { return processGenericMotionEvent(q); } } } 那么再来看下一 android.view.ViewRootImpl.ViewPostImeInputStage#processPointerEvent 里面又是怎么发的？ 12345678910111213141516171819202122private int processPointerEvent(QueuedInputEvent q) { final MotionEvent event = (MotionEvent)q.mEvent; mAttachInfo.mUnbufferedDispatchRequested = false; mAttachInfo.mHandlingPointerEvent = true; //mView 就是 android.view.ViewRootImpl#setView 的时候传入的View，也就是 DecorView //接下里就是 走到 DecorView的dispatchPointerEvent 中去了 //标记1，这里第一次 把事件发到 DecorView 中 boolean handled = mView.dispatchPointerEvent(event); maybeUpdatePointerIcon(event); maybeUpdateTooltip(event); mAttachInfo.mHandlingPointerEvent = false; if (mAttachInfo.mUnbufferedDispatchRequested &amp;&amp; !mUnbufferedInputDispatch) { mUnbufferedInputDispatch = true; if (mConsumeBatchedInputScheduled) { scheduleConsumeBatchedInputImmediately(); } } return handled ? FINISH_HANDLED : FORWARD; } 当调用到 DecorView 的 dispatchPointerEvent ，实际上是 android.view.View#dispatchPointerEvent ，接下来的问题实际上就是 view的事件分发了？ 123456789 public final boolean dispatchPointerEvent(MotionEvent event) { //是点击事件,转到dispatchTouchEvent if (event.isTouchEvent()) { return dispatchTouchEvent(event); } else { return dispatchGenericMotionEvent(event); }} 转接到 com.android.internal.policy.DecorView#dispatchTouchEvent 123456789public boolean dispatchTouchEvent(MotionEvent ev) { //Activity实现了Window.Callback接口 android.app.Activity#attach中 mWindow.setCallback(this); 所以这个callback指向Activity // mWindow 就是 PhoneWindow ，在 DecorView 初始化的时候传入的 final Window.Callback cb = mWindow.getCallback(); // 标记2，这里从DecorView 把事件转发到 Activity 中 return cb != null &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev);} 最后cb.dispatchTouchEvent(ev) 就相当于 走入到了 android.app.-Activity#dispatchTouchEvent 1234567891011121314 public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } //事件又被传递到了PhoneWindow中去分发这个事件 //如果被消费了，直接return //标记3，这里把事件从Activty转发到phoneWindow中去了 if (getWindow().superDispatchTouchEvent(ev)) { return true; } // 如果上面没有被消费，则进入Activity 的 onTouchEvent return onTouchEvent(ev);} Activity 的 getWindow() 就是 android.app.Activity#attach中的mWindow ，也就是 PhoneWindow。 com.android.internal.policy.PhoneWindow#superDispatchTouchEvent 12345 @Overridepublic boolean superDispatchTouchEvent(MotionEvent event) { //纳尼，又 转接到了 DecorView 中去 return mDecor.superDispatchTouchEvent(event);} 从上面的标记1，2，3 可以看到，首先事件从 android.view.ViewRootImpl.ViewPostImeInputStage#processPointerEvent 发到 DecorView ,DecorView 再分发事件的时候，通过 Window 获取callback 拿到 Activity ,转交给Activity 去发送，但是Activity又通过 getWindow，又把事件转交给Window ，Window 最后又通过mDecor.superDispatchTouchEvent(event) 转交给 了DecorView。搞半天？最后还是回到 android.view.ViewRootImpl.ViewPostImeInputStage#processPointerEvent 的 mView.dispatchPointerEvent(event)中？ 显然不是 第一次调用的是 DecorView.dispatchPointerEvent(event) ，第二次回到 DecorView是调用的 DecorView.superDispatchTouchEvent(event);也就调用到 DecorView 的父类 DispatchTouchEvent ，最后也就是 android.view.ViewGroup#dispatchTouchEvent的了。 一小段调用栈 123456789---dispatchTouchEvent(MotionEvent):2543, ViewGroup (android.view)//ViewGroup 分发事件superDispatchTouchEvent(MotionEvent):440, DecorView (com.android.internal.policy)//第二次superDispatchTouchEvent(MotionEvent):1830, PhoneWindow (com.android.internal.policy)dispatchTouchEvent(MotionEvent):3400, Activity (android.app)dispatchTouchEvent(MotionEvent):398, DecorView (com.android.internal.policy)//第一次dispatchPointerEvent(MotionEvent):12752, View (android.view)processPointerEvent(ViewRootImpl$QueuedInputEvent):5106,、--- 辗转的原因？来自 https://www.jianshu.com/p/b7cef3b3e703为什么在InputStage.processPointerEvent()中不直接把事件传递给Activity，而是这样来回绕一圈。这样DecorView -&gt; Activity -&gt; PhoneWindow -&gt; DecorView的来回绕一圈不是很折腾吗？ 首先，为了解耦，ViewRootImpl并不知道有Activity这种东西存在！不知道！它只是持有了DecorView。所以，想要直接把触摸事件送到Activity.dispatchTouchEvent() 是不行的。 那么，既然触摸事件已经到了Activity.dispatchTouchEvent()中了，为什么不直接分发给DecorView ，而是要通过PhoneWindow 来间接发送呢？因为Activity 不知道有DecorView 这种奇怪的东西存在啊！不知道！但是，Activity持有PhoneWindow ，而PhoneWindow当然知道自己的窗口里有些什么了，所以能够把事件派发给DecorView 。你看，在Android中，Activity并不知道自己的Window中有些什么，这样耦合性就很低了。我们换一个Window试试？不管Window里面的内容如何，只要Window任然符合Activity制定的标准，那么它就能在Activity中很好的工作。这就是解耦所带来的扩展性的好处。 作者：CoorChice链接：https://www.jianshu.com/p/b7cef3b3e703来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ViewGroup 的事件分发流程？首先分清楚 3个方法 dispatchTouchEvent() 分发器，决定事件怎么分发，会先询问onInterceptTouchEvent()，如果拦截了 进一步到 自己的 onTouchEvent() 中去。如果没有拦截，转发到子view的dispatchTouchEvent() onInterceptTouchEvent() 拦截器 是ViewGroup特有的方法，可以判断和拦截要不要将事件下发到子view去处理。 onTouchEvent() 处理器。最后的一个子view 收到事件将会直接由【分发器】分发到【处理器】中。如果处理了返回true，如果不处理返回false，那么事件将传递到它的父级的【处理器】中。 不管个层级的【处理器】，如果处理事件返回true，一次触摸事件就结束了。如果不处理事件，返回false，就是事件还没有被消费，就会传送到上一级的【处理器】中。最终，如果DecorView的【处理器】也不打算处理事件，那么事件将会被发送到Activity的【处理器】中处理。 说白了，就是先交给子view优先消费，消费不了，返回了，我再消费。 那么ViewGroup dispatchTouchEvent()又是怎么把事件发到child view中去的呢？ android.view.ViewGroup#dispatchTouchEvent 12345678910111213141516171819202122232425262728293031// Find a child that can receive the event.// Scan children from front to back.// 找一个可以接受这个事件的子view,从后面向前找，找到一个就结束final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled();final View[] children = mChildren;for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } //该次点击是不是落在了 子view的 布局范围之中，且子view 可以接受点击，比如可见 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } 可能存在的问题，就是布局重叠的时候，收不到响应？ 最后再子view的 android.view.View#onTouchEvent中，包装成一个 mPerformClick ,最后通过 mHandler.post(action) 把这个 action 发到 主线程的looper 里面去处理了，然后looepr 处理消息，调用action ，就是我们set的OnClickListener里面去了。 android.os.Handler#dispatchMessage 1234567891011121314public void dispatchMessage(Message msg) { // msg.callback = performClick //开始处理 处理 Callback if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); }} 最后 调到 message.callback.run(); 然后 在run() 调用 performClick() 中的 mOnClickListener.onClick(this); 最后我们 就开始我们的OnClick 逻辑了 总结 最后一张大图 感谢[Android] 输入系统（二）] https://www.cnblogs.com/TaigaCon/p/4750349.html 作者：CoorChice链接：https://www.jianshu.com/p/b7cef3b3e703来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2020/04/27/Android/touchevent/"},{"title":"View的几个高度&#x2F;宽度","text":"自定义view的过程onMeasure()–&gt;onLayout()–&gt;onDraw() onMeasure() 计算当前各个子view的高宽度 onLayout() 确定各个子view在父容器的位置 需要4个参数确定子view的位置。都是相对父容器的left 左边距离top 上边距离right 右边距离bottom 下边距离如果我想让某个子view占据父布局的上一半。就是 child.layout(0,0,0,1/2*父容器的高度) onDraw() 开始绘制 真正开始具体绘制 1 view.getLayoutParams().height/width获取当前view在父容器中的布局宽高度, 父容器根据LayoutParams()可以确定这个view的怎么布局。这里的height 和 width 可以是具体的数，也可以是如下的参数。每个不一样的ViewGroup拥有不一样的LayoutParams。LayoutParams()不仅仅是确定高度和宽度，还可以确定Margin，gravity。 获取来源：1.动态布局，可以任何时候手动setLayoutParams，setLayoutParams方法里面会触发requestLayout();requestLayout触发父容器重新依次计算子view在父布局的位置。2.android.view.ViewGroup 的绘制过程中的方法会自动调用 view.setLayoutParams(params);注意可能获取为null，还没没有添加到布局中，自然不存在 LayoutParams。在方法 public void addView(**)会创建params = generateDefaultLayoutParams();每一种不同的布局类型，不同的generateDefaultLayoutParams初始化策略。 获取时机：addView之后 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static class LayoutParams { /** * Special value for the height or width requested by a View. * FILL_PARENT means that the view wants to be as big as its parent, * minus the parent's padding, if any. This value is deprecated * starting in API Level 8 and replaced by {@link #MATCH_PARENT}. */ @SuppressWarnings({\"UnusedDeclaration\"}) @Deprecated public static final int FILL_PARENT = -1; /** * Special value for the height or width requested by a View. * MATCH_PARENT means that the view wants to be as big as its parent, * minus the parent's padding, if any. Introduced in API Level 8. */ public static final int MATCH_PARENT = -1; /** * Special value for the height or width requested by a View. * WRAP_CONTENT means that the view wants to be just large enough to fit * its own internal content, taking its own padding into account. */ public static final int WRAP_CONTENT = -2; /** * Information about how wide the view wants to be. Can be one of the * constants FILL_PARENT (replaced by MATCH_PARENT * in API Level 8) or WRAP_CONTENT, or an exact size. */ @ViewDebug.ExportedProperty(category = \"layout\", mapping = { @ViewDebug.IntToString(from = MATCH_PARENT, to = \"MATCH_PARENT\"), @ViewDebug.IntToString(from = WRAP_CONTENT, to = \"WRAP_CONTENT\") }) public int width; /** * Information about how tall the view wants to be. Can be one of the * constants FILL_PARENT (replaced by MATCH_PARENT * in API Level 8) or WRAP_CONTENT, or an exact size. */ @ViewDebug.ExportedProperty(category = \"layout\", mapping = { @ViewDebug.IntToString(from = MATCH_PARENT, to = \"MATCH_PARENT\"), @ViewDebug.IntToString(from = WRAP_CONTENT, to = \"WRAP_CONTENT\") }) public int height; ...} 2 view().getHeight()/getWidth()获取当前view的高度和宽度，需在onLayout之后获取，就是用laout中的 宽度就是=左边-去右边 高度 = 上边-下边 获取时机：必须在onLayout 之后 1234567public final int getHeight() { return mBottom - mTop; } public final int getWidth() { return mRight - mLeft; } 3 view().getMeasuredHeight()/getMeasuredWidth()获取view自己的原始高度, 123456789 //The raw measured width of this view. public final int getMeasuredWidth() { //取mod MEASURED_SIZE_MASK = 0x00ffffff; return mMeasuredWidth &amp; MEASURED_SIZE_MASK; } //The raw measured height of this view. public final int getMeasuredHeight() { return mMeasuredHeight &amp; MEASURED_SIZE_MASK;} 值的来源 onMeasure中调用的setMeasuredDimensionRaw 123456private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) { mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET; } setMeasuredDimensionRaw来源于view#measure(int widthMeasureSpec, int heightMeasureSpec)widthMeasureSpec 和 heightMeasureSpec 和 view 和 原始layoutpram 又相关。 获取时机：必须在view的onMeasure之后 关于MeasuredHeight() 请参考 MeasureSpec 4. 出发点的BUG 为什么view重叠的时候，有时可以点击？而有时不可以点击？如图所示，存在以为视图布局如下,当以你以为的布局进行点击的时候，发现点击小view时而可以，时而不行？why？本质是点击事件的分发有关，点击事件由ViewGroup发往子View的时候，是从后面向前遍历的。也就是说，当2个view重叠的情况，谁在后面，谁响应本次事件。 可见android.view.ViewGroup#dispatchTouchEvent 1234567891011121314151617181920212223242526272829303132333435public boolean dispatchTouchEvent(MotionEvent ev){ --- if (newTouchTarget == null &amp;&amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. // 从后向前遍历 一个可以接受点击事件的 view final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } //判断子 view 能不能收到 点击事件，和点击事件是不是在 子view的范围中 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) ---} 最后才在 dispatchTransformedTouchEvent 调用 child.dispatchTouchEvent(event) 在onMeasure 调用 super.onMeasure 在super.onMeasure中计算子view的高度的时候会用到子view原来的LayoutParams，然后再计算 set子view的LayoutParams的，最后在onLayout的时候 通过 getMeasuredWidth()获取高度。问题在于getMeasuredWidth()获取的高度是在super.onMeasure的时候就已经确定了的，并不是在在onMeasure计算的高度，实际在于刚才set的LayoutParams。后面进入的时候 LayoutParams已经被更新了，再次super.onMeasure 更新的MeasuredWidth()就是和新的LayoutParams相关了,展示就会正确。 问题就是第一次进来的时候就会获取错误的高度，onlayout并不是我们手动计算的高度。","link":"/2020/04/26/Android/viewsomeheight/"},{"title":"理解MeasureSpec  widthMeasureSpec&#x2F;heightMeasureSpec","text":"在 onMeasure中的参数 heightMeasureSpec 又是什么？ MeasureSpec是父控件提供给子View的onMeaure参数，作为设定自身大小参考，只是个参考，要多大，还是View自己说了算。 MeasureSpec 是一个复合参数，包含了specMode和specSize,可以通过如下获取。 12int specMode = MeasureSpec.getMode(measureSpec);int specSize = MeasureSpec.getSize(measureSpec); 也可以通过如下合并 1MeasureSpec.makeMeasureSpec(resultSize, resultMode); specMode 有3种模式 UNSPECIFIED：不对View大小做限制，如：ListView，ScrollView EXACTLY：确切的大小，如：100dp或者march_parent AT_MOST：大小不可超过某数值，如：wrap_content 子View的MeasureSpec由父View的MeasureSpec和子View本身的LayoutPramas共同决定，在ViewGroup的getChildMeasureSpec方法中实现，具体解析在下面代码中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//spec parentWidthMeasureSpec// childDimension 是子view 自己的维度public static int getChildMeasureSpec(int spec, int padding, int childDimension) { //获取的父容器的 mode size int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) { //如果父容器 是 EXACTLY：确切的大小，如：100dp或者march\\_parent case MeasureSpec.EXACTLY: //如果child view 有具体的大小。则直接就用这个大小。 // 例如child view 的xml里面描述的高度是 100dp if (childDimension &gt;= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; //如果子child view的维度描述是 MATCH_PARENT } else if (childDimension == LayoutParams.MATCH_PARENT) { //那么child view的size就是 等于 父容器的size //mode 也等于父容器的mode resultSize = size; resultMode = MeasureSpec.EXACTLY; //如果子child view的维度描述是 WRAP_CONTENT } else if (childDimension == LayoutParams.WRAP_CONTENT) { //那么child view的size也等于 父容器的size。但是mode是AT_MOST，child view可以参考这个size resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // 如果父容器使用的是 AT\\_MOST：大小不可超过某数值，如：wrap\\_content case MeasureSpec.AT_MOST: //还是如果child view 指定了高度，都采用自己的高度，mode也是EXACTLY if (childDimension &gt;= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; //如果子child view的维度描述是 MATCH_PARENT } else if (childDimension == LayoutParams.MATCH_PARENT) { //child view 的参考size 等同于 父容器的size //但此时父容器的size没有确定值,所以mode也同于AT_MOST resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (childDimension == LayoutParams.WRAP_CONTENT) { //那么child view的size也等于 父容器的size。但是mode是AT_MOST，child view可以参考这个size resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; //如果父容器使用的是 UNSPECIFIED：不对View大小做限制，如：ListView，ScrollView case MeasureSpec.UNSPECIFIED: //还是如果child view 指定了高度，都采用自己的高度，mode也是EXACTLY if (childDimension &gt;= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // 子view MATCH_PARENT,则同于父size mode也是UNSPECIFIED resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } else if (childDimension == LayoutParams.WRAP_CONTENT) { //WRAP_CONTENT resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } break; } //拼装Size 和Mode ,返回这个子view的MeasureSpec return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } MeasureSpec不管父容器是什么szie和mode，如果child view 指定了高度，都采用自己的高度，mode也是EXACTLY 当子View接收到父控件传递的MeasureSpec的时候，就可以知道父控件希望自己如何显示，这个点对于开发者而言就是onMeasure函数 ViewGroup在计算自己尺寸的时候，必须预先知道所有子View的尺寸 如果父控件传递给的MeasureSpec的mode是MeasureSpec.UNSPECIFIED，就说明，父控件对自己没有任何限制，那么尺寸就选择自己需要的尺寸size 如果父控件传递给的MeasureSpec的mode是MeasureSpec.EXACTLY，就说明父控件有明确的要求，希望自己能用measureSpec中的尺寸，这时就推荐使用MeasureSpec.getSize(measureSpec) 如果父控件传递给的MeasureSpec的mode是MeasureSpec.AT_MOST，就说明父控件希望自己不要超出MeasureSpec.getSize(measureSpec)，如果超出了，就选择MeasureSpec.getSize(measureSpec)，否则用自己想要的尺寸就行了 ViewGroup的尺寸其实只需要三部： 测量所有子View，获取所有子View的尺寸 根据自身特点计算所需要的尺寸 综合考量需要的尺寸跟父控件传递的MeasureSpec，得出一个合理的尺寸 顶层View的MeasureSpec是谁指定传递给子View的MeasureSpec是父容器根据自己的MeasureSpec及子View的布局参数所确定的，那么根MeasureSpec是谁创建的呢？我们用最常用的两种Window来解释一下，Activity与Dialog，DecorView是Activity的根布局，传递给DecorView的MeasureSpec是系统根据Activity或者Dialog的Theme来确定的，也就是说，最初的MeasureSpec是直接根据Window的属性构建的，一般对于Activity来说，根MeasureSpec是EXACTLY+屏幕尺寸，对于Dialog来说，如果不做特殊设定会采用AT_MOST+屏幕尺寸。这里牵扯到WindowManagerService跟ActivityManagerService 感谢123456链接：https://www.jianshu.com/p/cecd0de7ec27来源：简书作者：看书的小蜗牛链接：https://www.jianshu.com/p/d16ec64181f2来源：简书","link":"/2020/04/26/Android/widthMeasureSpec-heightMeasureSpec/"},{"title":"App Debug 主线程，出现ANR后被系统Kill","text":"痛点笔者手上有个Reamle GT，日常开发工作中，是不是会debug，断点在主线程里面，基本被kill，没办法调试代码，自动重启给开发带来很大困扰，实在受不了，着手解决。 环境：realme gt，Android11，realme ui 2.0 思路先全局找log，发现信息，框架里面一定会留下下什么。复现一次，采集logcat，尝试搜索包名，kill app 多关注 ActivityManager。 找实现逻辑仔细筛选一下， 发现了这个日志，就是罪魁祸首了 104-23 14:07:36.545 1397 1695 I ActivityManager: Killing 13134:com.hi.dhl.startup.simple/u0a297 (adj 0): user request after error:Input dispatching timed out (3f0c272 com.simple/com.simple.MainActivity (server) is not responding. Waited 5001ms for MotionEvent) 接着过滤一下ActivityManager log，可以看到有出现ANR之后，处理完ANR之后，app就被kill了 12345678910111213141516171819202122237485: 04-23 14:07:36.527 1397 13246 E ActivityManager: 0% 12803/kworker/4:2-mm_percpu_wq: 0% user + 0% kernel7486: 04-23 14:07:36.527 1397 13246 E ActivityManager: +0% 13207/logcat: 0% user + 0% kernel7487: 04-23 14:07:36.527 1397 13246 E ActivityManager: 3.7% TOTAL: 1% user + 1.8% kernel + 0% iowait + 0.6% irq + 0.1% softirq7488: 04-23 14:07:36.527 1397 13246 E ActivityManager: CPU usage from 61ms to 379ms later (2022-04-23 14:07:36.082 to 2022-04-23 14:07:36.400):7489: 04-23 14:07:36.527 1397 13246 E ActivityManager: 37% 1397/system_server: 10% user + 27% kernel / faults: 921 minor7490: 04-23 14:07:36.527 1397 13246 E ActivityManager: 31% 13246/AnrConsumer: 6.8% user + 24% kernel7491: 04-23 14:07:36.527 1397 13246 E ActivityManager: 3.4% 2468/SensorService: 0% user + 3.4% kernel7492: 04-23 14:07:36.527 1397 13246 E ActivityManager: 3.4% 2790/OplusAppBwCore: 0% user + 3.4% kernel7493: 04-23 14:07:36.527 1397 13246 E ActivityManager: 3.2% 356/kworker/u24:6-ufs_clk_gating_0: 0% user + 3.2% kernel7494: 04-23 14:07:36.527 1397 13246 E ActivityManager: 3.3% 1008/usbtemp_kthread: 0% user + 3.3% kernel7495: 04-23 14:07:36.527 1397 13246 E ActivityManager: 4.2% 11938/kworker/u24:2-memlat_wq: 0% user + 4.2% kernel7496: 04-23 14:07:36.527 1397 13246 E ActivityManager: 7.2% TOTAL: 2% user + 4.8% kernel + 0.4% irq7497 04-23 14:07:36.527 1397 13246 V java.lang.ASSERT: copyAnr filePath = /data/anr/anr_2022-04-23-14-07-36-4287499 04-23 14:07:36.528 1397 13246 D OplusManager: send on stamp success7500: 04-23 14:07:36.528 1397 13246 D ActivityManager: Completed ANR of com.simple in 508ms, latency 1ms7501: 04-23 14:07:36.529 1397 1695 W ActivityManager: Dismiss app ANR dialog : com.simple 7502: 04-23 14:07:36.529 1397 1695 W ContextImpl: Calling a method in the system process without a qualified user: android.app.ContextImpl.sendBroadcast:1161 com.android.server.am.OplusExtraActivityManagerService.setKeyLockModeNormal:51 com.android.server.am.ActivityManagerService.killAppAtUsersRequest:10688 com.android.server.am.AppErrors.handleShowAnrUi:966 com.android.server.am.ActivityManagerService$UiHandler.handleMessage:1884 7503 04-23 14:07:36.529 1397 13247 I DropBoxManagerService: add tag=data_app_anr isTagEnabled=true flags=0x27527 04-23 14:07:36.544 1397 1695 D ScreenMode: switch from 2 to 37528: 04-23 14:07:36.545 1397 1695 I ActivityManager: Killing 13134:com.simple /u0a297 (adj 0): user request after error:Input dispatching timed out (3f0c272 com.simple /com.simple .MainActivity (server) is not responding. Waited 5001ms for MotionEvent)7529 04-23 14:07:36.545 1397 1700 D OplusFeatureHDREnhanceBrightness: onConfigChangedthreadId=22, threadName=android.display, configId=1 基本可以确定，是出现ANR之后，被kill了，但是其他手机上，会出现个ANR对话框，可以确定的是，开发者选项里面的已经开启了。那么厂商是怎么做的呢？去拉一下框架代码 1adb pull /system/framework 首先来看一下 framework.jar ,去看下Activity Manager的代码去搜索一下 日志里面的字段，很遗憾没有找到什么。除了 framework.jar 还有 services.jar，一些系统服务在里面。在services.jar 里面，发现一些端倪，去追 ，果然是在ActivityManagerService里面 12345678910111213141516171819public void killAppAtUserRequestLocked(ProcessRecord app) { String killAnnotation; ProcessRecord.ErrorDialogController controller = app.getDialogController(); int reasonCode = 6; int subReason = 0; if (controller.hasDebugWaitingDialog()) { reasonCode = 13; subReason = 1; } controller.clearAllErrorDialogs(); if (app == null || app.mAnrAnnotation == null) { killAnnotation = \"user request after error\"; } else { String killAnnotation2 = \"user request after error:\" + app.mAnrAnnotation; app.mAnrAnnotation = null; killAnnotation = killAnnotation2; } killAppImmediateLocked(app, reasonCode, subReason, \"user-terminated\", killAnnotation);} 调用来着 123456789101112131415public void killAppAtUsersRequest(ProcessRecord app) { synchronized (this) { try { boostPriorityForLockedSection(); if (app.pid &gt; 0 &amp;&amp; app.pid != MY_PID) { OplusExtraActivityManagerService.setKeyLockModeNormal(this.mContext, app.processName, this.mSystemReady); } this.mAppErrors.killAppAtUserRequestLocked(app); } catch (Throwable th) { resetPriorityAfterLockedSection(); throw th; } } resetPriorityAfterLockedSection();} 继续追调用，发现有4个地方在引用，我们挨个确认一下，在在 handleShowAnrUi 里面，可以发现这段逻辑向上去追这段逻辑，发现有个控制逻辑_ java.lang.String r5 = “persist.sys.assert.panic”， _在shell里面getpro试一下，得到默认false。我们现在要跳过kill的逻辑，改掉这个值不就可以啦。 修改_ 不幸的是，persist.sys.是系统属性，普通用户没有权限修改，也就是说需要root权限。root权限，需要解锁。解锁部分可以去xda看看，也是申请解锁，启动twrp，刷写magisk那一套。root完之后，shell里面，su setpro _persist.sys.assert.panic = true。 验证现在断点在主线程里面，就出现弹窗，不会直接kill debug的app了。想断多久就多久了。 建议国内可以考虑小米和一加，解锁和刷机起来比较简单，可以刷一些简单的ROM，调试和可玩性都比较高。","link":"/2022/04/30/Android/ui-timeout-kill-app-md/"},{"title":"如何下载AOSP (Android Open Source Project)","text":"准备条件你可能临时起意想要尝试，最好先确认一下自己的软硬件环境 内存16GB起步,编译会出现 fatal error: runtime: out of memory 磁盘200GB+ 如果你是要看源码，用不着下载 http://androidxref.com/ http://www.aospxref.com/ https://cs.android.com/ 本文采用的是清华源 https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/，你可以可以按原文里面的步骤 下载repo工具repo就是一个git脚本的集合，其实还是git公交，很多git命令可以直接套用。 1234mkdir ~/binPATH=~/bin:$PATHcurl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repo repo init 初始化 我没有通过初始包的方式下载，包含了自己不需要的，而且全部工程有点大。我们做一些精简。拉取指定的分支，如果需要特定的分支 去https://source.android.com/source/build-numbers.html#source-code-tags-and-builds 选择Tag repo init --depth=1 -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-11.0.0_r39 –depth=1 表示只下载最近版本的代码，只保留最近的commit版本。使用–depth 可以节省本地磁盘空间，加速下载，对于开发够用了 repo sync 下载repo sync -c -f --no-tags --no-clone-bundle -j`nproc` -c 或者–current-branch表示只拉取当前分支代码. –no-tags 不拉取tags –no-clone-bundle 不使用clone.bundle -f 如果sync失败，继续同步 –force-sync 如果文件目录有差异，强制覆盖掉 -j 参数指定同时运行多少个job, 看具体的源是否支持足够的数量 执行玩会出现success的log，大概80GB左右，出错可重新执行。 如果出现如下的错误，上面的命令追加重新跑一次 123error: Unable to fully sync the tree.error: Downloading network changes failed.Try re-running with \"-j1 --fail-fast\" to exit at the first error 常用的repo命令 创建分支 1repo start --all 自定义分支名 删除分支 1repo abandon 已创建的本地分支名 切换分支 12repo init -b xxx --depth=1repo sync -c -f repo回滚 123repo sync -drepo forall -c 'git reset --hard' # Remove all working directory (and staged) changes.repo forall -c 'git clean -f -d' # Clean untracked files 查看当前项目分支 12repo branchrepo status 可以看到每一个git 工程 12345678910111213141516171819202122232425262728project art/ branch android_11_study_ckproject bionic/ branch android_11_study_ckproject bootable/recovery/ branch android_11_study_ckproject build/blueprint/ branch android_11_study_ckproject build/make/ branch android_11_study_ckproject build/soong/ branch android_11_study_ckproject compatibility/cdd/ branch android_11_study_ckproject cts/ branch android_11_study_ckproject dalvik/ branch android_11_study_ckproject developers/build/ branch android_11_study_ckproject developers/demos/ branch android_11_study_ckproject developers/samples/android/ branch android_11_study_ckproject development/ branch android_11_study_ckproject device/amlogic/yukawa/ branch android_11_study_ckproject device/amlogic/yukawa-kernel/ branch android_11_study_ckproject device/common/ branch android_11_study_ckproject device/generic/arm64/ branch android_11_study_ckproject device/generic/armv7-a-neon/ branch android_11_study_ckproject device/generic/art/ branch android_11_study_ckproject device/generic/car/ branch android_11_study_ckproject device/generic/common/ branch android_11_study_ckproject device/generic/goldfish/ branch android_11_study_ckproject device/generic/goldfish-opengl/ branch android_11_study_ckproject device/generic/mini-emulator-arm64/ branch android_11_study_ckproject device/generic/mini-emulator-armv7-a-neon/ branch android_11_study_ckproject device/generic/mini-emulator-x86/ branch android_11_study_ckproject device/generic/mini-emulator-x86_64/ branch android_11_study_ckproject device/generic/opengl-transport/ branch android_11_study_ck AOSP 目录简介目录结构https://elinux.org/Master-android 123456789101112131415161718192021222324252627./├── art├── bionic├── bootable├── build├── compatibility├── cts├── dalvik├── developers├── development├── device├── external├── frameworks├── hardware├── kernel├── libcore├── libnativehelper├── out├── packages├── pdk├── platform_testing├── prebuilts├── sdk├── system├── test├── toolchain└── tools abi（Application Binary Interface） https://developer.android.com/ndk/guides/abis art（Android runtime） https://source.android.com/devices/tech/dalvik/ bionic 一些基础库 libm（library math） libc（library c）：在 glibc 的基础上做了裁剪与修改的，为了规避GNU GPL等商业行为的约束 libstdc++（library standard C++）：并非完整版，只做了简单支持linker：装载链接相关库 bootablebootable 下仅包含 recovery 此文件夹，其实就是启动 Android recovery 模式相关的代码 buildAndroid Build 系统，用来定制各种编译规则。主要由 makefile 组成。比如在编译时要执行的 source build/envsetup.sh 就位于 build 下 cts（Compatibility Test Suite)一个自动化测试工具 CTS dalvikdalvik 虚拟机 , https://source.android.com/devices/tech/dalvik/ developers一些可运行的 Android 示例项目，可以单独拉出来运行 device包含不同品牌手机独有的设备信息 external一些开源的第三方组件，这里仅列了一下大家比较熟悉的如glide、junit、okhttp、sqlite 等 frameworksAndroid 中大家熟悉的 Frameworks，应用程序框架层 12345678910111213141516avbasecompiledata-bindingexmffminikinmlmultidexnativeoptrssupportvolleywebviewwilhelm Android support 包 com.android.support:support-v4、v7 等都位于 frameworks/support 文件夹下 webview 就位于 frameworks/webview 文件夹下 各种 Service，比如ActivityManagerService、SystemService、WindowManagerService、InputManagerService等就位于 frameworks/base 文件夹下 keystore、opengl 等也位于 frameworks/base 文件夹下 hardware包含了 android HAL（硬件抽象层）相关代码。硬件抽象层介于 Linux内核驱动程序与 Android 系统之间。对 Linux 驱动进行了封装，使操作系统级别可以忽略底层实现的细节。 libcore 一些核心库 libnativehelperJNI 相关的一些类 ndk原生开发工具包 out编译完后输出的所有相关文件都位于此文件夹下，包括生成的各种 img 就位于 out/target/product/hammerhead 下 packages各种内置的 apk、ContentProvider、输入法、壁纸等 蓝牙、浏览器、相机、邮件、音乐、NFC 等都位于 packages/apps 下面 MediaProvider、DownloadProvider、MmsProvider等都位于 packages/providers 下 壁纸相关位于 packages/wallpapers 下 pdk（Platform Development Kit）平台开发套件，仅包含了一些供硬件抽象层开发使用的必要组件，供一些 OEM 厂商用来适配及测试最新的Android 系统，加快第三方厂商的更新速度。加快OEM厂商的update速度 prebuilts一些预构建成二进制的库 prebuiltshttps://developer.android.com/ndk/guides/prebuilts systemAndroid 的部分系统源码及一些工具，主要是在各种 java 启动程序起来前的部分。工具比如 adb、fastboot、keystore 等，其他如 mkbootimg、init 进程等 vendor包含不同供应商的私有的二进制库 参考 https://blog.csdn.net/counsellor/article/details/86591081 https://ressrc.com/2018/11/19/android-source-directory-structure-analysis/","link":"/2021/07/17/Android/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BDaosp/"},{"title":"Android开发工具推荐","text":"自己在平时工作中发现的一些不错的工具，记录下，方便在切换外部环境的时候，快速找回持续更新 AS 插件 SaveAction可以在保存的时候，自动格式化自己修改过的代码，可以自动去掉多余的import Git Tool Box快速直接显示git balme CodeLocator https://github.com/bytedance/CodeLocator 展示当前的View视图 展示当前的Activity信息 展示当前所有Fragment的信息 展示自定义的App运行时信息 展示当前应用的文件信息 实时编辑View的状态, 如可见性, 文本内容等 定位当前响应触摸事件的View 获取当前View绑定的数据 获取当前View对应的绘制内容 跳转View的点击事件代码, findViewById, ViewHolder的代码位置 跳转View的xml布局文件 跳转Toast, Dialog的显示代码位置 跳转启动当前Activity的代码位置 展示应用支持的所有Schema信息 向应用发送指定Schema 定位项目内最新的Apk文件 apk文件支持右键安装 快速打开显示布局边界, 过渡绘制, 点按操作等 快速连接Charles代理 App工具 Topactivity可以查看当前打开的页面，包名称和页面名称，方便快速定位Activity 下载 topactivity.mp3 LibChecker 方便快速分享目标app使用了哪些原生库，可以跟踪学习一些开源项目，例如分析微信的so 下载 libchecker.mp3 Intet Intercept发送或接受一个Intet，可以分析和debug Intet 下载 intentintercept.mp3 ActivityManager分析目前app的Activity，并支持直接挑战目标页面 下载activitymanager.mp3","link":"/2021/12/11/Android/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"},{"title":"快速点击StartActivity引发的误会","text":"问题来源在A 跳到 B ，再跳到C的过程中，一定条件下发送广播，需要把B关掉，达到的效果就是 C直接返回A。但是现在出现一个Bug就是C返回的时候，还是B。当时没有打印onCreate的日志，只发现B在前面finish了，居然又在后面onResume了，这显然违反科学。当时想就算B启动了多个，B也都在onCreate的时候注册了广播，都应该可以收到广播的。后面怀疑是手滑不小心点击了2次，或是系统突然响应过慢，点击了多次，造成创建了多个实例，所以我直接通过for循环快速模拟这种情况。 问题分析 模拟复现问题123for (int i = 0; i &lt; 4; i++) { startActivity(new Intent(MainActivity.this, Main2Activity.class));} 首先查看 activity栈 通过db shell dumpsys activity activities 查看 activity栈的详细信息 过滤了我们只关心的信息 12345678910111213141516* Hist #4: ActivityRecord{6a9b44e u0 com.test/.Main2Activity t36} state=RESUMED stopped=false delayedResume=false finishing=false * Hist #3: ActivityRecord{d603f13 u0 com.test/.Main2Activity t36} state=INITIALIZING stopped=false delayedResume=false finishing=false * Hist #2: ActivityRecord{ec9aee4 u0 com.test/.Main2Activity t36} state=INITIALIZING stopped=false delayedResume=false finishing=false * Hist #1: ActivityRecord{aea6311 u0 com.test/.Main2Activity t36} state=INITIALIZING stopped=false delayedResume=false finishing=false * Hist #0: ActivityRecord{ff269a8 u0 com.test/.MainActivity t36} state=STOPPED stopped=true delayedResume=false finishing=false Running activities (most recent first): TaskRecord{561d198 #36 A=com.test U=0 StackId=11 sz=5} Run #1: ActivityRecord{6a9b44e u0 com.test/.Main2Activity t36} Run #0: ActivityRecord{ff269a8 u0 com.test/.MainActivity t36} mResumedActivity: ActivityRecord{6a9b44e u0 com.test/.Main2Activity t36} state=INITIALIZING ？？我们可以看到创建了4个ActivityRecord，这个是符合预期的，前面的3个ActivityRecord状态还是INITIALIZING，就最后一个ActivityRecord走到了RESUMED。发现在这种情况下面，点击返回的时候，state=INITIALIZING 的Activity才走了onCreate。 疑惑？ 难道前面的 ActivityRecord 不应该都是 state=STOPPED 吗？ 怀疑点，所有的Activity的生命周期方法都是AMS来回调的，都会在我们的主线程消息里面处理 是不是AMS反应太慢？反正就是AMS的回到消息没有发过来？ 消息发过来了，我们还没有处理 基于上面的假设我们，我们可以dump一下消息 dump message 查看主线程的的Looper里的MessageQueue里面的持有的消息 123456789 for (int i = 0; i &lt; 4; i++) { Log.i(TAG, \"startActivity: click -------------------\"); startActivity(new Intent(MainActivity.this, Main2Activity.class)); dump(); }public static void dump() { Looper.getMainLooper().dump(new LogPrinter(Log.DEBUG, TAG), \"PREFIX\");} 1234567891011121314151617181920212223242526272829303132333435363738394041// 第一次立马点击的时候，就收到了一个 ClientTransaction 消息 3.609 I/MainActivity: startActivity: click ------------------- 3.670 Looper (main, tid 2) {833b991} 3.670 Message 0: { when=-67ms callback=android.view.View$UnsetPressedState target=android.view.ViewRootImpl$ViewRootHandler } 3.671 Message 1: { when=-29ms what=159 obj=android.app.servertransaction.ClientTransaction@efd342 target=android.app.ActivityThread$H } 3.671 (Total messages: 2, polling=false, quitting=false) //第二次点击的时候，并没有收到消息，可以看到消息没有变化 3.671 I/MainActivity: startActivity: click ------------------- 3.721 Looper (main, tid 2) {833b991} 3.721 Message 0: { when=-118ms callback=android.view.View$UnsetPressedState target=android.view.ViewRootImpl$ViewRootHandler } 3.721 Message 1: { when=-80ms what=159 obj=android.app.servertransaction.ClientTransaction@efd342 target=android.app.ActivityThread$H } 3.721 (Total messages: 2, polling=false, quitting=false) //第三次点击的时候，并没有收到消息，可以看到消息没有变化 3.721 I/MainActivity: startActivity: click ------------------- 3.760 Looper (main, tid 2) {833b991} 3.760 Message 0: { when=-157ms callback=android.view.View$UnsetPressedState target=android.view.ViewRootImpl$ViewRootHandler } 3.761 Message 1: { when=-119ms what=159 obj=android.app.servertransaction.ClientTransaction@efd342 target=android.app.ActivityThread$H } 3.761 (Total messages: 2, polling=false, quitting=false) //第四次点击的时候，并没有收到消息，可以看到消息没有变化 3.761 I/MainActivity: startActivity: click ------------------- 3.797 Looper (main, tid 2) {833b991} 3.797 Message 0: { when=-194ms callback=android.view.View$UnsetPressedState target=android.view.ViewRootImpl$ViewRootHandler } 3.797 Message 1: { when=-156ms what=159 obj=android.app.servertransaction.ClientTransaction@efd342 target=android.app.ActivityThread$H } 3.797 (Total messages: 2, polling=false, quitting=false) //到这里主线程才空出手来，去处理后面的消息 //这个就是这个onPause消息处理 3.815 I/MainActivity: onPause: 3.815 Looper (main, tid 2) {833b991} 3.815 Message 0: { when=-15ms callback=android.view.Choreographer$FrameDisplayEventReceiver target=android.view.Choreographer$FrameHandler } 3.816 (Total messages: 1, polling=false, quitting=false) 4.808 I/MainActivity: onStop: 我们确实只收到了一个 onPause消息，为什么？那就需要找下大哥AMS问下了 源码debug，向AMS定位问题 当AMS收到startActivity之后，会new一个ActivityRecord,然后后面需要把当前Resumed状态的Activity，onPause掉，所以我们可以直接定位发送Pause消息的地方。 com.android.server.am.ActivityStack#startPausingLocked 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, ActivityRecord resuming, boolean pauseImmediately) { //第一次进来mPausingActivity是null，应用没有暂停就没有所谓的mPausingActivity if (mPausingActivity != null) { ---- } //第二次进来，如果 mResumedActivity = null 。这里直接return了。就是Trying to pause when nothing is resumed //mResumedActivity 就是 将要启动的activity com.test/.Main2Activity ActivityRecord prev = mResumedActivity; if (prev == null) { if (resuming == null) { Slog.wtf(TAG, \"Trying to pause when nothing is resumed\"); mStackSupervisor.resumeFocusedStackTopActivityLocked(); } return false; } if (prev == resuming) { Slog.wtf(TAG, \"Trying to pause activity that is in process of being resumed\"); return false; } // prev 就是将要暂停的 之前的 com.test/.MainActivity mPausingActivity = prev; mLastPausedActivity = prev; mLastNoHistoryActivity = (prev.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NO_HISTORY) != 0 || (prev.info.flags &amp; ActivityInfo.FLAG_NO_HISTORY) != 0 ? prev : null; // 设置状态PAUSING android 9在这里面做了 mResumedActivity = null, 和网上以前的博客的不一样 // 后面调用到了onActivityStateChanged prev.setState(PAUSING, \"startPausingLocked\"); prev.getTask().touchActiveTime(); clearLaunchTime(prev); mStackSupervisor.getLaunchTimeTracker().stopFullyDrawnTraceIfNeeded(getWindowingMode()); mService.updateCpuStats(); //调用进程不为null，且调用进程的ApplicationThread不为null if (prev.app != null &amp;&amp; prev.app.thread != null) { if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, \"Enqueueing pending pause: \" + prev); try { // 这里发送了PauseActivityItem //通过调用进程的ApplicationThread通知调用进程schedulePauseActivity方法 //那么在 onActivityStateChanged 之内，只会走一次 mService.getLifecycleManager().scheduleTransaction(prev.app.thread, prev.appToken, PauseActivityItem.obtain(prev.finishing, userLeaving, prev.configChangeFlags, pauseImmediately)); } catch (Exception e) { // Ignore exception, if process died other code will cleanup. Slog.w(TAG, \"Exception thrown during pause\", e); mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; } } else { mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; }} com.android.server.am.ActivityStack#onActivityStateChanged 123456789void onActivityStateChanged(ActivityRecord record, ActivityState state, String reason) { //之前的Resumed的ActivityRecord 的 状态改变成新的，就是 state = PAUSING，reason = startPausingLocked //这里 setResumedActivity = null if (record == mResumedActivity &amp;&amp; state != RESUMED) { setResumedActivity(null, reason + \" - onActivityStateChanged\"); } ... } 豁然开朗 onPause 肯定和 ResumedActivity 相关，没有ResumedActivity ，自然就不需要onPause。所以在短时间里面，重复进入startPausingLocked就会存在一个状态，也就是 mResumedActivity= null。然后这个startPausingLocked方法提前return了，根本没有发送scheduleTransaction-&gt;PauseActivityItem ,所以短时时间里面只发送了一次，也就是下次的mResumedActivity的setState还没调用的之前。 点击事件,所有的startActivity事件都是在 主线程里面执行的 就算在这个for循环里面的这段时间里面收到了AMS发过来的ClientTransaction,也不能立即去执行 第一次启动的activityAMS抛出了onPause的Message，而后面没有抛出 等这个for循环走完之后，再去处理ClientTransaction 消息，去执行当前activity的onPause回调方法，是最后回一个消息给AMS AMS收到消息之后，从TaskRecord的栈顶取出ActivityRecord，执行它的生命周期方法，比如onCreate 这样我们页面展示的就是最后一次的Activity 当你留够了时间?1234for (int i = 0; i &lt; 4; i++) { startActivity(new Intent(MainActivity.this, Main2Activity.class)); Thread.sleep(1000); } 你会发现 之前的 state=INITIALIZING 全部变成了state=STOPPED ,也就是一般的页面跳转情况 123456789101112131415161718192021 * Hist #4: ActivityRecord{1b0bee6 u0 com.test/.Main2Activity t40} state=RESUMED stopped=false delayedResume=false finishing=false * Hist #3: ActivityRecord{77e243c u0 com.test/.Main2Activity t40} state=STOPPED stopped=true delayedResume=false finishing=false * Hist #2: ActivityRecord{3085c2 u0 com.test/.Main2Activity t40} state=STOPPED stopped=true delayedResume=false finishing=false * Hist #1: ActivityRecord{769b0f8 u0 com.test/.Main2Activity t40} state=STOPPED stopped=true delayedResume=false finishing=false * Hist #0: ActivityRecord{9808381 u0 com.test/.MainActivity t40} state=STOPPED stopped=true delayedResume=false finishing=falseRunning activities (most recent first): TaskRecord{557a2f7 #40 A=com.test U=0 StackId=15 sz=5} Run #4: ActivityRecord{1b0bee6 u0 com.test/.Main2Activity t40} Run #3: ActivityRecord{77e243c u0 com.test/.Main2Activity t40} Run #2: ActivityRecord{3085c2 u0 com.test/.Main2Activity t40} Run #1: ActivityRecord{769b0f8 u0 com.test/.Main2Activity t40} Run #0: ActivityRecord{9808381 u0 com.test/.MainActivity t40}mResumedActivity: ActivityRecord{1b0bee6 u0 com.test/.Main2Activity t40}mLastPausedActivity: ActivityRecord{77e243c u0 com.test/.Main2Activity t40} 而且你会发现主线程的消息队列里面已经收到了很多个生命周期的ClientTransaction回调消息，不再是之前的就只有1个了 123456789101112.535 Message 0: { when=-3s642ms what=159 obj=android.app.servertransaction.ClientTransaction@4962 target=android.app.ActivityThread$H }.539 Message 1: { when=-3s606ms what=159 obj=android.app.servertransaction.ClientTransaction@17b4bc5e target=android.app.ActivityThread$H }.540 Message 2: { when=-3s604ms what=6 target=android.view.ViewRootImpl$ViewRootHandler }.543 Message 3: { when=-3s123ms what=159 obj=android.app.servertransaction.ClientTransaction@efd342 target=android.app.ActivityThread$H }.543 Message 4: { when=-2s613ms what=159 obj=android.app.servertransaction.ClientTransaction@4962 target=android.app.ActivityThread$H }.543 Message 5: { when=-2s606ms what=159 obj=android.app.servertransaction.ClientTransaction@119702d7 target=android.app.ActivityThread$H }.543 Message 6: { when=-2s85ms what=159 obj=android.app.servertransaction.ClientTransaction@efd342 target=android.app.ActivityThread$H }.544 Message 7: { when=-1s573ms what=159 obj=android.app.servertransaction.ClientTransaction@4962 target=android.app.ActivityThread$H }.545 Message 8: { when=-1s567ms what=159 obj=android.app.servertransaction.ClientTransaction@a56cd5ac target=android.app.ActivityThread$H }.545 Message 9: { when=-1s44ms what=159 obj=android.app.servertransaction.ClientTransaction@efd342 target=android.app.ActivityThread$H }.546 Message 10: { when=-536ms what=159 obj=android.app.servertransaction.ClientTransaction@4962 target=android.app.ActivityThread$H }.546 Message 11: { when=-529ms what=159 obj=android.app.servertransaction.ClientTransaction@f1a0fa6d target=android.app.ActivityThread$H } 这样之前activity都是走了onCreate的流程了 总结 我之前以为情况 实际点击返回出现的情况 之前错误的理解将ActivityRecord 与 RunningActivity 一一对应了。 ActivityRecord对应的Activity 可能没有及时创建 返回上一个Activity,上一个Activity的状态可能是INITIALIZING OnPause onStop 附录 转载startActivity的流程图 (https://img-blog.csdn.net/20171121115636419?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXVuX2hlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)","link":"/2020/06/05/Android/%E5%BF%AB%E9%80%9F%E7%82%B9%E5%87%BBStartActivity%E5%BC%95%E5%8F%91%E7%9A%84%E8%AF%AF%E4%BC%9A/"},{"title":"怎么debug wechat-release.apk？","text":"debug是指在smail层面，类似字节码层面。 1.安装smailidea插件从本地安装，market里面搜索不到。https://bitbucket.org/JesusFreke/smali/downloads/ 2. 使用baksmail 反编译Apkjava -jar baksmail.jar d testapk.apk -o ./srcDir 3. 导入AS打开AS ,选择新建project 选择 new-&gt;import 选择 上面的srcDir，依次选择jdk，最后邮件标记跟目录为 Mark Director -&gt; Source root然后设置sdk，最后和测试手机的系统版本一致：项目目录–&gt;右键–&gt;Open ModuleSettings： 我们可以看到工程目录 4.AS 配置debug接下来配置：Run/Debug Configurations里面的配置文件：打开后我们点击上面的+符合，然后选择Remote，添加一个远程调试如下图：port 后面再说 6.安装运行APK 启动方式可以选择 开发者模式里面 等待应用调试 也可以选择 adb shell am start -D -S -W 包名/启动ACTICITY 例如 adb shell am start -D -S -W com.tencent.mm/com.tencent.mm.ui.LauncherUI 7.DEBUG获取port的2中方式 ，在AS里面设置这个port 使用 JDWP 首先通过 adb ps | grep 查看 这个apk的 pid 端口转发，把当前电脑的A端口 ，转发对接到手机的B端口。JDWP的端口默认就是PID，所以需要查看PID adb forward tcp:8080 jdwp:pid 使用DDMS 打开DDMS，遇到端口问题，先adb kill-server 和 adb start-server 重启一下adb 选择目标APK，点击 会出现 最后一列 会出现 8080/8700 ，就是要填8080,不是填8700 在AS 中点击 debug，DDMS 选中的进程 会出现绿色的bug图标 点击debug 熟悉的界面8 其它 确保app 是 debug enable的，若不是，可以 修改APK后重新签名打包 也可以给手机或模拟器编译一个debug的rom","link":"/2020/05/07/Android/%E6%80%8E%E4%B9%88debugrelase%E5%8C%85smail/"},{"title":"Java指令重排","text":"1234567891011121314151617181920212223public class Main{ static boolean mark = true; public static void main(String[] args) throws InterruptedException { run(); /*加上这句会怎么样？*/ //Thread.sleep(100); mrak = false; System.out.println(\"main end\"); } static void run(){ new Thread(new Runnable() { @Override public void run() { int i = 0; while (mark){ //这里具体要做什么也会影响到结果 i++; } } }).start(); }} 1.不加Thread.sleep(100)程序会正常结束，大多数情况下，在启动新线程的时候，主线程后面的会获得执行。 1234567public void run() { int i = 0; while (run){ System.out.println(\"new thread start\"); i++; } } 通过验证发现， System.out.println(“new thread start”) 并不会输出。 2.加Thread.sleep(100)奇怪的现象发生了。这时候，新开的线程不会结束。why？编译的过程有 其中中间代码是和平台无关的，编译器在中间代码后面可以进行一些和平台无关的代码优化，在目标代码生成的时候，编译器当然也可以根据目标平台支持的特性进行优化，常见的指令重排可以是CPU流水线优化，IO重排等。当然JVM也会对你写的代码进行一些优化，发生在编译阶段和运行阶段都有可能。 主要还是编译器以及CPU为了优化代码或者执行的效率而执行的优化操作；应用条件是单线程场景下，对于并发多线程场景下，指令重排会产生不确定的执行效果(原文链接https://blog.csdn.net/blueheart20/article/details/52117761[链接](https://blog.csdn.net/blueheart20/article/details/52117761)) 3 如何防止指令重排?volatile关键字可以保证变量的可见性，因为对volatile的操作都在Main Memory中，而Main Memory是被所有线程所共享的，这里的代价就是牺牲了性能，无法利用寄存器或Cache，因为它们都不是全局的，无法保证可见性，可能产生脏读。 volatile还有一个作用就是局部阻止重排序的发生，对volatile变量的操作指令都不会被重排序，因为如果重排序，又可能产生可见性问题。 在保证可见性方面，锁（包括显式锁、对象锁）以及对原子变量的读写都可以确保变量的可见性。但是实现方式略有不同，例如同步锁保证得到锁时从内存里重新读入数据刷新缓存，释放锁时将数据写回内存以保数据可见，而volatile变量干脆都是读写内存。(原文链接：https://blog.csdn.net/blueheart20/article/details/52117761[链接](https://blog.csdn.net/blueheart20/article/details/52117761)) 12// 在run方法里面进行跨对象访问。也会避免当前这个优化static volatile boolean run = true;","link":"/2019/09/27/Java/Java%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/"},{"title":"Java的多态方法的与静态与动态分派","text":"前言 多态：一个对象变量可以引用多个实际对象 动态绑定：程序运行自动选择调用那个对象的方法 1 先看C++ 1234567891011121314151617181920#include using namespace std;class Person{public:int x=1,y=1;void Show() { cout &lt;&lt; \"I am a Person \" &lt;&lt;x&lt;&lt;y&lt;&lt; endl;}};class Student:public Person{public:void Show() { cout &lt;&lt; \"I am a Student \" &lt;&lt;x&lt;&lt;y&lt;&lt; endl;}};int main(){ Student s0; Person p0=s0; p0.Show(); s0.Show(); return 0;} 运行结果 12I am a Person 11I am a Student 11 2.再看Java 123456789101112131415161718192021class Person{public void Show(){ System.out.println(\"I am a Person\");}}class Student extends Person{public void Show(){ System.out.println(\"I am a Student\");}}public class Main{public static void main(String arg[]){ Student s0=new Student(); Person p0=s0; p0.Show(); s0.Show();}} 运行结果 12I am a StudentI am a Student 3.分析原因Java与C的绑定不同。Java中只有final、static、private和构造方法是静态绑定的，其它所有方法都采用动态绑定，而C++只有虚函数进行的是动态绑定。所以在C++中，p0.Show()才用静态绑定的Show()，尽管指向的是Student。而Java则是动态绑定，因为有JVM，JVM会调用变量实际指向的对象的方法。p0实际是指向s0的，所以会调用s0的Show()。 从java的字节码角度出发，有5种调用指令 invokeinterface: 调用接口中的方法，实际上是在运行期决定实际实现该接口的哪一个对象 invokestatic 调用静态方法 invokespecial 调用实际的私有方法，构造方法 invokevirtual 调用虚方法 运行期间动态查找的过程 invokedynamic 动态调用 方法重载时一种静态类型，调用的时候就是声明的类型，编译时可以确定。 方法重写是一种动态类型，是实际调用的时候，才知道的。需要运行时确定。 虚拟机一定调用引用对象的”实际类“的最适合的方法。虚拟机预先为每一个类创建一个 方法表，在运行时，虚拟机会查这个表。首先适配实际类的方法，否则在超类中继续寻找，以此类推。 字节码带来的疑惑？ INVOKEVIRTUAL Person.Show ()V //—这里明明显示的是调用Person.Show怎么调用有到 Student.Show 123456789101112131415161718192021222324252627282930// access flags 0x9 public static main([Ljava/lang/String;)V L0 LINENUMBER 15 L0 NEW Student DUP INVOKESPECIAL Student.&lt;init&gt; ()V ASTORE 1 L1 LINENUMBER 16 L1 ALOAD 1 ASTORE 2 L2 LINENUMBER 17 L2 ALOAD 2 INVOKEVIRTUAL Person.Show ()V //---这里明明显示的是调用Person.Show怎么调用有到 Student.Show L3 LINENUMBER 18 L3 ALOAD 1 INVOKEVIRTUAL Student.Show ()V L4 LINENUMBER 19 L4 RETURN L5 LOCALVARIABLE arg [Ljava/lang/String; L0 L5 0 LOCALVARIABLE s0 LStudent; L1 L5 1 LOCALVARIABLE p0 LPerson; L2 L5 2 MAXSTACK = 2 MAXLOCALS = 3} 这个就涉及到原理INVOKEVIRTUAL了 INVOKEVIRTUAL 首先去找在操作数的栈顶的实际指向的那个对象的实际类型，寻找到描述和访问权限都符合，则直接返回这个方法的直接引用。 如果找不到，然后去找父类 再找不到，抛异常 这样依次去找会不会很慢？ JVM会优化，生成一个叫vtable的方法表。 通过vtable代替实际查找。","link":"/2019/05/31/Java/Java%E7%9A%84%E5%A4%9A%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8E%E9%9D%99%E6%80%81%E4%B8%8E%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/"},{"title":"Java查看对象的大小","text":"1.JOL 12345&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.9&lt;/version&gt; &lt;/dependency&gt; 123456//查看对象内部信息 print(ClassLayout.parseInstance(obj).toPrintable()); //查看对象外部信息 print(GraphLayout.parseInstance(obj).toPrintable()); //获取对象总大小 print(\"size : \" + GraphLayout.parseInstance(obj).totalSize()); 2. lucene提供的专门用于计算堆内存占用大小的工具类：RamUsageEstimator，maven坐标：12345&lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-core&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt; 常用的方法 123456789//计算指定对象及其引用树上的所有对象的综合大小，单位字节long RamUsageEstimator.sizeOf(Object obj)//计算指定对象本身在堆空间的大小，单位字节long RamUsageEstimator.shallowSizeOf(Object obj)//计算指定对象及其引用树上的所有对象的综合大小，返回可读的结果，如：2KBString RamUsageEstimator.humanSizeOf(Object obj) 12345public static void main(String[] args) { final byte[] sLock = new byte[0]; System.out.println(RamUsageEstimator.sizeOf(new Object())); System.out.println(RamUsageEstimator.sizeOf(sLock)); } 默认开启指针压缩 -XX:+UseCompressedOops 121616 关闭指针压缩 -XX:- UseCompressedOops 121624 简单好用，锁的话就用new Object() 3.关闭指针压缩为什么大了8个字节？大了4个字节，加上要内存对齐8个字节。1234567891011121314151617181920212223242526272829303132333435363738394041object----------------------------------------------查看对象内部信息java.lang.Object object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 00 1c c3 1c (00000000 00011100 11000011 00011100) (482548736) 12 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0)Instance size: 16 bytesSpace losses: 0 bytes internal + 0 bytes external = 0 bytes total查看对象外部信息java.lang.Object@aec6354d object externals: ADDRESS SIZE TYPE PATH VALUE 1288d8b18 16 java.lang.Object (object)获取对象总大小size : 16sLock----------------------------------------------查看对象内部信息[B object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) a8 07 c3 1c (10101000 00000111 11000011 00011100) (482543528) 12 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 16 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 20 4 (alignment/padding gap) 24 0 byte [B.&lt;elements&gt; N/AInstance size: 24 bytesSpace losses: 4 bytes internal + 0 bytes external = 4 bytes total查看对象外部信息[B@41975e01d object externals: ADDRESS SIZE TYPE PATH VALUE 1288d8b00 24 [B []获取对象总大小size : 24 开启指针压缩 1234567891011121314151617181920212223242526272829303132333435363738394041object----------------------------------------------查看对象内部信息java.lang.Object object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243) 12 4 (loss due to the next object alignment)Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total查看对象外部信息java.lang.Object@aec6354d object externals: ADDRESS SIZE TYPE PATH VALUE 76be9bd30 16 java.lang.Object (object)获取对象总大小size : 16sLock----------------------------------------------查看对象内部信息[B object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) f5 00 00 f8 (11110101 00000000 00000000 11111000) (-134217483) 12 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 16 0 byte [B.&lt;elements&gt; N/AInstance size: 16 bytesSpace losses: 0 bytes internal + 0 bytes external = 0 bytes total查看对象外部信息[B@41975e01d object externals: ADDRESS SIZE TYPE PATH VALUE 76be9bd20 16 [B []获取对象总大小size : 16Process finished with exit code 0 4. 为什么object header 会有 20 个字节呢？不管是否开启指针压缩，数组引用类型要多一个 4个字节的长度 的标记。 1Object object = new Object[0x0FFFFFFF]; 验证 12345678910111213object----------------------------------------------查看对象内部信息[Ljava.lang.Object; object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 38 cb 6c 1c (00111000 11001011 01101100 00011100) (476891960) 12 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 16 4 (object header) ff ff ff 0f (11111111 11111111 11111111 00001111) (268435455) 20 4 (alignment/padding gap) 24 2147483640 java.lang.Object Object;.&lt;elements&gt; N/AInstance size: 2147483664 bytesSpace losses: 4 bytes internal + 0 bytes external = 4 bytes total 那我要是直接声明一个 长整型 [long]的呢？对不起，不支持！ 为什么？？？ Java 中数组的最大长度是多少呢？看一下它的length属性就可以了。length属性是32位的有符号整数，它的最大值是2的31次幂，就是2G。为何有这个限制呢？为什么length的属性不是long型呢？我们假设一下，如果它是long型的，那么它的最大长度是2的63次幂。内存永远也不会有那么大吧。即使是字节数组长度是int的，最大长都达到2GB. 由此想到了String，这个家伙底层也是基于数组的，是一个字符数组。字符是16位的基本类型,一个String的最大长度是多少呢？就是字符数组的最大长度也是2G，占用内存是4GB。 从JVM的角度来解释：创建数组的字节码是anewarray和newarray，操作数栈的字宽是32位，而这两个字节码的参数都是一个字长，所以无法接受long型的长度参数。不知道这样解释是否很牵强。","link":"/2019/12/14/Java/Java%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F/"},{"title":"Mac下怎么用Clion debug openJdk8?","text":"还记得前面编译还了的java - v 有个错误，我们来试一下用Clion debug一下 1.打开Clion ，导入项目打开 clion，选择 File-&gt;ImportProject，选择到 ../openjdk-8/hotspot 目录。 2.配置Run导入成功以后，会出现一个默认的Run，修改掉Run 里面的配置，去掉build，我们不需要build。Target 不用变，Executable需要改成我们自己编译的./bin/java。clion 导入源码之后遇到头文件找不到的问题，可以在 CMakeLists.txt 里面添加一些根路径， 可以在CMakeLists.txt里面添加，还有不存在的头文件，可以直接添加到src/share/vm/precompiled/precompiled.hpp，从里面找 CMakeLists 1234include_directories(./src/share/vm)include_directories(./src/cpu/x86/vm)include_directories(./src/share/vm/precompiled)include_directories(./src/share/vm/utilities) src/share/vm/precompiled/precompiled.hpp 12345678# include &lt;cstdlib&gt;# include &lt;cstdint&gt;# include &lt;cstring&gt;# include \"register_x86.hpp\"# include \"assembler_x86.hpp\"# include \"globalDefinitions.hpp\"# include \"globalDefinitions_x86.hpp\"# include \"assembler_x86.hpp\" 3.选择断点，点击debug 先打开core dump 查看调用栈,确定断点123456789101112Stack: [0x00007000043c8000,0x00007000044c8000], sp=0x00007000044c7c70, free space=1023k Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code) V [libjvm.dylib+0xa2e268] PerfData::~PerfData()+0x8 V [libjvm.dylib+0xa2ee3d] PerfDataManager::destroy()+0x6d V [libjvm.dylib+0xa313ed] perfMemory_exit()+0x3d V [libjvm.dylib+0x6718cd] exit_globals()+0x1d V [libjvm.dylib+0xb744bc] Threads::destroy_vm()+0x19c V [libjvm.dylib+0x740e62] jni_DestroyJavaVM+0x182 C [java+0x3abc] JavaMain+0x28c C [libsystem_pthread.dylib+0x3661] _pthread_body+0x154 C [libsystem_pthread.dylib+0x350d] _pthread_body+0x0 C [libsystem_pthread.dylib+0x2bf9] thread_start+0xd 刚开始可能会出现 可以在点击 LLDB，输入 process handle SIGSEGV --stop=false 即可，这里告诉编译器忽略错误 然后点击resume，绿色的三角 命中断点，就后面的正常debug 可看到这个函数执行都这里就是crash了，所以之前的编译错误，可以忽略这里的错误达到正常结束的目的。 这是什么错Exception: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)？","link":"/2019/05/13/Java/Mac%E4%B8%8B%E6%80%8E%E4%B9%88%E7%94%A8CliondebugJVM/"},{"title":"Java分析Object Header 信息","text":"1.头信息123class AAA{ private int number;} 1234567891011------------after invoke hascode()-----------------AAA object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 bc 37 0b (00000001 10111100 00110111 00001011) (188201985) 4 4 (object header) 7e 00 00 00 (01111110 00000000 00000000 00000000) (126) 8 4 (object header) a8 35 85 1c (10101000 00110101 10000101 00011100) (478492072) 12 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 16 4 int AAA.number 0 20 4 (loss due to the next object alignment)Instance size: 24 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total 可以看到在 64位机上，关闭压缩。object header 占16 字节。以4个字节方式对齐。开启压缩，实测占12字节。 HotSpot 虚拟机的对象头包括两部分信息：Mark Word（标记字段）和 Klass Pointer（类型指针） 2.MarkWordMark Word 用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。JVM 对象头一般占用两个机器码，在 32-bit JVM 上占用 64bit， 在 64-bit JVM 上占用 128bit 即 16 bytes（暂不考虑开启压缩指针的场景）。另外，如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中无法确定数组的大小。对象需要存储的运行时数据很多，其实已经超出了32、64位 Bitmap 结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如在 32 位的HotSpot 虚拟机中对象未被锁定的状态下，Mark Word 的 32个Bits 空间中的 25Bits 用于存储对象哈希码（HashCode），4Bits 用于存储对象分代年龄，2Bits 用于存储锁标志位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示。 原文链接：https://blog.csdn.net/wenniuwuren/article/details/50939410 来自 https://gist.github.com/arturmkrtchyan/43d6135e8a15798cc46c 64位机。关闭压缩 头部信息 各个字段占位123456789101112131415|------------------------------------------------------------------------------------------------------------|--------------------|| Object Header (128 bits) | State ||------------------------------------------------------------------------------|-----------------------------|--------------------|| Mark Word (64 bits) | Klass Word (64 bits) | ||------------------------------------------------------------------------------|-----------------------------|--------------------|| unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 | OOP to metadata object | Normal ||------------------------------------------------------------------------------|-----------------------------|--------------------|| thread:54 | epoch:2 | unused:1 | age:4 | biased_lock:1 | lock:2 | OOP to metadata object | Biased ||------------------------------------------------------------------------------|-----------------------------|--------------------|| ptr_to_lock_record:62 | lock:2 | OOP to metadata object | Lightweight Locked ||------------------------------------------------------------------------------|-----------------------------|--------------------|| ptr_to_heavyweight_monitor:62 | lock:2 | OOP to metadata object | Heavyweight Locked ||------------------------------------------------------------------------------|-----------------------------|--------------------|| | lock:2 | OOP to metadata object | Marked for GC ||------------------------------------------------------------------------------|-----------------------------|--------------------| 64位机。开启压缩 头部信息 各个字段占位123456789101112131415|--------------------------------------------------------------------------------------------------------------|--------------------|| Object Header (96 bits) | State ||--------------------------------------------------------------------------------|-----------------------------|--------------------|| Mark Word (64 bits) | Klass Word (32 bits) | ||--------------------------------------------------------------------------------|-----------------------------|--------------------|| unused:25 | identity_hashcode:31 | cms_free:1 | age:4 | biased_lock:1 | lock:2 | OOP to metadata object | Normal ||--------------------------------------------------------------------------------|-----------------------------|--------------------|| thread:54 | epoch:2 | cms_free:1 | age:4 | biased_lock:1 | lock:2 | OOP to metadata object | Biased ||--------------------------------------------------------------------------------|-----------------------------|--------------------|| ptr_to_lock_record | lock:2 | OOP to metadata object | Lightweight Locked ||--------------------------------------------------------------------------------|-----------------------------|--------------------|| ptr_to_heavyweight_monitor | lock:2 | OOP to metadata object | Heavyweight Locked ||--------------------------------------------------------------------------------|-----------------------------|--------------------|| | lock:2 | OOP to metadata object | Marked for GC ||--------------------------------------------------------------------------------|-----------------------------|--------------------| 3.Klass Pointer，即是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 4.通过JOL 验证 头部字段信息 。并分析字段信息。12345601 bc 37 0b (00000001 10111100 00110111 00001011) (188201985)7e 00 00 00 (01111110 00000000 00000000 00000000) (126)a8 35 85 1c (10101000 00110101 10000101 00011100) (478492072)00 00 00 00 (00000000 00000000 00000000 00000000) (0) 进一步拆分Mark Word (64 bits) 。对比各个字段。 unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 由于大小端的关系，打印 hashcode可以看出是倒序的。 12 unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:200000001 10111100 00110111 0|00010110 11111100 00000000 0000000 | 0 |0000 |0 | 00 看到age是4个bit，好像也可以解释为什么年龄最高为15了。 😂","link":"/2019/10/11/Java/ObjectHeader/"},{"title":"Mac下编译OpenJdk8","text":"1.下载和解压源码 本地环境 OS version 10.13.6 网上也有说通过mercurial下载，太慢了，去http://jdk.java.net/下载源码包然后解压。 2.配置环境本地需要一个可用的JDK，直接java -verison可用即可，最好版本低于编译版本 2.1 安装依赖 和配置环境 缺少什么就尝试brew install 一下 主要 breaw install binutils freetype 123456If you need to have binutils first in your PATH run: echo 'export PATH=\"/usr/local/opt/binutils/bin:$PATH\"' &gt;&gt; ~/.zshrcFor compilers to find binutils you may need to set: export LDFLAGS=\"-L/usr/local/opt/binutils/lib\" export CPPFLAGS=\"-I/usr/local/opt/binutils/include\" 设置以下环境变量，new一个env.sh12345678910111213141516171819202122232425262728293031323334353637383940# 设定语言选项，必须设置export LANG=C# Mac平台，C编译器不再是GCC，是clangexport CC=clangexport CXX=clang++# 跳过clang的一些严格的语法检查，不然会将N多的警告作为Errorexport COMPILER_WARNINGS_FATAL=false# 链接时使用的参数export LFLAGS='-Xlinker -lstdc++'# 是否使用clangexport USE_CLANG=true# 使用64位数据模型export LP64=1# 告诉编译平台是64位，不然会按32位来编译export ARCH_DATA_MODEL=64# 允许自动下载依赖export ALLOW_DOWNLOADS=true# 并行编译的线程数，编译时间长，为了不影响其他工作，我选择为2export HOTSPOT_BUILD_JOBS=2# 是否跳过与先前版本的比较export SKIP_COMPARE_IMAGES=true# 是否使用预编译头文件，加快编译速度export USE_PRECOMPILED_HEADER=true# 是否使用增量编译export INCREMENTAL_BUILD=true# 编译内容export BUILD_LANGTOOLS=trueexport BUILD_JAXP=trueexport BUILD_JAXWS=trueexport BUILD_CORBA=trueexport BUILD_HOTSPOT=trueexport BUILD_JDK=true# 编译版本export SKIP_DEBUG_BUILD=trueexport SKIP_FASTDEBUG_BUILD=falseexport DEBUG_NAME=debug# 避开javaws和浏览器Java插件之类的部分的buildexport BUILD_DEPLOY=falseexport BUILD_INSTALL=falseunset JAVA_HOME 2.2 为什么区分release和debug版本？首先编译release版本比较简单，遇到的错误会比较少。我前面编译releae的时候，也比较顺利，后面编译debug版本出了很多问题，有些只在debug下才会有。我见有的博客里面描述的问题，我也没有遇到，所以遇到具体问题，具体环境分析，看到错误，尽量往前看第一个error，后面的是由前面的error引起的，搜索关键的error。 2.3 配置debug版本 的configure1./configure --with-freetype-include=/usr/local/include/freetype2 --with-freetype-lib=/usr/local/lib/ --with-target-bits=64 --with-debug-level=slowdebug --enable-debug-symbols ZIP_DEBUGINFO_FILES=0 OBJCOPY=gobjcopy with-target-bits=64 ：指定生成64位jdk； with-debug-level=slowdebug：编译时debug的级别，有release, fastdebug, slowdebug 三种级别； enable-debug-symbols ZIP_DEBUGINFO_FILES=0：生成调试的符号信息，并且不压缩 2.4 配置release版本 的configure1./configure --with-freetype-include=/usr/local/include/freetype2 --with-freetype-lib=/usr/local/lib/ configure成功的信息123456789101112131415161718Configuration summary:* Debug level: release* JDK variant: normal* JVM variants: server* OpenJDK target: OS: macosx, CPU architecture: x86, address length: 64Tools summary:* Boot JDK: java version \"1.8.0_211\" Java(TM) SE Runtime Environment (build 1.8.0_211-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode) (at /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home)* C Compiler: Apple LLVM version (clang-1000.10.44.4) version 10.0.0 (clang-1000.10.44.4) (at /usr/bin/clang)* C++ Compiler: version (at /usr/bin/g++)Build performance summary:* Cores to use: 4* Memory limit: 8192 MB* ccache status: not installed (consider installing)Build performance tip: ccache gives a tremendous speedup for C++ recompilations.You do not have ccache installed. Try installing it. 2.4 configure 可能遇到的错误12345678checking for clang... /usr/bin/clangconfigure: Resolving CC (as /usr/bin/clang) failed, using /usr/bin/clang directly.checking resolved symbolic links for CC... /usr/bin/clangchecking if CC is disguised ccache... no, keeping CCconfigure: The C compiler (located as /usr/bin/clang) does not seem to be the required GCC compiler.configure: The result from running with --version was: \"Apple LLVM version 10.0.0 (clang-1000.10.44.4)\"configure: error: GCC compiler is required. Try setting --with-tools-dir.configure exiting with result code 1 修改vim common/autoconf/generated-configure.sh中的2个地方，把判断去掉1234567# if test $? -ne 0; then# { $as_echo \"$as_me:${as_lineno-$LINENO}: The $COMPILER_NAME compiler (located as $COMPILER) does not seem to be the required GCC compiler.\" &gt;&amp;5# $as_echo \"$as_me: The $COMPILER_NAME compiler (located as $COMPILER) does not seem to be the required GCC compiler.\" &gt;&amp;6;}# { $as_echo \"$as_me:${as_lineno-$LINENO}: The result from running with --version was: \\\"$COMPILER_VERSION_TEST\\\"\" &gt;&amp;5# $as_echo \"$as_me: The result from running with --version was: \\\"$COMPILER_VERSION_TEST\\\"\" &gt;&amp;6;}# as_fn_error $? \"GCC compiler is required. Try setting --with-tools-dir.\" \"$LINENO\" 5# fi 3.编译可能遇到的错误 最常见的就是编译器办版本和代码的历史原因，语法格式不支持了，常见的做法是修改代码，或升降编译器。看报错的具体文件路径和行数 若报下面的错替换 为 Universe::narrow_oop_base() != NULL 12345 if (Universe::narrow_oop_base()&gt;0) { // Implies UseCompressedOops. ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~1 error generated.make[6]: *** [lcm.o] Error 1make[6]: *** Waiting for unfinished jobs.... 若报下面类似的错误 替换语法 if (base()!=NULL),保存,重新 make 123456789 if (base()&gt;0) { ~~~~~~^~1 error generated.make[6]: *** [virtualspace.o] Error 1make[6]: *** Waiting for unfinished jobs....make[5]: *** [the_vm] Error 2make[4]: *** [product] Error 2make[3]: *** [generic_build2] Error 2make[2]: *** [product] Error 2 最后可能遇到找不到 x86_64 符号 123456Undefined symbols for architecture x86_64: \"_attachCurrentThread\", referenced from: +[ThreadUtilities getJNIEnv] in ThreadUtilities.o +[ThreadUtilities getJNIEnvUncached] in ThreadUtilities.old: symbol(s) not found for architecture x86_64clang: error: linker command failed with exit code 1 (use -v to see invocation) 解决办法： 12345vi ./jdk/src/macosx/native/sun/osxapp/ThreadUtilities.m然后把inline void attachCurrentThread(void** env) {改为static inline void attachCurrentThread(void** env) { 4.编译成功12345678910----- Build times -------Start 2019-05-11 19:58:39End 2019-05-11 20:02:5900:00:16 corba00:01:20 hotspot00:00:10 jaxp00:00:15 jaxws00:02:00 jdk00:00:18 langtools00:04:20 TOTAL 到build目录下检查版本./java -version 123openjdk version \"1.8.0-internal-debug\"OpenJDK Runtime Environment (build 1.8.0-internal-debug-kenchan_2019_05_11_19_58-b00)OpenJDK 64-Bit Server VM (build 25.40-b25-debug, mixed mode) 如果检查版本，你恰好也遇到的了运行时错误 可见 https://bugs.openjdk.java.net/browse/JDK-8204325 12345678910111213141516171819202122232425openjdk version \"1.8.0-internal-debug\"OpenJDK Runtime Environment (build 1.8.0-internal-debug-kenchan_2019_05_11_19_58-b00)OpenJDK 64-Bit Server VM (build 25.40-b25-debug, mixed mode)## A fatal error has been detected by the Java Runtime Environment:## SIGILL (0x4) at pc=0x000000010f42e268, pid=67347, tid=8451## JRE version: OpenJDK Runtime Environment (8.0) (build 1.8.0-internal-debug-kenchan_2019_05_11_19_58-b00)# Java VM: OpenJDK 64-Bit Server VM (25.40-b25-debug mixed mode bsd-amd64 compressed oops)# Problematic frame:# V [libjvm.dylib+0xa2e268] PerfData::~PerfData()+0x8## Failed to write core dump. Core dumps have been disabled. To enable core dumping, try \"ulimit -c unlimited\" before starting Java again## An error report file with more information is saved as:# /Users/kenchan/Downloads/openjdk/build/macosx-x86_64-normal-server-slowdebug/jdk/bin/hs_err_pid67347.log## If you would like to submit a bug report, please visit:# http://bugreport.java.com/bugreport/crash.jsp#[error occurred during error reporting , id 0x4][1] 67347 abort ./java -version 解决办法 参考了https://stackoverflow.com/questions/50678467/building-openjdk-9-on-mac-os/54954805#54954805 修改 hotspot/src/share/vm/runtime /perfMemory.cpp 123// if (SafepointSynchronize::is_at_safepoint() &amp;&amp; !StatSampler::is_active()) {// PerfDataManager::destroy();// } 这个明显是去掉了内存回收，可能导致内存泄漏，不过我们是本地测试学习，先忽略这个错误。 修改 hotspot/src/share/vm/runtime/perfData.cpp PerfDataManager::destroy() 函数123456789101112131415161718void PerfDataManager::destroy() {if (_all == NULL) // destroy already called, or initialization never happened return;for (int index = 0; index &lt; _all-&gt;length(); index++) { PerfData* p = _all-&gt;at(index); delete p;//注释掉我}delete(_all);delete(_sampled);delete(_constants);_all = NULL;_sampled = NULL;_constants = NULL;} 怎么找到这个错的呢？请看 ？Mac下怎么用Clion debug openJdk8? 5.参考 https://github.com/johnwatsondev/johnwatsondev.github.io/issues/2 https://blog.csdn.net/lizhengjava/article/details/105629780 https://stackoverflow.com/questions/50678467/building-openjdk-9-on-mac-os/54954805#54954805","link":"/2019/05/11/Java/Mac%E4%B8%8B%E7%BC%96%E8%AF%91OpenJdk8/"},{"title":"Synchronized偏向锁批量重偏向与批量撤销","text":"1.批量重偏向 intx BiasedLockingBulkRebiasThreshold = 20 默认偏向锁批量重偏向阈值 可以通过JVM参数 -XX:BiasedLockingBulkRebiasThreshold手动设置阈值 起因：当一个线程A对某个类生成大量的对象的对象，这些对象偏向了A，后面突然有来了个线程B去抢线程A生成的对象，就会导致偏向锁的升级为轻量级锁，如果总是在不断的升级锁，到了一定的阈值，JVM 就会对类的所有对象进行批量的重新偏向与B。 测试代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class BiasedLock { public static void main(String[] args) throws InterruptedException { //偏向延时 Thread.sleep(5000); final ArrayList&lt;Dog&gt; dogArrayList = new ArrayList&lt;&gt;(); Runnable runnable1 = new Runnable() { @Override public void run() { while (dogArrayList.size() &lt; 60) { Dog dog = new Dog(); synchronized (dog){ dogArrayList.add(dog); HeaderPrint.parseHeaderInfo(dog); } } //保持线程不要退出 try { Thread.sleep(100000); } catch (InterruptedException e) { e.printStackTrace(); } } }; Runnable runnable2 = new Runnable() { @Override public void run() { for (int i = 0; i &lt; 50; i++) { Dog dog = dogArrayList.get(i); synchronized (dog){ System.out.print((i+1)+\":\"); dogArrayList.add(dog); HeaderPrint.parseHeaderInfo(dog); } } //保持线程不要退出 try { Thread.sleep(100000); } catch (InterruptedException e) { e.printStackTrace(); } } }; new Thread(runnable1).start(); //保证线程1生成完毕 Thread.sleep(5000); new Thread(runnable2).start(); }} 我们可以看到，线程2启动的时候，是从偏向锁升级到了 轻量级锁 一直升级到 阈值20的时候，触发JVM优化机制，JVM认为偏向的不对，怎么总是线程2来强=抢，总的升级锁，比较麻烦，所以JVM直接让剩下dog对象，直接重新偏向到线程2 线程0 的偏向值 thread:54:000000000000000001111111101001001000101100000011000100(HEX:1fe922c0c4) 在 第 20个是的时候，就已经重新偏向了 后面的也都是偏向锁 1234567891050:--------START-----------Thread-2--------偏向锁--------thread:54:000000000000000001111111101001001000101100011000001110(HEX:1fe922c60e)epoch:2:01unused:1:0age:4:0000biased_lock:1:1--------END-----------Thread-2 2.批量撤销 intx BiasedLockingBulkRevokeThreshold = 40 默认偏向锁批量撤销阈值 可以通过JVM参数 -XX:BiasedLockingBulkRevokeThreshold手动设置阈值 起因：在多个线程竞争剧烈的情况下，使用偏向锁将会降低效率，于是乎产生了批量撤销机制。 测试代码： 批量重偏向和批量撤销是针对类的优化。 偏向锁只会重偏向一次，后面就是升级锁 当某个类已经触发批量撤销机制后，该类的对象不会再使用偏向锁 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public static void main(String[] args) throws InterruptedException { final CountDownLatch countDownLatch = new CountDownLatch(2); //偏向延时 Thread.sleep(5000); final ArrayList&lt;Dog&gt; dogArrayList = new ArrayList&lt;&gt;(); Runnable runnable1 = new Runnable() { @Override public void run() { while (dogArrayList.size() &lt; 80) { Dog dog = new Dog(); synchronized (dog) { dogArrayList.add(dog); } } //保持线程不要退出 try { Thread.sleep(50000); } catch (InterruptedException e) { e.printStackTrace(); } } }; Runnable runnable2 = new Runnable() { @Override public void run() { for (int i = 0; i &lt;39; i++) { if (i == 38) { System.out.println((i + 1) + \":\"); //这里主要是给主线程留出时间，让主线程打印出一个new Dog countDownLatch.countDown(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } Dog dog = dogArrayList.get(i); synchronized (dog) { dogArrayList.add(dog); try { Thread.sleep(20); } catch (InterruptedException e) { e.printStackTrace(); } } } //保持线程不要退出 try { Thread.sleep(50000); } catch (InterruptedException e) { e.printStackTrace(); } } }; new Thread(runnable1).start(); //保证线程1生成完毕 Thread.sleep(3000); //重新偏向线程2 new Thread(runnable2).start(); Thread.sleep(3000); //线程3导致偏向锁升级 new Thread(runnable2).start(); //线程3导致锁升级到39的时候，new出来的对象，默认是可偏向的状态 countDownLatch.await(); HeaderPrint.parseHeaderInfo(new Dog()); //保证之后 Thread.sleep(3000); //第39之后的新对象，已经没有偏向了，偏向被撤销了 HeaderPrint.parseHeaderInfo(new Dog()); } 输出 第39的时候，默认输出的是，可偏向状态 第39之后，new 的对象，已经被取消默认可偏向的状态了，成无锁了 123456789101112131415161718192039:--------START-----------main--------偏向锁--------thread:54:000000000000000000000000000000000000000000000000000000(HEX:0)epoch:2:01unused:1:0age:4:0000biased_lock:1:1--------END-----------main--------START-----------main--------无锁-----------unused:25:0000000000000000000000000identity_hashcode:31: 0000000000000000000000000000000 (Hex:0)unused:1:0age:4:0000biased_lock:1:0lock:2:01--------END-----------main","link":"/2019/10/20/Java/Synchronized%E5%81%8F%E5%90%91%E9%94%81%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91%E4%B8%8E%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80/"},{"title":"Ubuntu编译glibc库来验证Synchronized锁优化效果","text":"0.前言当然你可以说通过JOL查看对象的头信息，当然那个也是一种方法，但那个只能说明是这种状态，没有过程，本次主要结合来验证，Synchronized 关键字锁的状态：无锁、偏向锁、轻量级锁、重量级锁基于Ubuntu16测试成功。18测试失败，centos没有测试主要是在Java调用系统函数的时候，打印log。但是在Java里面打印线程ID是JVM层面的。需要自己实现一个native方法，在java层面调用。最后对比对应的PID 和TID，发现查看当前线程调用了几次系统锁Java 的重量级级锁都是通过glibc库的pthread_mutex_lock函数实现的，是在和操作系统级别的锁。 glibc库glibc是linux系统中最底层的api，几乎其它任何运行库都会依赖于glibc。glibc除了封装linux操作系统所提供的系统服务外，它本身也提供了许多其它一些必要功能服务的实现。 操作系统底层库 int pthread_mutex_lock(pthread_mutex_t *mutex);pthread_mutex_lock()返回时，该互斥锁已被锁定。线程调用该函数让互斥锁上锁，如果该互斥锁已被另一个线程锁定和拥有，则调用该线程将阻塞，直到该互斥锁变为可用为止。 对于 Solaris线程，请参见mutex_lock 语法 会阻塞 我们可以从JVM 源码中看到调用 ThreadCritical::ThreadCritical12345678910ThreadCritical::ThreadCritical() { pthread_t self = pthread_self(); if (self != tc_owner) { int ret = pthread_mutex_lock(&amp;tc_mutex); guarantee(ret == 0, \"fatal error with pthread_mutex_lock()\"); assert(tc_count == 0, \"Lock acquired with illegal reentry count.\"); tc_owner = self; } tc_count++;} 这个是底层系统库，我们是看不到源码的，只能自己下载。可以在glibc/nptl/phread_mutex_lock.c里看到实现。 我尝试就是在这里函数里加上自己的log 12345int __pthread_mutex_lock (pthread_mutex_t *mutex){ //打印log fprintf(stdout,\"pthread_mutex_lock log PID = %d TID = %lu mutex = %p \\n\",getpid(),pthread_self(),&amp;mutex); --- 1. 查看自己的glibc版本12345root@189415df5c51:/lib/x86_64-linux-gnu# pwd/lib/x86_64-linux-gnuroot@189415df5c51:/lib/x86_64-linux-gnu# ls -l libc.so.6lrwxrwxrwx 1 root root 12 Feb 5 2019 libc.so.6 -&gt; libc-2.23.soroot@189415df5c51:/lib/x86_64-linux-gnu# 2.最好下载同一个版本，编译glibc版本https://ftp.gnu.org/gnu/glibc/?C=M;O=A目录可以自己变化，但是glibc不让在源码目录下面编译 会报 Makeconfig:42: *** missing separator. Stop若有必要，可以参考 Linux源码包的一般安装步 12345mkdir buildcd build./../configure --prefix = usr/local/glibc makemake install 3.修改替换 编译vim pthread_mutex_lock.c 添加log 1fprintf(stdout,\"pthread_mutex_lock log PID = %d TID = %lu mutex = %p \\n\",getpid(),pthread_self(),&amp;mutex); 4.运行时替换关键库 这里需要注意，搞错了，就不能的话，所有命令都可能用不了了 自己主要修改的是pthread库，所以替换系统的pthread库，find一下 1.查看 /etc/ld.conf.d/x86-gnu*.conf 下的目录 2.因为要替换几个关键文件，直接手动替换会出错，系统库是在动态加载的。copy 一个临时目录，加上了n后缀，做区分。去替换临时目录里面的文件 3.例如我的 12345cp /usr/local/glibc23/lib/libpthread.so /usr/lib/x86_64-linux-gnu-n/libpthread.socp /usr/local/glibc23/lib/libpthread_nonshared.a /usr/lib/x86_64-linux-gnu-n/libpthread_nonshared.acp /usr/local/glibc23/lib/libpthread.a /usr/lib/x86_64-linux-gnu-n/libpthread.acp /usr/local/glibc23/lib/libpthread-2.23.so /lib/x86_64-linux-gnu-n/libpthread-2.23.socp /usr/local/glibc23/lib/libpthread.so.0 /lib/x86_64-linux-gnu-n/libpthread.so.0 4.修改 /etc/ld.conf.d/x86-gnu*.conf 里面的链接库路径指向临时目录，不用了可以改回 5.执行ldconfig，生效 6.自己配置java环境 基本任命令都会触发这行log 123root@189415df5c51:/etc/ld.so.conf.d# lspthread_mutex_lock log PID = 62030 TID = 140453473769472 mutex=0x7fbddf6a1948libc.conf x86_64-linux-gnu.conf 5.编写Java验证接下来，就是正常jni流程了 JniTool.java12345678package jnitool;public class JniTool { static { System.loadLibrary(\"jnitools\"); } public native void getThreadID();} 这里jnitool必须在 java.library.path这一jvm变量所指向的路径中，可以通过如下方法获得该变量System.getProperty(“java.library.path”); 生成.h文件，javah -jni jnitool.JniTool打印java线程的pid和tid，jvm层面 12345678910#include \"jnitool_JniTool.h\"#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;JNIEXPORT void JNICALL Java_jnitool_JniTool_getThreadID (JNIEnv * env, jobject obj){ fprintf(stdout,\"java_lock log PID = %d TID = %lu \\n\",getpid(),pthread_self()); fflush(stdout);//刷新，防止错位打印} 使用make编译123456vim makefilelibjnitools.so: gcc -lpthread -fPIC -shared -o libjnitools.so -I /root/jdk1.8.0_221/include/ -I /root/jdk1.8.0_221/include/linux/ ./jnitools.c make 6. 观察不同的锁 主要是对比不同的锁情况下，对操作系统系统锁的调用情况，观察优化效果 当然JVM对锁的优化，是调用系统锁的次数越少越好 听过系统锁的log，直观对比调用pthread_mutex_lock次数 奇怪的是我在docker里面，修改glibc库后，加上jol打印头信息就会卡，所以先验证是什么锁的情况下，再打的log 6.1 无锁123456789101112131415161718192021222324252627282930313233343536373839404142public class SyncTest { //测试锁 final Object lock = new Object(); //获取pthread tid JniTool jniTool = new JniTool(); public static void main(String[] args) throws InterruptedException { //不打开，默认就是无所的状态 //Thread.sleep(5000); SyncTest test = new SyncTest(); System.out.println(\"---------------------------start--------------------\"); test.start(); } public void start() throws InterruptedException { Runnable runnable = new Runnable() { @Override public void run() { int count = 0; System.out.println(Thread.currentThread().getName() + \" start\"); while (true) { if (count &lt; 50) { count++; } else { return; } try { lock(); } catch (InterruptedException e) { e.printStackTrace(); } } } }; new Thread(runnable).start(); } public void lock() throws InterruptedException { synchronized (lock) { jniTool.getThreadID(); } }} out.log 通过log可以看到50次调用,通过搜索tid查看 刚开始和结束调用了系统锁，中间是没有调用系统锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657583545: pthread_mutex_lock log PID = 399 TID = 140058569967360 mutex=0x7f61e800b728 3546: pthread_mutex_lock log PID = 399 TID = 140058569967360 mutex=0x7f61e8100b28 3549: pthread_mutex_lock log PID = 399 TID = 140058569967360 mutex=0x7f61e8100b28 3555: pthread_mutex_lock log PID = 399 TID = 140058569967360 mutex=0x7f61e80b9228 3562: pthread_mutex_lock log PID = 399 TID = 140058569967360 mutex=0x7f61f778b8a0 3563: pthread_mutex_lock log PID = 399 TID = 140058569967360 mutex=0x7f61f83d3948 3564: java_lock log-----------PID = 399 TID = 140058569967360 3575: java_lock log-----------PID = 399 TID = 140058569967360 3576: java_lock log-----------PID = 399 TID = 140058569967360 3577: java_lock log-----------PID = 399 TID = 140058569967360 3578: java_lock log-----------PID = 399 TID = 140058569967360 3579: java_lock log-----------PID = 399 TID = 140058569967360 3580: java_lock log-----------PID = 399 TID = 140058569967360 3581: java_lock log-----------PID = 399 TID = 140058569967360 3582: java_lock log-----------PID = 399 TID = 140058569967360 3583: java_lock log-----------PID = 399 TID = 140058569967360 3584: java_lock log-----------PID = 399 TID = 140058569967360 3585: java_lock log-----------PID = 399 TID = 140058569967360 3586: java_lock log-----------PID = 399 TID = 140058569967360 3587: java_lock log-----------PID = 399 TID = 140058569967360 3588: java_lock log-----------PID = 399 TID = 140058569967360 3590: java_lock log-----------PID = 399 TID = 140058569967360 3591: java_lock log-----------PID = 399 TID = 140058569967360 3592: java_lock log-----------PID = 399 TID = 140058569967360 3593: java_lock log-----------PID = 399 TID = 140058569967360 3594: java_lock log-----------PID = 399 TID = 140058569967360 3595: java_lock log-----------PID = 399 TID = 140058569967360 3596: java_lock log-----------PID = 399 TID = 140058569967360 3597: java_lock log-----------PID = 399 TID = 140058569967360 3598: java_lock log-----------PID = 399 TID = 140058569967360 3599: java_lock log-----------PID = 399 TID = 140058569967360 3600: java_lock log-----------PID = 399 TID = 140058569967360 3601: java_lock log-----------PID = 399 TID = 140058569967360 3602: java_lock log-----------PID = 399 TID = 140058569967360 3603: java_lock log-----------PID = 399 TID = 140058569967360 3604: java_lock log-----------PID = 399 TID = 140058569967360 3605: java_lock log-----------PID = 399 TID = 140058569967360 3606: java_lock log-----------PID = 399 TID = 140058569967360 3607: java_lock log-----------PID = 399 TID = 140058569967360 3608: java_lock log-----------PID = 399 TID = 140058569967360 3609: java_lock log-----------PID = 399 TID = 140058569967360 3610: java_lock log-----------PID = 399 TID = 140058569967360 3611: java_lock log-----------PID = 399 TID = 140058569967360 3612: java_lock log-----------PID = 399 TID = 140058569967360 3613: java_lock log-----------PID = 399 TID = 140058569967360 3614: java_lock log-----------PID = 399 TID = 140058569967360 3615: java_lock log-----------PID = 399 TID = 140058569967360 3616: java_lock log-----------PID = 399 TID = 140058569967360 3617: java_lock log-----------PID = 399 TID = 140058569967360 3618: java_lock log-----------PID = 399 TID = 140058569967360 3619: java_lock log-----------PID = 399 TID = 140058569967360 3620: java_lock log-----------PID = 399 TID = 140058569967360 3621: java_lock log-----------PID = 399 TID = 140058569967360 3622: java_lock log-----------PID = 399 TID = 140058569967360 3623: java_lock log-----------PID = 399 TID = 140058569967360 3624: pthread_mutex_lock log PID = 399 TID = 140058569967360 mutex=0x7f61e800b528 3625: pthread_mutex_lock log PID = 399 TID = 140058569967360 mutex=0x7f61f77a32c0 3626: pthread_mutex_lock log PID = 399 TID = 140058569967360 mutex=0x7f61f77a32c0 6.2 偏向锁 偏向锁是默认延时加载的 我们可以加JVM参数或sleep 通过上面的代码，加上 Thread.sleep(5000);确保偏向锁打开 out.log 查看输出, 效果如上 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061623742: pthread_mutex_lock log PID = 431 TID = 139799890413312 mutex=0x7f25c800b728 3743: pthread_mutex_lock log PID = 431 TID = 139799890413312 mutex=0x7f25c80e9128 3750: pthread_mutex_lock log PID = 431 TID = 139799890413312 mutex=0x7f25c80e9128 3752: pthread_mutex_lock log PID = 431 TID = 139799890413312 mutex=0x7f25c80b9228 3763: pthread_mutex_lock log PID = 431 TID = 139799890413312 mutex=0x7f25cffe18a0 3764: pthread_mutex_lock log PID = 431 TID = 139799890413312 mutex=0x7f25d4c8b948 3765: java_lock log-----------PID = 431 TID = 139799890413312 3772: java_lock log-----------PID = 431 TID = 139799890413312 3773: java_lock log-----------PID = 431 TID = 139799890413312 3774: java_lock log-----------PID = 431 TID = 139799890413312 3775: java_lock log-----------PID = 431 TID = 139799890413312 3776: java_lock log-----------PID = 431 TID = 139799890413312 3777: java_lock log-----------PID = 431 TID = 139799890413312 3778: java_lock log-----------PID = 431 TID = 139799890413312 3779: java_lock log-----------PID = 431 TID = 139799890413312 3780: java_lock log-----------PID = 431 TID = 139799890413312 3781: java_lock log-----------PID = 431 TID = 139799890413312 3782: java_lock log-----------PID = 431 TID = 139799890413312 3783: java_lock log-----------PID = 431 TID = 139799890413312 3785: java_lock log-----------PID = 431 TID = 139799890413312 3787: java_lock log-----------PID = 431 TID = 139799890413312 3788: java_lock log-----------PID = 431 TID = 139799890413312 3789: java_lock log-----------PID = 431 TID = 139799890413312 3790: java_lock log-----------PID = 431 TID = 139799890413312 3791: java_lock log-----------PID = 431 TID = 139799890413312 3792: java_lock log-----------PID = 431 TID = 139799890413312 3793: java_lock log-----------PID = 431 TID = 139799890413312 3794: java_lock log-----------PID = 431 TID = 139799890413312 3795: java_lock log-----------PID = 431 TID = 139799890413312 3796: java_lock log-----------PID = 431 TID = 139799890413312 3797: java_lock log-----------PID = 431 TID = 139799890413312 3798: java_lock log-----------PID = 431 TID = 139799890413312 3799: java_lock log-----------PID = 431 TID = 139799890413312 3800: java_lock log-----------PID = 431 TID = 139799890413312 3801: java_lock log-----------PID = 431 TID = 139799890413312 3802: java_lock log-----------PID = 431 TID = 139799890413312 3803: java_lock log-----------PID = 431 TID = 139799890413312 3804: java_lock log-----------PID = 431 TID = 139799890413312 3805: java_lock log-----------PID = 431 TID = 139799890413312 3806: java_lock log-----------PID = 431 TID = 139799890413312 3807: java_lock log-----------PID = 431 TID = 139799890413312 3808: java_lock log-----------PID = 431 TID = 139799890413312 3809: java_lock log-----------PID = 431 TID = 139799890413312 3810: java_lock log-----------PID = 431 TID = 139799890413312 3811: java_lock log-----------PID = 431 TID = 139799890413312 3812: java_lock log-----------PID = 431 TID = 139799890413312 3813: java_lock log-----------PID = 431 TID = 139799890413312 3814: java_lock log-----------PID = 431 TID = 139799890413312 3815: java_lock log-----------PID = 431 TID = 139799890413312 3816: java_lock log-----------PID = 431 TID = 139799890413312 3817: java_lock log-----------PID = 431 TID = 139799890413312 3818: java_lock log-----------PID = 431 TID = 139799890413312 3819: java_lock log-----------PID = 431 TID = 139799890413312 3820: java_lock log-----------PID = 431 TID = 139799890413312 3821: java_lock log-----------PID = 431 TID = 139799890413312 3822: java_lock log-----------PID = 431 TID = 139799890413312 3823: pthread_mutex_lock log PID = 431 TID = 139799890413312 mutex=0x7f25c8079528 3824: pthread_mutex_lock log PID = 431 TID = 139799890413312 mutex=0x7f25c80e9128 3828: pthread_mutex_lock log PID = 431 TID = 139799890413312 mutex=0x7f25c80e9128 3829: pthread_mutex_lock log PID = 431 TID = 139799890413312 mutex=0x7f25c800b528 3830: pthread_mutex_lock log PID = 431 TID = 139799890413312 mutex=0x7f25cfff92c0 3831: pthread_mutex_lock log PID = 431 TID = 139799890413312 mutex=0x7f25cfff92c0 6.3 轻量级锁 我们偏向锁，升级到轻量级锁1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class SyncTest { //测试锁 final Object lock = new Object(); //获取pthread tid JniTool jniTool = new JniTool(); public static void main(String[] args) throws InterruptedException { //打开就是默认的偏向锁，默认是可偏向状态，但是不偏向任何一个线程 //不打开，默认就是无所的状态 Thread.sleep(5000); SyncTest test = new SyncTest(); // test.parseHeaderInfo((ClassLayout.parseInstance(test.lock).toPrintable())); System.out.println(\"---------------------------start--------------------\"); test.start(); } public void start() throws InterruptedException { Runnable runnable = new Runnable() { @Override public void run() { int count = 0; System.out.println(Thread.currentThread().getName() + \" start\"); while (true) { if (count &lt; 50) { count++; } else { //若线程没有结束，但是线程1放锁了，升级为轻量级锁 try { Thread.sleep(100000); } catch (InterruptedException e) { e.printStackTrace(); } return; } try { lock(); // parseHeaderInfo(ClassLayout.parseInstance(lock).toPrintable()); } catch (InterruptedException e) { e.printStackTrace(); } } } }; new Thread(runnable).start(); //加上，保证线程1结束，若果线程1已经结束，则还是偏向锁 //若线程没有结束，但是线程1放锁了，升级为轻量级锁 Thread.sleep(2000); //不加,则会升级为重量级锁 new Thread(runnable).start(); } public void lock() throws InterruptedException { synchronized (lock) { jniTool.getThreadID(); } }} out.log 线程1的时候偏向 线程2的时候，升级到轻量级锁1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131143763: pthread_mutex_lock log PID = 498 TID = 139928822331136 mutex=0x7f43cc00b728 3764: pthread_mutex_lock log PID = 498 TID = 139928822331136 mutex=0x7f43cc108d28 3768: pthread_mutex_lock log PID = 498 TID = 139928822331136 mutex=0x7f43cc108d28 3769: pthread_mutex_lock log PID = 498 TID = 139928822331136 mutex=0x7f43cc0bba28 3774: pthread_mutex_lock log PID = 498 TID = 139928822331136 mutex=0x7f43d3fe18a0 3775: pthread_mutex_lock log PID = 498 TID = 139928822331136 mutex=0x7f43d9bea948 3777: java_lock log-----------PID = 498 TID = 139928822331136 3789: java_lock log-----------PID = 498 TID = 139928822331136 3790: java_lock log-----------PID = 498 TID = 139928822331136 3791: java_lock log-----------PID = 498 TID = 139928822331136 3792: java_lock log-----------PID = 498 TID = 139928822331136 3793: java_lock log-----------PID = 498 TID = 139928822331136 3794: java_lock log-----------PID = 498 TID = 139928822331136 3795: java_lock log-----------PID = 498 TID = 139928822331136 3796: java_lock log-----------PID = 498 TID = 139928822331136 3797: java_lock log-----------PID = 498 TID = 139928822331136 3798: java_lock log-----------PID = 498 TID = 139928822331136 3799: java_lock log-----------PID = 498 TID = 139928822331136 3800: java_lock log-----------PID = 498 TID = 139928822331136 3801: java_lock log-----------PID = 498 TID = 139928822331136 3802: java_lock log-----------PID = 498 TID = 139928822331136 3803: java_lock log-----------PID = 498 TID = 139928822331136 3804: java_lock log-----------PID = 498 TID = 139928822331136 3805: java_lock log-----------PID = 498 TID = 139928822331136 3806: java_lock log-----------PID = 498 TID = 139928822331136 3807: java_lock log-----------PID = 498 TID = 139928822331136 3808: java_lock log-----------PID = 498 TID = 139928822331136 3809: java_lock log-----------PID = 498 TID = 139928822331136 3810: java_lock log-----------PID = 498 TID = 139928822331136 3811: java_lock log-----------PID = 498 TID = 139928822331136 3812: java_lock log-----------PID = 498 TID = 139928822331136 3813: java_lock log-----------PID = 498 TID = 139928822331136 3814: java_lock log-----------PID = 498 TID = 139928822331136 3815: java_lock log-----------PID = 498 TID = 139928822331136 3816: java_lock log-----------PID = 498 TID = 139928822331136 3817: java_lock log-----------PID = 498 TID = 139928822331136 3818: java_lock log-----------PID = 498 TID = 139928822331136 3819: java_lock log-----------PID = 498 TID = 139928822331136 3820: java_lock log-----------PID = 498 TID = 139928822331136 3822: java_lock log-----------PID = 498 TID = 139928822331136 3824: java_lock log-----------PID = 498 TID = 139928822331136 3825: java_lock log-----------PID = 498 TID = 139928822331136 3826: java_lock log-----------PID = 498 TID = 139928822331136 3827: java_lock log-----------PID = 498 TID = 139928822331136 3828: java_lock log-----------PID = 498 TID = 139928822331136 3829: java_lock log-----------PID = 498 TID = 139928822331136 3830: java_lock log-----------PID = 498 TID = 139928822331136 3831: java_lock log-----------PID = 498 TID = 139928822331136 3832: java_lock log-----------PID = 498 TID = 139928822331136 3833: java_lock log-----------PID = 498 TID = 139928822331136 3834: java_lock log-----------PID = 498 TID = 139928822331136 3835: java_lock log-----------PID = 498 TID = 139928822331136 3836: java_lock log-----------PID = 498 TID = 139928822331136 3837: java_lock log-----------PID = 498 TID = 139928822331136 3838: java_lock log-----------PID = 498 TID = 139928822331136 3839: java_lock log-----------PID = 498 TID = 139928822331136 3840: pthread_mutex_lock log PID = 498 TID = 139928822331136 mutex=0x7f43cc108b28 3932: pthread_mutex_lock log PID = 498 TID = 139928821278464 mutex=0x7f43cc00b728 3933: pthread_mutex_lock log PID = 498 TID = 139928821278464 mutex=0x7f43cc0dd228 3938: pthread_mutex_lock log PID = 498 TID = 139928821278464 mutex=0x7f43cc0dd228 3942: pthread_mutex_lock log PID = 498 TID = 139928821278464 mutex=0x7f43cc079528 3945: pthread_mutex_lock log PID = 498 TID = 139928821278464 mutex=0x7f43cc079528 3950: pthread_mutex_lock log PID = 498 TID = 139928821278464 mutex=0x7f43cc079528 3953: java_lock log-----------PID = 498 TID = 139928821278464 3954: java_lock log-----------PID = 498 TID = 139928821278464 3955: java_lock log-----------PID = 498 TID = 139928821278464 3956: java_lock log-----------PID = 498 TID = 139928821278464 3957: java_lock log-----------PID = 498 TID = 139928821278464 3958: java_lock log-----------PID = 498 TID = 139928821278464 3959: java_lock log-----------PID = 498 TID = 139928821278464 3960: java_lock log-----------PID = 498 TID = 139928821278464 3961: java_lock log-----------PID = 498 TID = 139928821278464 3962: java_lock log-----------PID = 498 TID = 139928821278464 3963: java_lock log-----------PID = 498 TID = 139928821278464 3964: java_lock log-----------PID = 498 TID = 139928821278464 3965: java_lock log-----------PID = 498 TID = 139928821278464 3966: java_lock log-----------PID = 498 TID = 139928821278464 3967: java_lock log-----------PID = 498 TID = 139928821278464 3968: java_lock log-----------PID = 498 TID = 139928821278464 3969: java_lock log-----------PID = 498 TID = 139928821278464 3970: java_lock log-----------PID = 498 TID = 139928821278464 3971: java_lock log-----------PID = 498 TID = 139928821278464 3972: java_lock log-----------PID = 498 TID = 139928821278464 3973: java_lock log-----------PID = 498 TID = 139928821278464 3974: java_lock log-----------PID = 498 TID = 139928821278464 3975: java_lock log-----------PID = 498 TID = 139928821278464 3976: java_lock log-----------PID = 498 TID = 139928821278464 3977: java_lock log-----------PID = 498 TID = 139928821278464 3978: java_lock log-----------PID = 498 TID = 139928821278464 3979: java_lock log-----------PID = 498 TID = 139928821278464 3980: java_lock log-----------PID = 498 TID = 139928821278464 3981: java_lock log-----------PID = 498 TID = 139928821278464 3982: java_lock log-----------PID = 498 TID = 139928821278464 3983: java_lock log-----------PID = 498 TID = 139928821278464 3984: java_lock log-----------PID = 498 TID = 139928821278464 3985: java_lock log-----------PID = 498 TID = 139928821278464 3986: java_lock log-----------PID = 498 TID = 139928821278464 3987: java_lock log-----------PID = 498 TID = 139928821278464 3988: java_lock log-----------PID = 498 TID = 139928821278464 3989: java_lock log-----------PID = 498 TID = 139928821278464 3990: java_lock log-----------PID = 498 TID = 139928821278464 3991: java_lock log-----------PID = 498 TID = 139928821278464 3992: java_lock log-----------PID = 498 TID = 139928821278464 3993: java_lock log-----------PID = 498 TID = 139928821278464 3994: java_lock log-----------PID = 498 TID = 139928821278464 3995: java_lock log-----------PID = 498 TID = 139928821278464 3996: java_lock log-----------PID = 498 TID = 139928821278464 3997: java_lock log-----------PID = 498 TID = 139928821278464 3998: java_lock log-----------PID = 498 TID = 139928821278464 3999: java_lock log-----------PID = 498 TID = 139928821278464 4000: java_lock log-----------PID = 498 TID = 139928821278464 4001: java_lock log-----------PID = 498 TID = 139928821278464 4002: java_lock log-----------PID = 498 TID = 139928821278464 4003: pthread_mutex_lock log PID = 498 TID = 139928821278464 mutex=0x7f43cc0dd028 6.4 重量级锁 上面的代码，我们2个线程不等待，直接启动 则会再偏向锁的情况下，直接升级到重量级锁 out.log 可以明显看到 系统锁的调用测试变多 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602613750: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029000b728 3751: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f0290108c28 3756: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f0290108c28 3758: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029000b728 3759: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f02900b9228 3760: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a528 3770: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a528 3775: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029d4b28a0 3776: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029e0fa948 3778: java_lock log-----------PID = 532 TID = 139648716183296 3784: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f0290079528 3785: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a528 3796: java_lock log-----------PID = 532 TID = 139648716183296 3797: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a528 3798: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3799: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3800: java_lock log-----------PID = 532 TID = 139648716183296 3801: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3802: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3803: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3804: java_lock log-----------PID = 532 TID = 139648716183296 3805: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3806: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3807: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3808: java_lock log-----------PID = 532 TID = 139648716183296 3809: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3810: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3811: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3812: java_lock log-----------PID = 532 TID = 139648716183296 3813: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3814: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3815: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3816: java_lock log-----------PID = 532 TID = 139648716183296 3817: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3818: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3819: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3820: java_lock log-----------PID = 532 TID = 139648716183296 3821: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3822: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3823: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3824: java_lock log-----------PID = 532 TID = 139648716183296 3825: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3826: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3827: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3828: java_lock log-----------PID = 532 TID = 139648716183296 3829: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3830: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3831: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3832: java_lock log-----------PID = 532 TID = 139648716183296 3833: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3834: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3835: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3836: java_lock log-----------PID = 532 TID = 139648716183296 3837: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3838: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3839: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3840: java_lock log-----------PID = 532 TID = 139648716183296 3841: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3842: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3843: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3844: java_lock log-----------PID = 532 TID = 139648716183296 3845: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3846: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3847: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3848: java_lock log-----------PID = 532 TID = 139648716183296 3849: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3850: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3851: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3852: java_lock log-----------PID = 532 TID = 139648716183296 3853: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3854: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3855: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3856: java_lock log-----------PID = 532 TID = 139648716183296 3857: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3858: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3859: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3860: java_lock log-----------PID = 532 TID = 139648716183296 3861: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3862: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3863: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3864: java_lock log-----------PID = 532 TID = 139648716183296 3865: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3866: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3867: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3868: java_lock log-----------PID = 532 TID = 139648716183296 3869: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3870: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3871: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3872: java_lock log-----------PID = 532 TID = 139648716183296 3873: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3874: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3875: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3876: java_lock log-----------PID = 532 TID = 139648716183296 3877: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3878: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3879: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3880: java_lock log-----------PID = 532 TID = 139648716183296 3881: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3882: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3883: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3884: java_lock log-----------PID = 532 TID = 139648716183296 3885: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3886: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3887: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3888: java_lock log-----------PID = 532 TID = 139648716183296 3889: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3890: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3891: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3892: java_lock log-----------PID = 532 TID = 139648716183296 3893: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3894: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3895: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3896: java_lock log-----------PID = 532 TID = 139648716183296 3897: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3898: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3899: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3900: java_lock log-----------PID = 532 TID = 139648716183296 3901: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3902: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3903: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3904: java_lock log-----------PID = 532 TID = 139648716183296 3905: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3906: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3907: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3908: java_lock log-----------PID = 532 TID = 139648716183296 3909: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3910: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3911: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3912: java_lock log-----------PID = 532 TID = 139648716183296 3913: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3914: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3915: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3916: java_lock log-----------PID = 532 TID = 139648716183296 3917: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3918: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3919: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3920: java_lock log-----------PID = 532 TID = 139648716183296 3921: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3922: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3923: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3924: java_lock log-----------PID = 532 TID = 139648716183296 3925: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3926: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3927: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3928: java_lock log-----------PID = 532 TID = 139648716183296 3929: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3930: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3931: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3932: java_lock log-----------PID = 532 TID = 139648716183296 3933: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3934: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3935: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3936: java_lock log-----------PID = 532 TID = 139648716183296 3937: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3938: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3939: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3940: java_lock log-----------PID = 532 TID = 139648716183296 3941: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3942: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3943: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3944: java_lock log-----------PID = 532 TID = 139648716183296 3945: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3946: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3947: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3948: java_lock log-----------PID = 532 TID = 139648716183296 3949: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3950: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3951: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3952: java_lock log-----------PID = 532 TID = 139648716183296 3953: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3954: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3955: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3956: java_lock log-----------PID = 532 TID = 139648716183296 3957: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3958: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3959: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3960: java_lock log-----------PID = 532 TID = 139648716183296 3961: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3962: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3963: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3964: java_lock log-----------PID = 532 TID = 139648716183296 3965: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3966: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3967: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3968: java_lock log-----------PID = 532 TID = 139648716183296 3969: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3970: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3971: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3972: java_lock log-----------PID = 532 TID = 139648716183296 3973: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3974: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3975: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3976: java_lock log-----------PID = 532 TID = 139648716183296 3977: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3978: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3979: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3980: java_lock log-----------PID = 532 TID = 139648716183296 3981: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3982: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3983: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3984: java_lock log-----------PID = 532 TID = 139648716183296 3985: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3986: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3987: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3988: java_lock log-----------PID = 532 TID = 139648716183296 3989: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3990: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3991: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f029010a128 3992: pthread_mutex_lock log PID = 532 TID = 139648716183296 mutex=0x7f0290108a28 3993: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a128 3994: java_lock log-----------PID = 532 TID = 139648647034624 3995: java_lock log-----------PID = 532 TID = 139648647034624 3996: java_lock log-----------PID = 532 TID = 139648647034624 3997: java_lock log-----------PID = 532 TID = 139648647034624 3998: java_lock log-----------PID = 532 TID = 139648647034624 3999: java_lock log-----------PID = 532 TID = 139648647034624 4000: java_lock log-----------PID = 532 TID = 139648647034624 4001: java_lock log-----------PID = 532 TID = 139648647034624 4002: java_lock log-----------PID = 532 TID = 139648647034624 4003: java_lock log-----------PID = 532 TID = 139648647034624 4004: java_lock log-----------PID = 532 TID = 139648647034624 4005: java_lock log-----------PID = 532 TID = 139648647034624 4006: java_lock log-----------PID = 532 TID = 139648647034624 4007: java_lock log-----------PID = 532 TID = 139648647034624 4008: java_lock log-----------PID = 532 TID = 139648647034624 4009: java_lock log-----------PID = 532 TID = 139648647034624 4010: java_lock log-----------PID = 532 TID = 139648647034624 4011: java_lock log-----------PID = 532 TID = 139648647034624 4012: java_lock log-----------PID = 532 TID = 139648647034624 4013: java_lock log-----------PID = 532 TID = 139648647034624 4014: java_lock log-----------PID = 532 TID = 139648647034624 4015: java_lock log-----------PID = 532 TID = 139648647034624 4016: java_lock log-----------PID = 532 TID = 139648647034624 4017: java_lock log-----------PID = 532 TID = 139648647034624 4018: java_lock log-----------PID = 532 TID = 139648647034624 4019: java_lock log-----------PID = 532 TID = 139648647034624 4020: java_lock log-----------PID = 532 TID = 139648647034624 4021: java_lock log-----------PID = 532 TID = 139648647034624 4022: java_lock log-----------PID = 532 TID = 139648647034624 4023: java_lock log-----------PID = 532 TID = 139648647034624 4024: java_lock log-----------PID = 532 TID = 139648647034624 4025: java_lock log-----------PID = 532 TID = 139648647034624 4026: java_lock log-----------PID = 532 TID = 139648647034624 4027: java_lock log-----------PID = 532 TID = 139648647034624 4028: java_lock log-----------PID = 532 TID = 139648647034624 4029: java_lock log-----------PID = 532 TID = 139648647034624 4030: java_lock log-----------PID = 532 TID = 139648647034624 4031: java_lock log-----------PID = 532 TID = 139648647034624 4032: java_lock log-----------PID = 532 TID = 139648647034624 4033: java_lock log-----------PID = 532 TID = 139648647034624 4034: java_lock log-----------PID = 532 TID = 139648647034624 4035: java_lock log-----------PID = 532 TID = 139648647034624 4036: java_lock log-----------PID = 532 TID = 139648647034624 4037: java_lock log-----------PID = 532 TID = 139648647034624 4038: java_lock log-----------PID = 532 TID = 139648647034624 4039: java_lock log-----------PID = 532 TID = 139648647034624 4040: java_lock log-----------PID = 532 TID = 139648647034624 4041: java_lock log-----------PID = 532 TID = 139648647034624 4042: java_lock log-----------PID = 532 TID = 139648647034624 4043: java_lock log-----------PID = 532 TID = 139648647034624 4044: pthread_mutex_lock log PID = 532 TID = 139648647034624 mutex=0x7f029010a328 7 总结 无锁，偏向锁，轻量级锁，本质上都JVM层面的锁，除了开始和结束的时候，没有调用系统锁。 重量级锁是需要 系统锁 pthread_mutex_lock 支持的 每个线程50次调用，系统锁的调用次数，我们包括开始和结束 无锁 偏向 轻量级 重量级 线程数量 1 1 2 2 pthread_mutex_lock 调用次数 12 次 12次 14 次 161次 对比 轻量级锁和 重量级锁还是 优化比较大的 8 docker 镜像如果有需要, 上面 docker pull registry.cn-hangzhou.aliyuncs.com/kaiattrib/test:ubuntu16_glibc23 带 jdk 带 glibc23 源码，可编译 带 自己写的一个jni调用库","link":"/2019/10/18/Java/Ubuntu%E7%BC%96%E8%AF%91glibc%E5%BA%93%E6%9D%A5%E9%AA%8C%E8%AF%81JavaSynchronized%E9%94%81%E4%BC%98%E5%8C%96/"},{"title":"深入理解 Java HashCode","text":"1. hashcode1.Object的hashcode默认调用object的hashcode的话，会调用native方法，与本地相关。1public native int hashCode(); 来自 ： https://zhuanlan.zhihu.com/p/33915892下载完整的jdk呗（openJDK1.8）。找到Object.c文件，查看上面的方法映射表发现，hashCode被映射到了一个叫JVM_IHashCode上去了。 1234567static JNINativeMethod methods[] = { {\"hashCode\", \"()I\", (void *)&amp;JVM_IHashCode}, {\"wait\", \"(J)V\", (void *)&amp;JVM_MonitorWait}, {\"notify\", \"()V\", (void *)&amp;JVM_MonitorNotify}, {\"notifyAll\", \"()V\", (void *)&amp;JVM_MonitorNotifyAll}, {\"clone\", \"()Ljava/lang/Object;\", (void *)&amp;JVM_Clone},}; 顺藤摸瓜去看看JVM_IHashCode到底干了什么？熟悉的味道，在jvm.h里面有方法声明，那实现一定在jvm.cpp里面。不过jvm.cpp对于JVM_IHashCode的实现调用的是ObjectSynchronizer::FastHashCode的方法。 12345JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle)) JVMWrapper(\"JVM_IHashCode\"); // as implemented in the classic virtual machine; return 0 if object is NULL return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;JVM_END 发现声明在synchronizer.hpp 实现在这里synchronizer.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163// hashCode() generation ://// Possibilities:// * MD5Digest of {obj,stwRandom}// * CRC32 of {obj,stwRandom} or any linear-feedback shift register function.// * A DES- or AES-style SBox[] mechanism// * One of the Phi-based schemes, such as:// 2654435761 = 2^32 * Phi (golden ratio)// HashCodeValue = ((uintptr_t(obj) &gt;&gt; 3) * 2654435761) ^ GVars.stwRandom ;// * A variation of Marsaglia's shift-xor RNG scheme.// * (obj ^ stwRandom) is appealing, but can result// in undesirable regularity in the hashCode values of adjacent objects// (objects allocated back-to-back, in particular). This could potentially// result in hashtable collisions and reduced hashtable efficiency.// There are simple ways to \"diffuse\" the middle address bits over the// generated hashCode values:static inline intptr_t get_next_hash(Thread * Self, oop obj) { intptr_t value = 0; if (hashCode == 0) { // This form uses global Park-Miller RNG. // On MP system we'll have lots of RW access to a global, so the // mechanism induces lots of coherency traffic. value = os::random(); } else if (hashCode == 1) { // This variation has the property of being stable (idempotent) // between STW operations. This can be useful in some of the 1-0 // synchronization schemes. intptr_t addrBits = cast_from_oop&lt;intptr_t&gt;(obj) &gt;&gt; 3; value = addrBits ^ (addrBits &gt;&gt; 5) ^ GVars.stwRandom; } else if (hashCode == 2) { value = 1; // for sensitivity testing } else if (hashCode == 3) { value = ++GVars.hcSequence; } else if (hashCode == 4) { value = cast_from_oop&lt;intptr_t&gt;(obj); } else { // Marsaglia's xor-shift scheme with thread-specific state // This is probably the best overall implementation -- we'll // likely make this the default in future releases. unsigned t = Self-&gt;_hashStateX; t ^= (t &lt;&lt; 11); Self-&gt;_hashStateX = Self-&gt;_hashStateY; Self-&gt;_hashStateY = Self-&gt;_hashStateZ; Self-&gt;_hashStateZ = Self-&gt;_hashStateW; unsigned v = Self-&gt;_hashStateW; v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8)); Self-&gt;_hashStateW = v; value = v; } value &amp;= markOopDesc::hash_mask; if (value == 0) value = 0xBAD; assert(value != markOopDesc::no_hash, \"invariant\"); TEVENT(hashCode: GENERATE); return value;}intptr_t ObjectSynchronizer::FastHashCode(Thread * Self, oop obj) { if (UseBiasedLocking) { // NOTE: many places throughout the JVM do not expect a safepoint // to be taken here, in particular most operations on perm gen // objects. However, we only ever bias Java instances and all of // the call sites of identity_hash that might revoke biases have // been checked to make sure they can handle a safepoint. The // added check of the bias pattern is to avoid useless calls to // thread-local storage. if (obj-&gt;mark()-&gt;has_bias_pattern()) { // Handle for oop obj in case of STW safepoint Handle hobj(Self, obj); // Relaxing assertion for bug 6320749. assert(Universe::verify_in_progress() || !SafepointSynchronize::is_at_safepoint(), \"biases should not be seen by VM thread here\"); BiasedLocking::revoke_and_rebias(hobj, false, JavaThread::current()); obj = hobj(); assert(!obj-&gt;mark()-&gt;has_bias_pattern(), \"biases should be revoked by now\"); } } // hashCode() is a heap mutator ... // Relaxing assertion for bug 6320749. assert(Universe::verify_in_progress() || DumpSharedSpaces || !SafepointSynchronize::is_at_safepoint(), \"invariant\"); assert(Universe::verify_in_progress() || DumpSharedSpaces || Self-&gt;is_Java_thread() , \"invariant\"); assert(Universe::verify_in_progress() || DumpSharedSpaces || ((JavaThread *)Self)-&gt;thread_state() != _thread_blocked, \"invariant\"); ObjectMonitor* monitor = NULL; markOop temp, test; intptr_t hash; markOop mark = ReadStableMark(obj); // object should remain ineligible for biased locking assert(!mark-&gt;has_bias_pattern(), \"invariant\"); if (mark-&gt;is_neutral()) { hash = mark-&gt;hash(); // this is a normal header if (hash) { // if it has hash, just return it return hash; } hash = get_next_hash(Self, obj); // allocate a new hash code temp = mark-&gt;copy_set_hash(hash); // merge the hash code into header // use (machine word version) atomic operation to install the hash test = obj-&gt;cas_set_mark(temp, mark); if (test == mark) { return hash; } // If atomic operation failed, we must inflate the header // into heavy weight monitor. We could add more code here // for fast path, but it does not worth the complexity. } else if (mark-&gt;has_monitor()) { monitor = mark-&gt;monitor(); temp = monitor-&gt;header(); assert(temp-&gt;is_neutral(), \"invariant\"); hash = temp-&gt;hash(); if (hash) { return hash; } // Skip to the following code to reduce code size } else if (Self-&gt;is_lock_owned((address)mark-&gt;locker())) { temp = mark-&gt;displaced_mark_helper(); // this is a lightweight monitor owned assert(temp-&gt;is_neutral(), \"invariant\"); hash = temp-&gt;hash(); // by current thread, check if the displaced if (hash) { // header contains hash code return hash; } // WARNING: // The displaced header is strictly immutable. // It can NOT be changed in ANY cases. So we have // to inflate the header into heavyweight monitor // even the current thread owns the lock. The reason // is the BasicLock (stack slot) will be asynchronously // read by other threads during the inflate() function. // Any change to stack may not propagate to other threads // correctly. } // Inflate the monitor to set hash code monitor = ObjectSynchronizer::inflate(Self, obj, inflate_cause_hash_code); // Load displaced header and check it has hash code mark = monitor-&gt;header(); assert(mark-&gt;is_neutral(), \"invariant\"); hash = mark-&gt;hash(); if (hash == 0) { hash = get_next_hash(Self, obj); temp = mark-&gt;copy_set_hash(hash); // merge hash code into header assert(temp-&gt;is_neutral(), \"invariant\"); test = Atomic::cmpxchg(temp, monitor-&gt;header_addr(), mark); if (test != mark) { // The only update to the header in the monitor (outside GC) // is install the hash code. If someone add new usage of // displaced header, please update this code hash = test-&gt;hash(); assert(test-&gt;is_neutral(), \"invariant\"); assert(hash != 0, \"Trivial unexpected object/monitor header usage.\"); } } // We finally get the hash return hash;} 2.Java Object.hashCode()返回的是对象内存地址？不是！OpenJDK8 默认hashCode的计算方法是通过和当前线程有关的一个随机数+三个确定值，运用Marsaglia’s xorshift scheme随机数算法得到的一个随机数。和对象内存地址无关。当然也可以自己实现hashcode方法，关于hashcode() 与 equals()。主要是利用hashcode 可以判断2个对象的不等，hashcode相等，对象不一定相等，但hashcode不等，可以肯定2个对象不相等。在很多地方判断对象等不等。如果equals 定义了2个对象是相等的，需要注意hashcode还是不是相等的。 3.String类的hasCode()123456789101112public int hashCode() { int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) { char val[] = value; for (int i = 0; i &lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } 2.使用JOL查看对象信息maven 依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.9&lt;/version&gt;&lt;/dependency&gt; 为了内存比较“整齐”，关闭压缩指针，启动参数加上-XX:-UseCompressedOops 1.测试对象123class AAA{ private int number;} 2.测试方式112345678910111213141516171819202122public static void main(String[] args) { AAA aaa = new AAA(); System.out.println(\"---------before invoke hascode()-----------------\"); System.out.println(ClassLayout.parseInstance(aaa).toPrintable()); /*invoke hashcode() 转换成16进制*/ System.out.println(Integer.toHexString(aaa.hashCode())); System.out.println(\"------------after invoke hascode()-----------------\"); System.out.println(ClassLayout.parseInstance(aaa).toPrintable()); synchronized (aaa){ System.out.println(\"---------in synchronized() func--------------\"); System.out.println(Integer.toHexString(aaa.hashCode())); System.out.println(ClassLayout.parseInstance(aaa).toPrintable()); System.out.println(Integer.toHexString(aaa.hashCode())); } System.out.println(\"---------after invoke synchronized()--------------\"); System.out.println(Integer.toHexString(aaa.hashCode())); System.out.println(ClassLayout.parseInstance(aaa).toPrintable()); } 输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051---------before invoke hascode()-----------------AAA object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) a8 35 85 1c (10101000 00110101 10000101 00011100) (478492072) 12 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 16 4 int AAA.number 0 20 4 (loss due to the next object alignment)Instance size: 24 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total7e0b37bc------------after invoke hascode()-----------------AAA object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 bc 37 0b (00000001 10111100 00110111 00001011) (188201985) 4 4 (object header) 7e 00 00 00 (01111110 00000000 00000000 00000000) (126) 8 4 (object header) a8 35 85 1c (10101000 00110101 10000101 00011100) (478492072) 12 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 16 4 int AAA.number 0 20 4 (loss due to the next object alignment)Instance size: 24 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total---------in synchronized() func--------------7e0b37bcAAA object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) b0 f4 34 03 (10110000 11110100 00110100 00000011) (53802160) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) a8 35 85 1c (10101000 00110101 10000101 00011100) (478492072) 12 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 16 4 int AAA.number 0 20 4 (loss due to the next object alignment)Instance size: 24 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total7e0b37bc---------after invoke synchronized()--------------7e0b37bcAAA object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 bc 37 0b (00000001 10111100 00110111 00001011) (188201985) 4 4 (object header) 7e 00 00 00 (01111110 00000000 00000000 00000000) (126) 8 4 (object header) a8 35 85 1c (10101000 00110101 10000101 00011100) (478492072) 12 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 16 4 int AAA.number 0 20 4 (loss due to the next object alignment)Instance size: 24 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total 可以看到，在调用一次 hashcode之后，就会在object header 中生成hashcode。注意区分大小端模式。 object header 在有锁的情况下会发生变化，但是不会改变hashcode的值。 为什么有锁的状态下，头部的hashcode会变。无锁后 又变回来了？这是因为header会随着锁的状态发生变化。只有在无锁的情况下，才是这些字段。unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 另外，调用了一次hashcode 就会在栈帧中存在hashcode，但是与 偏向锁的字段发生冲突，因此jvm采用调用过hashcode的，不会存在偏向锁。为什么其它锁 可以呢？因为保存了指向栈中锁记录的指针，可以记录在里面。","link":"/2020/04/21/Java/javahashcode/"},{"title":"pthreadID 线程ID 复用证明","text":"背景pthread 库中有一个 pthread_self() 接口用来获取线程 ID，但是这个 ID并不是内核中那个线程 ID，pthread_t 到底是个什么样的数据结构呢？因为 POSIX 标准并没有限制 pthread_t 的数据类型，所以该类型取决于具体实现。对于 Linux 目前使用的 NPTL 实现而言，pthread_t 类型的线程 ID，本质上就是一个进程地址空间上的一个地址，而且 pthread_t 类型的线程 ID很有可能被复用。进程之间不会存在重复的线程 ID，而且不同线程之间也不会重复，在任意时刻都是全局唯一的值。 来源：在学习偏向锁的过程中，偏向锁是不能重新偏向的，为什么在各个线程中发现都是偏向到同一个线程？ 上一个线程拿到锁之后，是偏向锁。现在一个新线程拿到锁之后，可能复用了上一个ID。JVM判断加锁的对象是可偏向的，进一步对比发现偏向的线程还是当前线程，所以偏向锁使用成功。实际上这是一个新线程了。其实这样加上偏向锁性能还好些，免得升级锁。 证明JNI native code 获取线程ID 12345JNIEXPORT void JNICALL Java_jnitool_JniTool_getThreadID (JNIEnv * env, jobject obj){ fprintf(stdout,\"java_lock log PID = %d TID = %lu \\n\",getpid(),pthread_self());} 测试代码，让线程顺序执行。 123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args) throws Exception { out.println(\"\\n main ------------------------ start\"); JniTool jniTool = new JniTool(); Thread thread1 = new Thread(new Runnable() { public void run() { out.println(\"t1------------------------ start\"); jniTool.getThreadID(); out.println(\"java getId \"+(Thread.currentThread().getId())); out.println(\"t1------------------------ end\"); } }); thread1.start(); thread1.join(); Thread thread2 = new Thread(new Runnable() { public void run() { out.println(\"t2------------------------start\"); jniTool.getThreadID(); out.println(\"java getId \"+(Thread.currentThread().getId())); out.println(\"t2------------------------end\"); } }); thread2.start(); thread2.join(); Thread thread3 = new Thread(new Runnable() { public void run() { out.println(\"t3------------------------start\"); jniTool.getThreadID(); out.println(\"java getId \"+(Thread.currentThread().getId())); out.println(\"t3------------------------end\"); } }); thread3.start(); thread3.join(); out.println(\"\\n main ------------------------ end\"); }} 123456789101112131415 main ------------------------ startt1------------------------ startjava_lock log PID = 55 TID = 140073151424256 java getId 8t1------------------------ endt2------------------------startjava_lock log PID = 55 TID = 140073151424256 java getId 9t2------------------------endt3------------------------startjava_lock log PID = 55 TID = 140073151424256 java getId 10t3------------------------end main ------------------------ end 观察输出，查看线程ID 确实被复用了。","link":"/2019/10/13/Java/pthreadID%E5%A4%8D%E7%94%A8/"},{"title":"static final String 与类的加载与初始化问题","text":"题目 下面的代码会不会导致Student类的加载与初始化？ 1234567891011public class ClassLoadTest { public static void main(String[] args) { System.out.println(Student.final_str); }}class Student { //在编译阶段编译阶段，加入到了类的常量池中,没有直接引用到类，不会触发类的初始化 static final String final_str = \"final world\"; static String str = \"str world\";} 答案是不一定会加载类，但不会初始化，会加载类可以通过 JVM参数 -XX:+TraceClassLoading 得到验证 之前也有刷过这样的题目，run一下代码，还真是，然后看解释，嗯，然后就没有然后了，之前看过的解释是说在编译阶段编译阶段，类的常量池中,没有直接引用到类，不会触发类的初始化。后面也就忘了 所以这次来深入验证一下 这句话 “在编译阶段编译阶段，加入到了类的常量池中”，主要对比 static final String 与 static String 验证 你通过-XX:+TraceClassLoading打印了类的加载信息，居然没有导致加载类？没有加载？类的都没有加载，你怎么访问类的成员呢？？？ 更加有力的说明其实就是在调用方法里面看到 123456789101112131415// access flags 0x9 public static main([Ljava/lang/String;)V L0 LINENUMBER 17 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"final world\" //这里直接加载了一个常量，并没有调用某一个对象，所以灭有加载类 INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L1 LINENUMBER 18 L1 RETURN L2 LOCALVARIABLE args [Ljava/lang/String; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1} 如果是static string的话，会有调用类的信息出来 1234567891011// access flags 0x9 public static main([Ljava/lang/String;)V L0 LINENUMBER 17 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; GETSTATIC com/test/classload/Student.str : Ljava/lang/String; //这里指的那个类 INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L1 LINENUMBER 18 L1 RETURN L2 其实上面已经说明了类的初始化问题，但是我们继续看一下区别 先编译Student 直接查看二进制class 通过反编译 查看字节码，有注释 12345678910111213141516171819202122232425262728293031323334// class version 52.0 (52)// access flags 0x20class com/test/classload/Student { // compiled from: ClassLoadTest.java // access flags 0x18 注意区别 这里直接给了值 final static Ljava/lang/String; final_str = \"final world\" // access flags 0x8 注意区别 这里在类的初始化的时候给值 static Ljava/lang/String; str // access flags 0x0 对象的init方法 &lt;init&gt;()V L0 LINENUMBER 21 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V RETURN L1 LOCALVARIABLE this Lcom/test/classload/Student; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x8 类的init方法，其实这里 static &lt;clinit&gt;()V L0 LINENUMBER 24 L0 LDC \"str world\" //看到没有，这里只有对str的赋值，并没有对 final_str 进行赋值 PUTSTATIC com/test/classload/Student.str : Ljava/lang/String; RETURN MAXSTACK = 1 MAXLOCALS = 0} 只看这里，只能说明区别，没有完全，说明问题，直接看一下原始的二进制 这就涉及到，class文件的格式的的 可以简单的看到，16进制对应的String信息，有我们写的str world，其实就是按照一定的TLV（type length value）格式，进行数据的标识。 具体的格式信息，我们可以借用jclasslib工具来可视化 这就class文件的信息排列顺序 可以看到我们定义字段信息，比如str和final_str，以及自动生成init的方法 注意到了区别，发现final_str是直接指向了常量池的信息的，而str就是空的，只有属性，没有value信息，需要在class init的时候进行赋值，这个也符合上面看到的字节码 可以看到final_str的属性信息和value，就是我们自定义的 final world 以上说明在编译后，final_str在还没有进行类的初始化的时候，就已经有了值，指向了常量池的中的字符串。总结编译的时候，编译器知道 既然是final的，直接在调用放加入了，其实这是一种编译器的优化，不用去调用类的方法，所以才没有导致类的加载，并不是说只要调用了类的final static 就一定没有导致类的初始化，比如通过反射。","link":"/2019/10/21/Java/staticfinalString%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98/"},{"title":"分析 Synchronized 锁的4个状态","text":"1.前言通过JOL查看对象的头信息，Synchronized 关键字锁的状态：无锁、偏向锁、轻量级锁、重量级锁 基于64位 jdk8测试 int pthread_mutex_lock(pthread_mutex_t *mutex);pthread_mutex_lock()返回时，该互斥锁已被锁定。线程调用该函数让互斥锁上锁，如果该互斥锁已被另一个线程锁定和拥有，则调用该线程将阻塞，直到该互斥锁变为可用为止。 对于 Solaris线程，请参见mutex_lock 语法 会阻塞 我们可以从JVM 源码中看到对glibc库调用，操作系统层级的锁 ThreadCritical::ThreadCritical12345678910ThreadCritical::ThreadCritical() { pthread_t self = pthread_self(); if (self != tc_owner) { int ret = pthread_mutex_lock(&amp;tc_mutex); guarantee(ret == 0, \"fatal error with pthread_mutex_lock()\"); assert(tc_count == 0, \"Lock acquired with illegal reentry count.\"); tc_owner = self; } tc_count++;} 这个是底层系统库，我们是看不到源码的，只能自己下载。可以在glibc/nptl/phread_mutex_lock.c里看到实现。 2.验证准备 先通过一个jni调用来获取pthread层面的tidJniTool.java12345678package jnitool;public class JniTool { static { System.loadLibrary(\"jnitools\"); } public native void getThreadID();} 这里jnitool必须在 java.library.path这一jvm变量所指向的路径中，可以通过如下方法获得该变量System.getProperty(“java.library.path”); 生成.h文件，javah -jni jnitool.JniTool打印java线程的pid和tid，jvm层面 12345678910#include \"jnitool_JniTool.h\"#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;JNIEXPORT void JNICALL Java_jnitool_JniTool_getThreadID (JNIEnv * env, jobject obj){ fprintf(stdout,\"java_lock log PID = %d TID = %lu \\n\",getpid(),pthread_self()); fflush(stdout);//刷新，防止错位打印} 使用make编译123456vim makefilelibjnitools.so: gcc -lpthread -fPIC -shared -o libjnitools.so -I /root/jdk1.8.0_221/include/ -I /root/jdk1.8.0_221/include/linux/ ./jnitools.c make 对象头信息 object header 关闭指针压缩 -XX:-UseCompressedOops 关于对象头信息的详情介绍，可以 自己写个工具方法，根据markworld转换出头部信息 123456789101112131415|--------------------------------------------------------------------------------------------------------------|| Object Header (128 bits) ||--------------------------------------------------------------------------------------------------------------|| Mark Word (64 bits) | Klass Word (64 bits) | |--------------------------------------------------------------------------------------------------------------|| unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 | OOP to metadata object | 无锁|----------------------------------------------------------------------|--------|------------------------------|| thread:54 | epoch:2 | unused:1 | age:4 | biased_lock:1 | lock:2 | OOP to metadata object | 偏向锁|----------------------------------------------------------------------|--------|------------------------------|| ptr_to_lock_record:62 | lock:2 | OOP to metadata object | 轻量锁|----------------------------------------------------------------------|--------|------------------------------|| ptr_to_heavyweight_monitor:62 | lock:2 | OOP to metadata object | 重量锁|----------------------------------------------------------------------|--------|------------------------------|| | lock:2 | OOP to metadata object | GC|--------------------------------------------------------------------------------------------------------------| 接受JOL输出，自己写一个转换工具，方便debug 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public void parseHeaderInfo(String printable) { String[] split = printable.replaceAll(\"[|)]\", \"\").split(\"\\n\"); StringBuilder builder = new StringBuilder(); for (int i = 2; i &lt;= 3; i++) { builder.append(split[i].split(\"\\\\(\")[2]); } ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;(Arrays.asList(builder.toString().split(\" \"))); Collections.reverse(strings); builder = new StringBuilder(); for (String string : strings) { builder.append(string); } String markWord = builder.toString(); System.out.println(\"\\n--------START-----------\"); //System.out.println(\"mark world:\"+markWord); String lock = markWord.substring(62); String biased_lock = String.valueOf(markWord.charAt(61)); builder = new StringBuilder(); if (lock.equals(\"01\")) { if (biased_lock.equals(\"0\")) { System.out.println(\"--------无锁-----------\"); System.out.println(\"unused:25:\" + markWord.substring(0, 25)); System.out.println(\"identity_hashcode:31: \" + markWord.substring(25, 56) + \" (Hex:\" + Integer.toHexString(Integer.parseInt(markWord.substring(25, 56), 2)) + \")\"); System.out.println(\"unused:1:\" + markWord.substring(56, 57)); System.out.println(\"age:4:\" + markWord.substring(57, 61)); System.out.println(\"biased_lock:1:\" + markWord.substring(61, 62)); System.out.println(\"lock:2:\" + markWord.substring(62)); } else { System.out.println(\"--------偏向锁--------\"); System.out.println(\"thread:54:\" + markWord.substring(0, 54) +\"(Dex:\"+Long.parseLong(markWord.substring(0, 54), 2)+\")\"); System.out.println(\"epoch:2:\" + markWord.substring(54, 56)); System.out.println(\"unused:1:\" + markWord.substring(56, 57)); System.out.println(\"age:4:\" + markWord.substring(57, 61)); System.out.println(\"biased_lock:1:\" + markWord.substring(61, 62)); } } else { String hexString = Long.toHexString(Long.parseLong(markWord.substring(0, 62), 2)); if (lock.equals(\"00\")) { System.out.println(\"--------轻量级锁--------\"); System.out.println(\"ptr_to_lock_record:62:\" + markWord.substring(0, 62) + \" (Hex:\" + hexString + \")\"); System.out.println(\"lock:2:\" + markWord.substring(62)); } else if (lock.equals(\"10\")) { System.out.println(\"--------重量级锁--------\"); System.out.println(\"ptr_to_heavyweight_monitor::62:\" + markWord.substring(0, 62) + \" (Hex:\" + hexString + \")\"); System.out.println(\"lock:2:\" + markWord.substring(62)); } else if (lock.equals(\"11\")) { System.out.println(\"--------GC标记--------\"); } } System.out.println(\"--------END-----------\\n\"); } 3.无锁 JVM直接优化，进行无锁访问，虽然加了锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import jnitools.JniTools;import org.openjdk.jol.info.ClassLayout;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;public class SyncTest { final Object lock = new Object(); JniTools jniTool = new JniTools(); public static void main(String[] args) throws InterruptedException { SyncTest test = new SyncTest(); test.parseHeaderInfo((ClassLayout.parseInstance(test.lock).toPrintable())); System.out.println(\"---------------------------start--------------------\"); test.start(); } public void start() throws InterruptedException { Runnable runnable = new Runnable() { int count = 0; @Override public void run() { while (true) { if (count &lt; 100) { count++; } else { return; } try { lock(); parseHeaderInfo(ClassLayout.parseInstance(lock).toPrintable()); Thread.sleep(200); } catch (Exception e) { e.printStackTrace(); } } } }; new Thread(runnable).start(); Thread.sleep(5000); new Thread(runnable).start(); } public void lock() { synchronized (lock) { jniTool.getTid(); } }} 分析，虽然有多个线程访问，但是不存在，同时竞争。 log 无锁out.log 12345678910111213141516171819202122232425262728293031323334353637383940414243444546--------START-------------------无锁-----------unused:25:0000000000000000000000000identity_hashcode:31: 0000000000000000000000000000000 (Hex:0)unused:1:0age:4:0000biased_lock:1:0lock:2:01--------END--------------------------------------start--------------------java_lock log-----------PID = 189 TID = 139775743776512 --------START-------------------无锁-----------unused:25:0000000000000000000000000identity_hashcode:31: 0000000000000000000000000000000 (Hex:0)unused:1:0age:4:0000biased_lock:1:0lock:2:01--------END-----------java_lock log-----------PID = 189 TID = 139775743776512 --------START-------------------无锁-----------unused:25:0000000000000000000000000identity_hashcode:31: 0000000000000000000000000000000 (Hex:0)unused:1:0age:4:0000biased_lock:1:0lock:2:01--------END-----------java_lock log-----------PID = 189 TID = 139775743776512 --------START-------------------无锁-----------unused:25:0000000000000000000000000identity_hashcode:31: 0000000000000000000000000000000 (Hex:0)unused:1:0age:4:0001biased_lock:1:0lock:2:01--------END----------- 4 偏向锁 当关闭偏向锁功能时 由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。 一开始就是偏向锁，处于可偏向，谁先来锁，就偏向谁1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import jnitools.JniTools;import org.openjdk.jol.info.ClassLayout;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;public class SyncTest { final Object lock = new Object(); JniTools jniTool = new JniTools(); public static void main(String[] args) throws InterruptedException { Thread.sleep(5000); SyncTest test = new SyncTest(); test.parseHeaderInfo((ClassLayout.parseInstance(test.lock).toPrintable())); System.out.println(\"---------------------------start--------------------\"); test.start(); Thread.sleep(50000); } public void start() throws InterruptedException { Runnable runnable = new Runnable() { @Override public void run() { int count = 0; while (true) { if (count &lt; 50) { count++; } else { System.out.println(\"Thread \"+Thread.currentThread().getName()+\" return \"); return; } try { lock(); parseHeaderInfo(ClassLayout.parseInstance(lock).toPrintable()); // Thread.sleep(100); } catch (Exception e) { e.printStackTrace(); } } } }; new Thread(runnable).start(); Thread.sleep(5000); new Thread(runnable).start(); } public void lock() { synchronized (lock) { jniTool.getTid(); } }} Thread.sleep(5000); 主要在线程启动时候加上了sleep out.log 为了减少JVM启动时初始化时间，JVM默认延时加载偏向锁。大概为4s左右，具体时间因机器而异。当然我们也可以设置JVM参数 -XX:BiasedLockingStartupDelay=0 来取消延时加载偏向锁 你会发现占用 thread 和 epoch 的 位置的均为0，说明当前偏向锁并没有偏向任何线程，此时这个偏向锁正处于可偏向状态。 12345678910111213141516171819202122232425262728293031--------START-------------------偏向锁--------thread:54:000000000000000000000000000000000000000000000000000000(Dex:0)epoch:2:00unused:1:0age:4:0000biased_lock:1:1--------END--------------------------------------start--------------------java_lock log-----------PID = 398 TID = 140630884325120 --------START-------------------偏向锁--------thread:54:000000000000000001111111111001110100010000100001101100(Dex:137335212140)epoch:2:00unused:1:0age:4:0001biased_lock:1:1--------END-----------java_lock log-----------PID = 398 TID = 140630884325120 --------START-------------------偏向锁--------thread:54:000000000000000001111111111001110100010000100001101100(Dex:137335212140)epoch:2:00unused:1:0age:4:0001biased_lock:1:1--------END----------- Thread Thread-1 return 当线程2开始的时候，线程1已结结束了，这里怀疑线程复用，因为这里不满足线程重新偏向，且线程没有重新偏向 偏向的线程没有变化，且pthread的TID的对象头的里的信息都没有变化 12345678910111213141516171819202122java_lock log-----------PID = 398 TID = 140630884325120 --------START-------------------偏向锁--------thread:54:000000000000000001111111111001110100010000100001101100(Dex:137335212140)epoch:2:00unused:1:0age:4:0001biased_lock:1:1--------END-----------Thread Thread-1 return java_lock log-----------PID = 398 TID = 140630884325120 --------START-------------------偏向锁--------thread:54:000000000000000001111111111001110100010000100001101100(Dex:137335212140)epoch:2:00unused:1:0age:4:0001biased_lock:1:1--------END----------- 5 轻量级锁 我们让线程1放锁后，不让线程1退出 让线程2去拿锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 import jnitool.JniTool;import org.openjdk.jol.info.ClassLayout;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;public class SyncTest { final Object lock = new Object(); JniTool jniTool = new JniTool(); public static void main(String[] args) throws InterruptedException { Thread.sleep(5000); SyncTest test = new SyncTest(); test.parseHeaderInfo((ClassLayout.parseInstance(test.lock).toPrintable())); System.out.println(\"---------------------------start--------------------\"); test.start(); } public void start() throws InterruptedException { Runnable runnable = new Runnable() { @Override public void run() { int count = 0; System.out.println(Thread.currentThread().getName() + \" t1 start\"); while (true) { if (count &lt; 50) { count++; } else { return; } lock(); } } }; new Thread(runnable).start(); Thread.sleep(1000);//这里保证退出 new Thread(runnable).start(); } public void lock() { synchronized (lock) { Class&lt;?&gt; aClass = lock.getClass(); jniTool.getThreadID(); parseHeaderInfo(ClassLayout.parseInstance(lock).toPrintable()); } }} 线程1执行的时候，是偏向了线程1的 线程1退出，线程2来的时候，直接升级了轻量级锁 123456789101112131415161718192021java_lock log PID = 61919 TID = 123145379807232 --------START-----------Thread-1--------偏向锁--------thread:54:000000000000000001111111110000101010110100010011100100(Dex:137181742308)epoch:2:00unused:1:0age:4:0000biased_lock:1:1--------END-----------Thread-1Thread-2 t1 startjava_lock log PID = 61919 TID = 123145379807232 --------START-----------Thread-2--------轻量级锁--------ptr_to_lock_record:62:00000000000000000111000000000000000001001001111001111000001110 (Hex:1c0001279e0e)lock:2:00--------END-----------Thread-2java_lock log PID = 61919 TID = 123145379807232 6. 重量级锁 偏向锁直接升级 2个线程，同时并发访问 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import jnitool.JniTool;import org.openjdk.jol.info.ClassLayout;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;public class SyncTest { final Object lock = new Object(); JniTool jniTool = new JniTool(); public static void main(String[] args) throws InterruptedException { Thread.sleep(5000); SyncTest test = new SyncTest(); test.parseHeaderInfo((ClassLayout.parseInstance(test.lock).toPrintable())); System.out.println(\"---------------------------start--------------------\"); test.start(); } public void start() throws InterruptedException { Runnable runnable = new Runnable() { @Override public void run() { int count = 0; System.out.println(Thread.currentThread().getName() + \" t1 start\"); while (true) { if (count &lt; 50) { count++; } else { return; } lock(); } } }; new Thread(runnable).start(); new Thread(runnable).start(); } public void lock() { synchronized (lock) { Class&lt;?&gt; aClass = lock.getClass(); jniTool.getThreadID(); parseHeaderInfo(ClassLayout.parseInstance(lock).toPrintable()); } }} 从可偏向状态，直接升级为重量级锁。 12345678910111213141516171819--------START-----------main--------偏向锁--------thread:54:000000000000000000000000000000000000000000000000000000(Dex:0)epoch:2:00unused:1:0age:4:0000biased_lock:1:1--------END-----------main---------------------------start--------------------Thread-1 t1 startThread-2 t1 startjava_lock log PID = 61884 TID = 123145554096128 --------START-----------Thread-1--------重量级锁--------ptr_to_heavyweight_monitor::62:00000000000000000111111110101101000111010000000110001011010010 (Hex:1feb474062d2)lock:2:10--------END-----------Thread-1 总结 初始状态可能是偏向锁的可偏向状态，也可能是无锁状态 初始锁，若只有一个线程连续的多次访问，构成锁的偏向 不构成锁的重新偏向情况下，后面有多个线程轮流访问，不构成锁的竞争，锁升级到轻量级锁 可以有连续状态，连续锁的升级。","link":"/2019/10/17/Java/synchronized4%E7%A7%8D%E9%94%81/"},{"title":"从ContextClassLoader到JDBC和SPI","text":"SystemClassLoader可以jvm参数 java.system.class.loader 设置默认的系统加载器，默认是当前线程的ContextClassLoader。来自sun.misc.Launcher.getLauncher的getClassLoader, 而getLauncher的getClassLoader实际来自Launcher.AppClassLoader.getAppClassLoader。 ContextClassLoader 主要用于打破双亲模型一个典型的例子就是JDBC，JDBC的规范类是在rt.jar包里面的，默认是由BootstrapClassLoadr加载的，所以JDBC所依赖的类，比如我们自己实现的MYSQL，也应该是由BootstrapClassLoadr来加载，但是我们的MYSQL包路径并不在BootstrapClassLoadr加载的路径当中，这样就会出现找不到类的情况。所以在这种情况下面，我们就需要打破双亲委派模型，ContextClassLoader就应运而生。在BootstrapClassLoadr加载不到的情形下面，由BootstrapClassLoadr转接到当前线程的ContextClassLoader来加载。在SPI场合下都会出现，SPI就是JDK提供接口，具体实现由各个厂商实现，最后由ServiceLoader来进行加载。 SPI的关键，ServiceLoader SPI的具体实现，也就是jar包在service由ServiceLoader的load方法出触发 声明，泛型，且实现了迭代接口 1public final class ServiceLoader&lt;S&gt; implements Iterable&lt;S&gt; 我们可以看一下jdoc里面的描述 A service provider is identified by placing a provider-configuration file in the resource directory META-INF/services. The file’s name is the fully-qualified binary name of the service’s type. The file contains a list of** fully-qualified binary names of concrete provider classes**, one per line. Space and tab characters surrounding each name, as well as blank lines, are ignored. The comment character is ‘#’ (‘\\u0023’, NUMBER SIGN); on each line all characters following the first comment character are ignored. The file must be encoded in UTF-8. 这实际上就描述了，service的接口和具体实现类声明具体位置。 跟踪JDBC加载的过程 首先引入myql和oracle的JDBC包 安装过程中发现maven pom导入失败 mvn 手动安装 1mvn install:install-file -Dfile=/Users/kenchan/ojdbc7-12.1.0.2.jar -DgroupId=oracle -DartifactId=ojdbc7 -Dversion=12.1.0.2 -Dpackaging=jar 接口就是 java.sql.Driver，是JDK实现的规范。 我们可以看到mysql和oracle的jar 包中的service声明 具体的实现类分别是 com.mysql.cj.jdbc.Driver ，oracle.jdbc.OracleDriver类 测试代码，我们用ServiceLoader.load去加载一次java.sql.Driver.class 12345//ServiceLoader服务提供者，加载实现的服务 ServiceLoader&lt;java.sql.Driver&gt; loader = ServiceLoader.load(java.sql.Driver.class); for (java.sql.Driver driver : loader) { System.out.println(\"driver:\" + driver.getClass() + \",loader\" + driver.getClass().getClassLoader()); } 可以看到我们就是把jar包导入环境，什么都没做，就已经显示加载成功了JDBC的2个实现对象 而且可以看到他是由AppClassLoader加载的，但java.sql.Driver是由BoostrapClassLoader加载的。 12driver:class com.mysql.cj.jdbc.Driver,loadersun.misc.Launcher$AppClassLoader@135fbaa4driver:class oracle.jdbc.OracleDriver,loadersun.misc.Launcher$AppClassLoader@135fbaa4 首先可以看到 ** java.util.ServiceLoader#load(java.lang.Class)** 12345//在这里去获取了 ContextClassLoaderpublic static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) { ClassLoader cl = Thread.currentThread().getContextClassLoader(); return ServiceLoader.load(service, cl); } 转接到java.util.ServiceLoader#ServiceLoader(Class svc, ClassLoader cl) 123456private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) { //如果线程 ContextClassLoader 为null，则选用SystemClassLoader，也就是AppClassLoader去加载 loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl; acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null; reload(); } reload()里面是new了一个LazyIterator 就走了。实际加载是使用的时候，及时调用迭代器next获取的时候， 1234567891011public S next() { if (acc == null) { //就是这里 return nextService(); } else { PrivilegedAction&lt;S&gt; action = new PrivilegedAction&lt;S&gt;() { public S run() { return nextService(); } }; return AccessController.doPrivileged(action, acc); } } 在java.util.ServiceLoader.LazyIterator#hasNextService 里面做了扫描，从META-INF/services/里面去读取具体的实现类，保留了nextName 那ServiceLoader怎么知道只加载JDBC呢？其它的service它不加载？？？ 这就是通过String fullName = _PREFIX _+ service.getName();限定来获取的，service.getName() 我们传入的泛型及时service就是java.sql.Driver，也可以从上面看到jar包中的service下的文件名就是接口。 123456789101112131415161718192021222324252627private boolean hasNextService() { if (nextName != null) { return true; } if (configs == null) { try { //熟悉的样子，这里就是从META-INF/services/获取具体的类限定名 String fullName = PREFIX + service.getName(); //这里就是去读到了具体的实现类名称 if (loader == null) configs = ClassLoader.getSystemResources(fullName); else configs = loader.getResources(fullName); } catch (IOException x) { fail(service, \"Error locating configuration files\", x); } } while ((pending == null) || !pending.hasNext()) { if (!configs.hasMoreElements()) { return false; } pending = parse(service, configs.nextElement()); } //比如这里就可能获取到com.mysql.cj.jdbc.Driver nextName = pending.next(); return true; } 转接到 java.util.ServiceLoader.LazyIterator#nextService 里面，这里实际上就是通过反射做了真正的加载 12345678910111213141516171819202122232425262728293031private S nextService() { if (!hasNextService()) throw new NoSuchElementException(); //nextName就是上面获取到的 String cn = nextName; nextName = null; Class&lt;?&gt; c = null; try { //这里反射获取，可以看到用到了loader 就是ContextClassLoader。 c = Class.forName(cn, false, loader); } catch (ClassNotFoundException x) { fail(service, \"Provider \" + cn + \" not found\"); } if (!service.isAssignableFrom(c)) { fail(service, \"Provider \" + cn + \" not a subtype\"); } //通过反射，利用我们自定的ContextClassLoader 做了加载之后，就是利用反射生成一个实例，放到缓里面 try { S p = service.cast(c.newInstance()); providers.put(cn, p); return p; } catch (Throwable x) { fail(service, \"Provider \" + cn + \" could not be instantiated\", x); } throw new Error(); // This cannot happen } 到此，JDBC的实现类加载完毕 我们用JDBC 没有像这样去掉loader啊？？？其实你在用java.sql.DriverManager的时候，java.sql.DriverManager#loadInitialDrivers里面 调用了ServiceLoader.load(Driver.class); 总结 双亲委派模型在SPI机制下面缺陷，不能加载具体的实现类 JDK采用ContextClassLoader可以让我们自定加载器去加载具体的实现类 具体的实现类，归结到反射方法，可以让加载类的时候，指定具体的ClassLoader1public static Class&lt;?&gt; forName(String name, boolean initialize,ClassLoader loader)","link":"/2020/05/29/Java/%E4%BB%8EContextClassLoader%E5%88%B0JDBC%E5%92%8CSPI/"},{"title":"关于修改和代理Final类和方法？","text":"背景cglib是基于继承的代理的，但是final修饰的类的方法不能被代理，毕竟虚拟机规范限定了final关键字，想要实现代理的功能，自己不要加上final就是了。但是现在别人写好了库里的类，不方便修改想要尝试。 1.自定义Classloader，利用ASM去掉final关键字jvm利用双亲委派机制加载类，优先尝试让父类加载，父类加载成功，自己就没有机会加载，这是安全和防止重复加载的机制。默认情况下自己写的class是程序加载器加载的，jvm认为Classloder+类路径名 完全一样才是相同的一个class。所以用自己的加载器加载的类，没法转换成为之前的的引用。想要调用和访问，也只能利用反射。 比如这样是不行的 1Person person = new MyClassLoader（Person.class).newInstance() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class MyClassLoader extends ClassLoader { public MyClassLoader() { //指定父加载器为null super(null); } @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { System.out.println(\"findClass: \"+name); try { ClassReader reader = new ClassReader(name); ClassWriter writer = new ClassWriter(reader, 0); RemoveFinalFlagClassVisitor classVisitor = new RemoveFinalFlagClassVisitor(writer); reader.accept(classVisitor, ClassReader.SKIP_CODE); byte[] bytes = writer.toByteArray(); return defineClass(name, bytes, 0, bytes.length); } catch (IOException e) { e.printStackTrace(); } return null; }}// 利用ClassVisitor去掉final的修饰class RemoveFinalFlagClassVisitor extends ClassVisitor { public RemoveFinalFlagClassVisitor(ClassVisitor cv) { super(Opcodes.ASM5, cv); } @Override public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) { // we have the final flag if((access &amp; Opcodes.ACC_FINAL) == Opcodes.ACC_FINAL) { //remove the final flag access = access ^ Opcodes.ACC_FINAL; }// 在调用super.visit的时候，我们就已经把final关键字去掉了 super.visit(version, access, name, signature, superName, interfaces); } @Override public MethodVisitor visitMethod(int i, String s, String s1, String s2, String[] strings) { /*可以在这里修改final修饰非方法 这里可以利用debug查看修饰的特征值 */ if (i==17){ return super.visitMethod(1, s, s1, s2, strings); } return super.visitMethod(i, s, s1, s2, strings); }} 测试测试类 123456789101112final public class Manager{ private static int AAA = 1; private static int BBB = 2; private static int CCC = 3; final public void testFinal(){ System.out.println(\"test\"); } public void testPublic(){ System.out.println(\"test\"); }} 测试方法 1234567MyClassLoader myClassLoader = new MyClassLoader(); Class&lt;?&gt; aClass = myClassLoader.loadClass(Manager.class.getName()); System.out.println(Modifier.toString(aClass.getModifiers())); Method[] methods = aClass.getDeclaredMethods(); for (Method method : methods) { System.out.println(Modifier.toString(method.getModifiers())); } 测试结果 1234findClass: test.Managerpublicpublicpublic","link":"/2019/09/28/Java/%E5%85%B3%E4%BA%8E%E4%BF%AE%E6%94%B9%E5%92%8C%E4%BB%A3%E7%90%86Final%E7%B1%BB/"},{"title":"仿写一个Java Thread 底层实现","text":"Java里的线程和操作系统的线程是一一对应的，为了方便理解Thread 类的底层实现，我们可以自己来仿造一个MyThread, 同样接受一个Runable接口，调用start实现run方法。 这是要实现的类 1234567public class MyThread { Runnable mRunnable; public MyThread(Runnable runnable) { mRunnable = runnable; } native public void start();} 那么我们先去实现native方法12345678910111213141516171819202122232425#define TAG \"native-lib\" // 这个是自定义的LOG的标识#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,TAG,__VA_ARGS__) // 定义LOGD类型JavaVM *jvm = 0;jclass RunnableClass = NULL;extern \"C\"JNIEXPORT void JNICALLJava_com_test_MyThread_start(JNIEnv *env, jobject thiz) { LOGD(\"java invoke start()---------------start\"); jclass MyThreadClass = env-&gt;FindClass(\"com/test/MyThread\"); RunnableClass = (jclass) env-&gt;NewGlobalRef(env-&gt;FindClass(\"java/lang/Runnable\")); jfieldID runnableID = env-&gt;GetFieldID(MyThreadClass, \"mRunnable\", \"Ljava/lang/Runnable;\"); jobject mRunnable = env-&gt;NewGlobalRef(env-&gt;GetObjectField(thiz, runnableID)); pthread_t tid; int ret_t = -1; ret_t = pthread_create(&amp;tid, NULL, new_thread, mRunnable); pthread_detach(tid); if (ret_t != 0) { printf(\"pthread_create error \\n\"); return; } LOGD(\"java invoke start()---------------end\"); return;} java 调用了start方法进入 c 层面，接下来 主要是通过pthread创建新线程，在新线程里面反调java里面的run方法。 新建的线程 void *new_thread(void *arg)123456789101112131415161718void *new_thread(void *arg) { LOGD(\"new_thread-----------------\"); JNIEnv *env; jobject mRunnable = static_cast&lt;jobject&gt;(arg); LOGD(\"new_thread-----------------AttachCurrentThread()\"); //将当前线程注册到虚拟机中 jvm-&gt;AttachCurrentThread(&amp;env, NULL); jmethodID run = NULL; LOGD(\"new_thread-----------------GetMethodID\"); // 拿到run方法 run = env-&gt;GetMethodID(RunnableClass, \"run\", \"()V\"); LOGD(\"new_thread-----------------CallVoidMethod\"); env-&gt;CallVoidMethod(mRunnable, run); env-&gt;DeleteGlobalRef(mRunnable); LOGD(\"new_thread-----------------end\"); //返回值一定要 return nullptr;} 加载库的时候做一下初始化1234567891011/*加载库的时候，初始化JavaVM对象，全局复用*/jint JNI_OnLoad(JavaVM *vm, void *reserved) { JNIEnv *env; if (JNI_OK != vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6)) { printf(\"JNI_OnLoad error \\n\"); return -1; } jvm = vm; LOGD(\"JNI_OnLoad-----------------------------------\"); return JNI_VERSION_1_6;} 最后在java 里面加载so文件1234567891011121314public class MyThread { Runnable mRunnable; static { System.loadLibrary(\"native-lib\"); System.out.println(\"load native-lib\"); } public MyThread(Runnable runnable) { mRunnable = runnable; } native public void start();} 测试123456new MyThread(new Runnable() { @Override public void run() { System.out.println(\"Hello World!\"); } }).start(); 结果12345678910D/native-lib: JNI_OnLoad-----------------------------------I/System.out: load native-libD/native-lib: java invoke start()---------------start java invoke start()---------------endD/native-lib: new_thread----------------- new_thread-----------------AttachCurrentThread() new_thread-----------------GetMethodID new_thread-----------------CallVoidMethodI/System.out: Hello World!D/native-lib: new_thread-----------------end","link":"/2019/09/24/Java/%E4%BB%BF%E5%86%99%E4%B8%80%E4%B8%AAJavaThread%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"title":"如何定位CPU占用最高的代码块?","text":"1. 先利用top查看 占用较高的进程 2 。利用 top -Hp pid 或 ps H -p pid -o pid,tid,pmem,pcpu,time,comm。查看某个进程中的线程占用CPU的情况。 3. 利用jstack pid 对应某个线程，注意 jstack 中的 nid 是16进制的，注意转换。 4.可以在线程启动的时候，设置线程的name，方便快速定位。","link":"/2019/11/08/Java/%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8DCPU%E5%8D%A0%E7%94%A8%E6%9C%80%E9%AB%98%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97/"},{"title":"匿名内部类为什么要是final?","text":"1. java 是引用传参。在里面是修改不了的。 Java8 1234567891011121314151617181920212223242526272829303132public class FinalTest { public static void changeStr(String string){ string = \"BBBB\"; } public static void testInterface(TestInterface testInterface){ testInterface.say(); } public static void main(String[] args) { String string = \"AAAA\"; //这个是改不了的 changeStr(string); System.out.println(string); testInterface(new TestInterface() { @Override public void say() { /* 如果可以,这个改得了吗？ string = \"CCCCC\"; */ System.out.println(string); } }); }}interface TestInterface{ void say();} 2.如果在匿名内部内里面 可以修改？ 你觉是改了外部类的引用，还是没改呢？按写代码的思路，你可能认为给改了，因为这不是方法的传参。但实际上呢？会产生歧义。 3.匿名内部类引用外部变量 实际上是拷贝的引用。同方法的传参。java为了保持数据的一致性。不让在内部类里面修改。因为编译阶段就处理了，匿名内部类因引用的外部变量，在匿名对象构造时候，以构造参数形式传入的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// class version 52.0 (52)// access flags 0x21public class test/FinalTest { // compiled from: FinalTest.java // access flags 0x8 static INNERCLASS test/FinalTest$1 null null // access flags 0x1 public &lt;init&gt;()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V RETURN L1 LOCALVARIABLE this Ltest/FinalTest; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x9 public static changeStr(Ljava/lang/String;)V L0 LINENUMBER 6 L0 LDC \"BBBB\" ASTORE 0 L1 LINENUMBER 7 L1 RETURN L2 LOCALVARIABLE string Ljava/lang/String; L0 L2 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x9 public static testInterface(Ltest/TestInterface;)V L0 LINENUMBER 10 L0 ALOAD 0 INVOKEINTERFACE test/TestInterface.say ()V (itf) L1 LINENUMBER 11 L1 RETURN L2 LOCALVARIABLE testInterface Ltest/TestInterface; L0 L2 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x9 public static main([Ljava/lang/String;)V L0 LINENUMBER 13 L0 LDC \"AAAA\" ASTORE 1 L1 LINENUMBER 15 L1 ALOAD 1 INVOKESTATIC test/FinalTest.changeStr (Ljava/lang/String;)V L2 LINENUMBER 16 L2 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ALOAD 1 INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L3 LINENUMBER 18 L3 NEW test/FinalTest$1 DUP ALOAD 1 //看这里，看这里 &lt;init&gt; 方法多了一个String // 匿名内部类因引用的外部变量，在匿名对象构造时候，以构造参数形式传入的 INVOKESPECIAL test/FinalTest$1.&lt;init&gt; (Ljava/lang/String;)V INVOKESTATIC test/FinalTest.testInterface (Ltest/TestInterface;)V L4 LINENUMBER 28 L4 RETURN L5 LOCALVARIABLE args [Ljava/lang/String; L0 L5 0 LOCALVARIABLE string Ljava/lang/String; L1 L5 1 MAXSTACK = 3 MAXLOCALS = 2} 4.为什么？ 因为匿名内部类 引用外部类的变量 是隐式的类似方法的传参。关键是隐式的处理，若果可以改，必定是改不了外部引用的，防止产生歧义。为什么Java8 不需要加final？只是语法糖，内部类里面照样不能修改引用，修改导致编译不过的。**","link":"/2019/12/27/Java/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%98%AFFinal/"},{"title":"类加载器之间的关系","text":"本次我们主要讨论子类和父类的类加载器之前的关系, 以及包含之前的类加载器关系。我们自定义一个classloder，设置父加载器为null，这样保证都是自己来加载，指向的路径和AppClassloader一致，这样方便2个都好直接加载 继承关系12345class MyAnimal { public MyAnimal() { System.out.println(\"MyAnimal by load \" + MyAnimal.class.getClassLoader()); }} 12345class MyDog extends MyAnimal{ public MyDog() { System.out.println(\"MyDog by Load \" + MyDog.class.getClassLoader()); }} 123456789public static void main(String[] args) throws Exception { MyCustomClassLoader loader = new MyCustomClassLoader();//自定加载类 loader.setPath(\"/Users/kenchan/GitHub/jvm_study/target/classes/\"); Class&lt;?&gt; myDog = loader.loadClass(\"com.test.classload.MyDog\");//加载 Constructor&lt;?&gt; constructor = myDog.getConstructor();//实列化 constructor.setAccessible(true); Object o = constructor.newInstance(); } 输出 1234findClass,自定义类加载器加载了指定的类findClass,自定义类加载器加载了指定的类MyAnimal by load com.test.classload.MyCustomClassLoader@4b67cf4dMyDog by Load com.test.classload.MyCustomClassLoader@4b67cf4d 可以看到MyDog引发MyAnimal的类加载，同时也用了MyDog的加载器 从调用栈来看，在MyDog类被加载的时候，native defineClass1 阶段，native code直接回调到Dog的加载器 MyCustomClassLoader来尝试加载MyDog的父类 1234567891011findClass:34, MyCustomClassLoader (com.test.classload) [2]//MyCustomClassLoader加载父类MyAnimalloadClass:424, ClassLoader (java.lang)loadClass:357, ClassLoader (java.lang)//native define 引发加载父类MyAnimal的加载，从这里放回的就是MyCustomClassLoader了defineClass1:-1, ClassLoader (java.lang)defineClass:763, ClassLoader (java.lang)defineClass:642, ClassLoader (java.lang)findClass:36, MyCustomClassLoader (com.test.classload) [1]//首先加载DogloadClass:424, ClassLoader (java.lang)loadClass:357, ClassLoader (java.lang)main:15, 疑问1，假如MyAnimal提前被AppClassloder加载了呢？123456789101112public static void main(String[] args) throws Exception { MyCustomClassLoader loader = new MyCustomClassLoader(); loader.setPath(\"/Users/kenchan/GitHub/jvm_study/target/classes/\"); Class&lt;?&gt; myDog = loader.loadClass(\"com.test.classload.MyDog\"); //提前触发一下 MyAnimal类的加载，这里默认是用的AppClassloder Class&lt;?&gt; myAnimal = Class.forName(\"com.test.classload.MyAnimal\");//只是声明，并没有引发类的加载; myAnimal.newInstance();//引发类的加载 Constructor&lt;?&gt; constructor = myDog.getConstructor();//实列化 constructor.setAccessible(true); Object o = constructor.newInstance();} 查看输出，这里可以看到我们提前用了AppClassLoader 加载了一次 MyAnimal ，但是后面还是得被MyCustomClassLoader 加载了一次 12345findClass,自定义类加载器加载了指定的类findClass,自定义类加载器加载了指定的类MyAnimal by load sun.misc.Launcher$AppClassLoader@135fbaa4MyAnimal by load com.test.classload.MyCustomClassLoader@4b67cf4dMyDog by Load com.test.classload.MyCustomClassLoader@4b67cf4d 疑问2 ，假如MyAnimal提前被MyCustomClassLoader加载了呢？ 我们修改都用MyCustomClassLoader加载一次 12Class&lt;?&gt; myDog = loader.loadClass(\"com.test.classload.MyDog\");Class&lt;?&gt; myAnimal = loader.loadClass(\"com.test.classload.MyAnimal\");//只是声明，并没有引发类的加载; 看输出，都是只会加载一次的 1234findClass,自定义类加载器加载了指定的类findClass,自定义类加载器加载了指定的类MyAnimal by load com.test.classload.MyCustomClassLoader@4b67cf4dMyDog by Load com.test.classload.MyCustomClassLoader@4b67cf4d JVM认为类的不同，是根据加载器和类全名来判断的，类之间的加载器不同，包名同，是属于不同的命名空间里，所以一个Anmial类可以被同时被不同的类加载器加载一次。而不同命名空间里的类在使用某个类的时候，发现并没有加载，就会使用该命名空间的类加载器去加载。 包含关系 如果我们把MyDog改成这样 123456class MyDog { public MyDog() { System.out.println(\"MyDog by Load \" + MyDog.class.getClassLoader()); new MyAnimal(); }} 同理，在我们实例化MyAnimal()时候，都是先用调用方MyDog的类加载器去加载，MyDog我们设置的父加载器不为空的，继续交给父加载器去加载。通常情况下我们写的都是由AppClassloder去加载的，都在一个命名空间下面。 父加载器会反过来用子加载器比如我们在父加载器中去访问子加载器加载的类 让Dog 包含 Anmial 123456public class MyDog { public MyDog() { System.out.println(\"MyDog by Load \" + MyDog.class.getClassLoader()); new MyAnimal(); }} 让Anmial去访问一下Dog 123456public class MyAnimal { public MyAnimal() { System.out.println(\"MyAnimal by load \" + MyAnimal.class.getClassLoader()); System.out.println(\"MyAnimal:MyDog lode by \"+MyDog.class.getClassLoader()); }} 这样在我们直接初始化Dog的时候，会触发MyAnmial去访问Dog类 我们直接移动一下编译好的Dog.class 让Dog使用自定义的类加载器，让Anmial使用使用AppClassLoder 12345678public static void main(String[] args) throws Exception { MyCustomClassLoader loader = new MyCustomClassLoader(); loader.setPath(\"/Users/kenchan/GitHub/jvm_study/target/out/\"); Class&lt;?&gt; myDog = loader.loadClass(\"com.test.classload.MyDog\"); Constructor&lt;?&gt; constructor = myDog.getConstructor();//实列化 constructor.setAccessible(true); Object o = constructor.newInstance(); } 我们可以看到明明加载了MyDog类，却在Anmail打印System.out.println(&quot;MyAnimal:MyDog lode by &quot;+MyDog.class.getClassLoader());是抛错说找不到类 实际上的错误是由于AppClassLoader是访问不到它的子加载器加载的类的，属于不同的命名空间。AppClassLoder尝试自己去加载MyDog，结果没有找到。 举个继承的例子就是如果，子类是自定义加载器才能加载，父类通过AppClassloder才能加载，那么如果父类又引用了之类的话，父类的加载器AppClassloder是加载不了子类的。 结论类加载器，及其父加载器共同构成一个命名空间，但父类命名空间不能反过来访问子加载器加载的类，子加载器是可以访问父加载器加载的类,子加载器的父加载器是一个，但是父加载器的子加载器是可能有多个的，所以由谁触发的加载，谁可以一直想上追，追不到就自己，但是上面的却不能向下追，因为下面有多个，不知道追谁。当加载某一个类的时候，会调用当前的命名空间的子加载器，然后采用双亲委派机制上交给父加载器加载。我们也是可以做到 MyDog 是自定义加载器，MyAnimal是AppClassloder的，只要不打破双亲委派机制。在不打破双亲委派基础下，各个加载器之前的关系如下： 优先逐个交给最里面的加载器来做 里面的做不了，外面再来做 外面可以访问里面的加载的类 里面却不能访问外面的加载器加载的类","link":"/2019/10/25/Java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B9%8B%E5%89%8D%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"title":"记一次类加载引起的Bug","text":"1.起因程序莫名其妙出了 error:java.lang.NullPointerException: Null reference used for synchronization (monitor-enter）就是在使用同步锁的时候，是锁的对象是空的。很是奇怪，看代码没觉得啊。打印一下，确实是空的，Why？ 2. 代码，看出问题？代码逻辑简化如下: 12345678910111213141516171819202122public class SynTest { public static void main(String[] args) { System.out.println(LockInstance.string); }}class LockInstance { public static String string = getString(); private static byte[] sLock = new byte[0]; public static LockInstance getInstance() { synchronized (sLock){ return new LockInstance(); } } private static String getString(){ return LockInstance.getInstance().getApplicationContext(); } public String getApplicationContext() { return \"string\"; }} 没问题啊？ 猜一下结果输出？出错拉！！ 1234567Exception in thread \"main\" java.lang.ExceptionInInitializerError at SynTest.main(SynTest.java:3)Caused by: java.lang.NullPointerException at LockInstance.getInstance(SynTest.java:11) at LockInstance.getString(SynTest.java:16) at LockInstance.&lt;clinit&gt;(SynTest.java:8) ... 1 more 3 为什么？本质上是没有理解类加载的过程导致出错的。来理一下思路首先在第一次调用 LockInstane 的静态方法的时候，类会进行初始化。那么类的初始化是有一个过程的。按声明的静态变量进行初始化，再是类的静态块，最后再是执行调用的静态方法。按上面的代码，问题错在 类初始化的时候，由于静态的成员变量调用了静态方法进行初始化，但是在里面用的变量却还没来得及初始化。 4 解决办法如果类的成员变量的初始化需要用到类的成员变量，请保证在这之前已经用到的变量已经初始化了。 修改方法，放到前面就可以了。 12private static byte[] sLock = new byte[0];public static String string = getString(); 测试运行成功。","link":"/2020/04/18/Java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%BC%95%E8%B5%B7%E7%9A%84Bug/"},{"title":"把数字翻译成字符串","text":"给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 示例 1: 输入: 12258输出: 5 解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi” 提示： 0 &lt;= num &lt; 231 DFS从后面向前面找1234567891011121314151617181920class Solution { //从后面的数字向前找 public int translateNum(int num) { //只有一种可能 if (num &lt;= 9) { return 1; } //先判断以后面2个数字 int last2num = num % 100; //后面2位数字只能有一种,就是单个数字一种，那就取单个数字 if (last2num&lt;=9||last2num&gt;=26){ return translateNum(num / 10); }else{ // 后面2个数字，可以单独一种，也可以合成。所以相加 return translateNum(num / 10) + translateNum(num / 100); } }}","link":"/2020/04/30/LeetCode/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/"},{"title":"区分Kotlin中的 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;","text":"测试代码12345678fun main() { val list1 = mutableListOf&lt;String&gt;() val list2 = mutableListOf&lt;String&gt;() list1.add(\"sss\") list2.add(\"sss\") println(list1 == list2) println(list1 === list2)} 测试输出 12truefalse 我们可以点击跳转看到，== 在kotlin中是一个被重载了的操作符合点击跳转实现 ，等价于调用object的equals 函数而 === 不能直接跳转。我们通过反编译成字节码再编反译成java，=== 等价于 java 中的==，比较的是地址， ==在kotlin中是Intrinsics.areEqual方法。https://asmsupport.github.io/doc/0.4/jvmref/ref-if_acmpne.html === 等号中含有IF_ACMPNE知冷暖方便查看，可以再反编译成java，查看 1234567891011121314public static final void main() { boolean var1 = false; List list1 = (List)(new ArrayList()); boolean var2 = false; List list2 = (List)(new ArrayList()); list1.add(\"sss\"); list2.add(\"sss\"); var2 = Intrinsics.areEqual(list1, list2); boolean var3 = false; System.out.println(var2); var2 = list1 == list2; var3 = false; System.out.println(var2);} 一般Intrinsics.areEqual的实现是判断内容相等，=== 判断的是地址相等 总结在kotlin中 ，== 被重载为equals，判断的是内容相同就相等。=== 判断的是地址相等","link":"/2021/08/21/Kotlin/kotlin-equal-java/"},{"title":"把数组排成最小的数","text":"输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 示例 1: 输入: [10,2]输出: “102&quot; 示例 2: 输入: [3,30,34,5,9]输出: “3033459&quot; 提示: 0 &lt; nums.length &lt;= 100 说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数 拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0 123456789101112131415161718192021222324252627class Solution { public String minNumber(int[] nums) { NumNode[] numNode = new NumNode[nums.length]; for (int i = 0; i &lt; nums.length; i++) { numNode[i] = new NumNode(nums[i] + \"\"); } Arrays.sort(numNode); //流 比较优雅，但却不是最快 //return Arrays.stream(numNode).map(i -&gt; i.string).collect(Collectors.joining(\"\")); StringBuffer buffer = new StringBuffer(); for (NumNode node : numNode) { buffer.append(node.string); } return buffer.toString(); } class NumNode implements Comparable&lt;NumNode&gt;{ public NumNode(String string) { this.string = string; } public String string; @Override public int compareTo(NumNode o) { return (int) (Long.parseLong(string + o.string) - Long.parseLong(o.string + string)); } }}","link":"/2020/04/27/LeetCode/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/"},{"title":"Kotlin on JVM 协程的可重入实现","text":"1. 协程？协程的优势就是上下文切换的优势，不用打扰到操作系统。用户自己实现协程的切换。协程可以主动让出线程的能力，让Runtime进行调度。而面对线程而言，通常不是主动让出的，而是被操作系统强制调度。操作系统是感知不到Runtime层面的协程的，也不关心是不是正在进行协程调度。线程的现场信息由操作系统维护，协程的现场信息由Runtime来维护。 Kotlin on JVM 的“协程”，不是真正意义上的协程 ？ 效果上，比在Java线程池的的Runable基础上面，Runable 不具备暂停调度可恢复的特性。Runable从开始到结束一直占用当前线程，不管是runing还是wait，而Kotlin在协程”wait“的时候，会释放当前线程。 2. 协程的创建和执行过程写个协程来测试，Example1 添加 jvm参数 -Dkotlinx.coroutines.debug 打印线程信息的时候可以看到协程和线程的关系 123456789suspend fun test(){ val job = GlobalScope.launch { delay(2000) printThreadInfo() delay(2000) printThreadInfo() } Thread.sleep(10000)} 输出 12DefaultDispatcher-worker-1 @coroutine#1DefaultDispatcher-worker-1 @coroutine#1 看这个线程名称，有没有联想到了线程池？ 协程的分发 可以通过跟踪调用链发现 Schduler 的结构 两个都是全局队列，区别只是一个负责CPU密集Task，一个负责IO密集Task 全局队列之外，每个线程自己还有一个私有队列 vmMain/scheduling/CoroutineScheduler.kt:383 123456789101112131415161718192021222324252627fun dispatch(block: Runnable, taskContext: TaskContext = NonBlockingContext, tailDispatch: Boolean = false) { trackTask() // this is needed for virtual time support // 包装成Task,Task实际上继承Runable val task = createTask(block, taskContext) // try to submit the task to the local queue and act depending on the result val currentWorker = currentWorker() // 优先提交到当前Worker，当前Worker 可能是null，提交里面直接return val notAdded = currentWorker.submitToLocalQueue(task, tailDispatch) if (notAdded != null) { //然后尝试把Task提交GlobalQueue if (!addToGlobalQueue(notAdded)) { // Global queue is closed in the last step of close/shutdown -- no more tasks should be accepted throw RejectedExecutionException(\"$schedulerName was terminated\") } } val skipUnpark = tailDispatch &amp;&amp; currentWorker != null // Checking 'task' instead of 'notAdded' is completely okay if (task.mode == TASK_NON_BLOCKING) { if (skipUnpark) return // 里面会先尝试去parkedWorkers拿线程，拿不到就创建 signalCpuWork() } else { // Increment blocking tasks anyway signalBlockingWork(skipUnpark = skipUnpark) }} 多个线程提交Task到Queue的并发锁问题，由Queue保证 创建woker线程之后，启动woker线程 这里启动woker实际上是一个while，while里面不停的去获取Task执行Task，没有Task就park，和Hanlder里面loop很像。 jvmMain/scheduling/CoroutineScheduler.kt:670 123456789101112131415161718192021222324252627282930313233343536 private fun runWorker() { var rescanned = false while (!isTerminated &amp;&amp; state != WorkerState.TERMINATED) { // 这里去拿Task val task = findTask(mayHaveLocalTasks) // 拿到了就去执行 ，然后重复循环 if (task != null) { rescanned = false minDelayUntilStealableTaskNs = 0L executeTask(task) continue } else { mayHaveLocalTasks = false } // 这里先尝试了park minDelayUntilStealableTaskNs ，然后把 // minDelayUntilStealableTaskNs = 0 // 主要是 存在正在窃取的任务，还没窃取完成 if (minDelayUntilStealableTaskNs != 0L) { if (!rescanned) { rescanned = true } else { rescanned = false tryReleaseCpu(WorkerState.PARKING) interrupted() LockSupport.parkNanos(minDelayUntilStealableTaskNs) minDelayUntilStealableTaskNs = 0L } continue } //开始park，然后等待唤醒 tryPark() } tryReleaseCpu(WorkerState.TERMINATED) } 再看一怎么findTask的？ 12345678910111213141516171819202122232425262728fun findTask(scanLocalQueue: Boolean): Task? { if (tryAcquireCpuPermit()) return findAnyTask(scanLocalQueue) // If we can't acquire a CPU permit -- attempt to find blocking task val task = if (scanLocalQueue) { // localQueue.poll() ?: globalBlockingQueue.removeFirstOrNull() } else { globalBlockingQueue.removeFirstOrNull() } return task ?: trySteal(blockingOnly = true)}private fun findAnyTask(scanLocalQueue: Boolean): Task? { /* * Anti-starvation mechanism: probabilistically poll either local * or global queue to ensure progress for both external and internal tasks. */ if (scanLocalQueue) { val globalFirst = nextInt(2 * corePoolSize) == 0 if (globalFirst) pollGlobalQueues()?.let { return it } localQueue.poll()?.let { return it } if (!globalFirst) pollGlobalQueues()?.let { return it } } else { pollGlobalQueues()?.let { return it } } return trySteal(blockingOnly = false)} tryAcquireCpuPermit()尝试当前是不是占有CPU控制权，有的话就看全局Task队列和私有Task队列哪个优先级更高，哪个高就从哪个取任务 如果没有CPU使用权，那么优先看本地队列是不是有任务，没有的话再去取全局的IO密集型任务。 如果都没拿到任务的话，最后会通过 trySteal() 尝试去偷别的woker线程的任务 这里可以清楚了协程的分发流程，实际上是线程池 总结： 新启动一个协程，通过scheduler 的 dispatch 分发，包装成一个Task，如果是当前woker线程，则直接加入到当前Woker线程的Task队列里面去，如果当前Woker线程是null，加入到global队列中，并判断线程池参数来是否启动一个新的woker，是不是可以从pakedWoker线程队列里面唤醒一个woker。 Woker 线程一旦启动之后就是 在一个死循环 runwoker中，不断的去findTask来执行，findTask优先从自己线程的Task队列拿，然后全局的Task队列，最后还可以去“偷”其他woker的Task。没有新的Task就会park住当前线程，放入pakerWoker线程队列里面，等待下次有新的唤醒。 3.Kotlin on JVM 协程的可重入性 协程重入？Example2 123456789 GlobalScope.launch { printThreadInfo() delay(5000) printThreadInfo() } sleep(1000) GlobalScope.launch { printThreadInfo() } 输出信息 123DefaultDispatcher-worker-1 @coroutine#1DefaultDispatcher-worker-1 @coroutine#2DefaultDispatcher-worker-1 @coroutine#1 可以看到创建的2个协程都在线程worker-1，协程1在线程1上执行了一下，然后让出了线程，接着协程2获得线程执行，最后协程1重新获得线程执行。 嗯？？？,这种“调度”机制是怎么实现的？一个协程的暂停和恢复是怎么实现的？？？ 协程的生命周期 实际上Kotlin JVM Coroutine 的运行依赖于各种 Callback 机制 CPS（Continuation-Passing-Style, 续体传递风格） 函数通过回调传递结果 一般的写法 12345678class Test { public static long plus(int i1, int i2) { return i1 + i2; } public static void main(String[] args) { System.out.println(plus(1, 2)); }} CPS 写法 1234567891011class Test { interface Continuation { void next(int result); } public static void plus(int i1, int i2, Continuation continuation) { continuation.next(i1 + i2); } public static void main(String[] args) { plus(1, 2, result -&gt; System.out.println(result)); }} Kotlin Continuation 接口 1234567891011public interface Continuation; { /** * The context of the coroutine that corresponds to this continuation. */ public val context: CoroutineContext /** * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the * return value of the last suspension point. */ public fun resumeWith(result: Resultlt)} 每次切出去到 suspend 状态，再进入 running 状态都是通过 resumeWith 接口 Coroutine 实现了 Job,Continuation，CoroutineScope 接口 123456789public abstract class AbstractCoroutine;( /** * The context of the parent coroutine. */ @JvmField protected val parentContext: CoroutineContext, active: Boolean = true) : JobSupport(active), Job, Continuation&amp;lt;, CoroutineScope { // 省略 Kotlin Coroutine —&gt; Java 反编译 对Example1做反编译，看下字节码的层面 12345678910 public static final Object test(Continuation&amp;lt;? super Unit&amp;gt; $completion) { Job launch$default = BuildersKt__Builders_commonKt.launch$default(GlobalScope.INSTANCE, (CoroutineContext) null, (CoroutineStart) null, new KotlinCodeKt$test$job$1((Continuation) null), 3, (Object) null); Thread.sleep(10000); return Unit.INSTANCE; } public static final void printThreadInfo() { Thread currentThread = Thread.currentThread(); Intrinsics.checkExpressionValueIsNotNull(currentThread, &amp;quot;Thread.currentThread()&amp;quot;); System.out.println(currentThread.getName()); } Kotlin 函数 生成了一个 匿名函数 KotlinCodeKt$test$job$1 继承了 SuspendLambda 而 SuspendLambda &lt;—- ContinuationImpl &lt;—- BaseContinuationImpl &lt;—-Continuation 也就是说我们写的代码，被编译器包装成了一个 Continuation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596final class KotlinCodeKt$test$job$1 extends SuspendLambda implements Function2&amp;lt;CoroutineScope, Continuation&amp;lt;? super Unit&amp;gt;, Object&amp;gt; { Object L$0; int label; private CoroutineScope p$; KotlinCodeKt$test$job$1(Continuation continuation) { super(2, continuation); } public final Continuation&amp;lt;Unit&amp;gt; create(Object obj, Continuation&amp;lt;?&amp;gt; continuation) { Intrinsics.checkParameterIsNotNull(continuation, &amp;quot;completion&amp;quot;); KotlinCodeKt$test$job$1 kotlinCodeKt$test$job$1 = new KotlinCodeKt$test$job$1(continuation); CoroutineScope coroutineScope = (CoroutineScope) obj; kotlinCodeKt$test$job$1.p$ = (CoroutineScope) obj; return kotlinCodeKt$test$job$1; } public final Object invoke(Object obj, Object obj2) { return ((KotlinCodeKt$test$job$1) create(obj, (Continuation) obj2)).invokeSuspend(Unit.INSTANCE); } // 调用 resumeWith() 恢复协程调用的方法，它里面的逻辑，是调用invokeSuspend() 这个方法内部就是我们自己写的协程任务的代码 // return coroutine_suspended 表示协程挂起了 public final Object invokeSuspend(Object $result) { CoroutineScope $this$launch; Object coroutine_suspended = IntrinsicsKt.getCOROUTINE_SUSPENDED(); int i = this.label; if (i == 0) { ResultKt.throwOnFailure($result); $this$launch = this.p$; this.L$0 = $this$launch; this.label = 1; //调用我们写的代码片段 if (DelayKt.delay(2000, this) == coroutine_suspended) { return coroutine_suspended; } } else if (i == 1) { $this$launch = (CoroutineScope) this.L$0; ResultKt.throwOnFailure($result); } else if (i == 2) { CoroutineScope $this$launch2 = (CoroutineScope) this.L$0; ResultKt.throwOnFailure($result); KotlinCodeKt.printThreadInfo(); return Unit.INSTANCE; } else { throw new IllegalStateException(&amp;quot;call to &amp;#39;resume&amp;#39; before &amp;#39;invoke&amp;#39; with coroutine&amp;quot;); } //调用我们写的代码片段 KotlinCodeKt.printThreadInfo(); this.L$0 = $this$launch; this.label = 2; //调用我们写的代码片段 // 这里实际上就 达到dealy 的效果，postDelayed(Time=2000，Runnable = this) // 让this Runable 获得再次调度的机会 // 这里是非阻塞的 if (DelayKt.delay(2000, this) == coroutine_suspended) { return coroutine_suspended; } CoroutineScope coroutineScope = $this$launch; //调用我们写的代码片段 KotlinCodeKt.printThreadInfo(); return Unit.INSTANCE; }}public final override fun resumeWith(result: Result&amp;lt;Any?&amp;gt;) { // This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume var current = this var param = result while (true) { // Invoke &amp;quot;resume&amp;quot; debug probe on every resumed continuation, so that a debugging library infrastructure // can precisely track what part of suspended callstack was already resumed probeCoroutineResumed(current) with(current) { val completion = completion!! // fail fast when trying to resume continuation without completion val outcome: Result&amp;lt;Any?&amp;gt; = try { val outcome = invokeSuspend(param) // 如果是SUSPENDED则直接return这次resume if (outcome === COROUTINE_SUSPENDED) return Result.success(outcome) } catch (exception: Throwable) { Result.failure(exception) } releaseIntercepted() // this state machine instance is terminating if (completion is BaseContinuationImpl) { // unrolling recursion via loop current = completion param = outcome } else { // top-level completion reached -- invoke and return completion.resumeWith(outcome) return } } } } 通过关键词结合编译期我们自己写的协程代码进行包装成 Continuation 对象，实际就是对代码进行了分片，在执行和唤醒的粒度就是代码片 Kotlin on JVM 协程本质是通过编译分片和状态机来实现，没有协程的现场恢复和保留的过程。 dealy暂停，实际上是return了，dealy的时间实际上是通过 postDelayed(Time，_Runnable)来实现，但是_postDelay并不是post到scheduler里面的Task队列里面的。 Dealy 2s 又是怎么实现的？？？ 1DelayKt.delay(2000, this) 联系到handler ，涉及到延时的，肯定是有序的，怎么实现时间有序？ 实际是 包装成了一个 DelayedResumeTask ,等时间到了，最后调用task.run 还是 走到了上面的scheduler的dispatch流程。 1234567private inner class DelayedResumeTask( nanoTime: Long, private val cont: CancellableContinuation&lt;Unit&gt;) : DelayedTask(nanoTime) { override fun run() { with(cont) { resumeUndispatched(Unit) } } override fun toString(): String = super.toString() + cont.toString()} 延迟2秒是怎么实现的？？？ 我们写的dalay首先直接会调到 123456789101112131415public suspend fun delay(timeMillis: Long) { if (timeMillis &lt;= 0) return // don't delay return suspendCancellableCoroutine sc@ { cont: CancellableContinuation&lt;Unit&gt; -&gt; // 这里获取了context.delay cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont) }}// 实际上获取了 DefaultDelay internal val CoroutineContext.delay: Delay get() = get(ContinuationInterceptor) as? Delay ?: DefaultDelay// DefaultDelay 就是 DefaultExecutorinternal actual val DefaultDelay: Delay = DefaultExecutor 也就是说dealy的时候和 DefaultExecutor挂钩了 然后 dealy方法 会先调到 EventLoop.common.kt:370 123456789private fun scheduleImpl(now: Long, delayedTask: DelayedTask): Int { if (isCompleted) return SCHEDULE_COMPLETED val delayedQueue = _delayed.value ?: run { _delayed.compareAndSet(null, DelayedTaskQueue(now)) _delayed.value!! } //这里可以看 delayedQueue = _delayed实际上是DelayedTaskQueue return delayedTask.scheduleTask(now, delayedQueue, this)} DelayedTaskQueue 继承了ThreadSafeHeap 继续跟踪 scheduleTask，实际上走到commonMain/internal/ThreadSafeHeap.kt:64，添加到最后 12345678public inline fun addLastIf(node: T, cond: (T?) -&gt; Boolean): Boolean = synchronized(this) { if (cond(firstImpl())) { addImpl(node) true } else { false }} addImpl里面实际上就是添加到数组的最后面 1234567891011121314151617181920212223242526272829303132internal fun addImpl(node: T) { assert { node.heap == null } node.heap = this val a = realloc() val i = size++ a[i] = node node.index = i // 调整 siftUpFrom(i)}// 这里在比较调整，看下 实现的 Comparable&lt;T&gt;private tailrec fun siftUpFrom(i: Int) { if (i &lt;= 0) return val a = a!! val j = (i - 1) / 2 if (a[j]!! &lt;= a[i]!!) return swap(i, j) siftUpFrom(j)}// 是在比较 dealy timeoverride fun compareTo(other: DelayedTask): Int { val dTime = nanoTime - other.nanoTime return when { dTime &gt; 0 -&gt; 1 dTime &lt; 0 -&gt; -1 else -&gt; 0 }} 具体的延时是通过 DelayedTaskQueue来定时调度任务的，实际上是通过最小堆来排序的，添加的node 通过 比较 dealy 时间。 sheduleImpl完成之后，也就加入到DefaultExecutor的 DelayedTaskQueue之后，调用了unpark 12345678public fun schedule(now: Long, delayedTask: DelayedTask) { when (scheduleImpl(now, delayedTask)) { SCHEDULE_OK -&gt; if (shouldUnpark(delayedTask)) unpark() SCHEDULE_COMPLETED -&gt; reschedule(now, delayedTask) SCHEDULE_DISPOSED -&gt; {} // do nothing -- task was already disposed else -&gt; error(&quot;unexpected result&quot;) }} Unpark 里面 发现线程为null，则会创建线程，start线程，直接就是DefaultExecutor的run方法了，run里面调用processNextEvent。这里就是取出来用了，调用 processNextEvent() 来处理事件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 留意 processNextEvent() 是有返回值的，实际上返回的线程的park时间override fun processNextEvent(): Long { // 省略部分代码 //这里出现了 _delayed ，也就是上面提到了DelayedTaskQueue val delayed = _delayed.value if (delayed != null &amp;&amp; !delayed.isEmpty) { val now = nanoTime() // while ，是可能存在多个task到期了 while (true) { // 这里从 DelayedTaskQueue 取出来放到了 队列 _queue 中去了 // it.timeToExecute实际上就是比较 now - nanoTime &gt;= 0 delayed.removeFirstIf { if (it.timeToExecute(now)) { enqueueImpl(it) } else false } ?: break // quit loop when nothing more to remove or enqueueImpl returns false on \"isComplete\" } } // 从 _queue 里面取出一个来DelayedResumeTask任务执行 // 虽然本次可能加入多个Task，但是本次只执行一个，剩下的下次执行， val task = dequeue() if (task != null) { task.run() return 0 } // 需要park return nextTime}// 根据queue和nextDelayedTask判断，本次需要park的时间protected override val nextTime: Long get() { if (super.nextTime == 0L) return 0L val queue = _queue.value when { queue === null -&gt; {} // empty queue -- proceed queue is Queue&lt;*&gt; -&gt; if (!queue.isEmpty) return 0 // non-empty queue queue === CLOSED_EMPTY -&gt; return Long.MAX_VALUE // no more events -- closed else -&gt; return 0 // non-empty queue } val nextDelayedTask = _delayed.value?.peek() ?: return Long.MAX_VALUE return (nextDelayedTask.nanoTime - nanoTime()).coerceAtLeast(0) } 为什么要取出来放到_queue，直接取出来执行不行？ 取出来一个，执行一个，需要时间，而且在多次修改ThreadSafeHeap排序堆，同时其他线程也可能存在竞争情况，是带有锁的，一次性取来，取出来的task放到_queue是无序的。 Dealy 会导致协程切换线程吗？ 可以，协程可能切换线程。如果当前协程获得恢复执行，而原先的线程又在执行其它线程，则协程会在其它线程上执行。也就是说，协程在生命周期中可以更换线程。 为什么Kotlin JVM 要用线程池加CPS的方式来实现 ？直接用线程池不行？ 主要是JVM原生没有协程的概念，感知不到协程，只有线程，JVM要真正的像GO那样元素支持协程，是需要修改JVM的，或者抛弃JVM，但这样通用性和可扩展性就会很受影响 Kotlin 的目标是想要全平台的，Kotlin on JS ,Kotlin on Native。你JVM没有的能力，不代表其他没有。可以提供统一的编程接口，不用关心平台的实现。 提供友好的异步编程方式，简洁 更高抽象隐藏异步实现细节，实现写异步如同同步的顺序式写法，开发维护成本大大减低、但内存上有部分的妥协，协程因为创建了中间的一系列封装对象，比传统的多线程编程增加了额外的内存消耗 为什么用 dealy 代替 sleep ？ 了解了Kotlin的协程实现原理，在sleep的这段时间，还是占用当前线程，其他协程得不到来这个线程执行的机会。本质上sleep是sleep了当前线程，而dealy是dealy了当前协程。 附录 参考资料 Thread.sleep、Object.wait、LockSupport.park 区别 没讲明白，看下原文呗 https://www.jianshu.com/p/557a728e74c6 https://ethanhua.github.io/2018/12/24/kotlin_coroutines/ https://blog.csdn.net/weixin_42063726/article/details/106198068","link":"/2020/09/13/Kotlin/Kotlin-on-JVM%E5%8D%8F%E7%A8%8B/"},{"title":"队列的最大值","text":"请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。 若队列为空，pop_front 和 max_value 需要返回 -1 示例 1： 输入:[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”][[],[1],[2],[],[],[]]*输出: *[null,null,null,2,1,2] 示例 2： 输入:[“MaxQueue”,”pop_front”,”max_value”][[],[],[]]*输出: *[null,-1,-1] 限制： 1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000 1 &lt;= value &lt;= 10^5 队列标记每次标记上一次最大值的后面的最大值。 class MaxQueue {1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //记录当前的数 ArrayDeque&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); //记录每次更新的最大值 ArrayDeque&lt;Integer&gt; maxIndex = new ArrayDeque&lt;&gt;(); public MaxQueue() { } //maxIndex头节点就是当前的 public int max_value() { if (queue.isEmpty()) { return -1; } return maxIndex.peek(); } // 记录更新每次的最大值，前面的小的，都出队，所以每次就保留了后面的最大值 // 实际上maxindex降序保留最大值 public void push_back(int value) { if (!queue.isEmpty()) { //每次保留最大值 while (!maxIndex.isEmpty()&amp;&amp;maxIndex.getLast() &lt;= value) { maxIndex.removeLast(); } } maxIndex.add(value); queue.add(value); } public int pop_front() { if (queue.isEmpty()) { return -1; } Integer poll = queue.poll(); //若果当前 弹出的数，最大值出队 if (poll.equals(maxIndex.peek())) { maxIndex.poll(); } return poll ; }}","link":"/2020/05/01/LeetCode/dui-lie-de-zui-da-zhi-lcof/"},{"title":"丑数","text":"我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 示例: 输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 *说明: * 1 是丑数。 n 不超过1690。 丑数的递推性质： 丑数只包含因子 2,3,52, 3, 5 2, 3,5 ，因此有 “丑数 == = 某较小丑数 ×\\times × 某因子” （例如：10=5×210 = 5 \\times 2 10= 5× 2 ）。 丑数的递推性质： 丑数只包含因子 2, 3, 52,3,5 ，因此有 “丑数 == 某较小丑数 \\times× 某因子” （例如：10 = 5 \\times 210=5×2）。 作者：jyd链接：https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 12345678910111213141516171819202122//丑数的递推性质： 丑数只包含因子 2, 3, 52,3,5 ，因此有 “丑数 == 某较小丑数 \\times× 某因子” （例如：10 = 5 \\times 210=5×2）。public int nthUglyNumber(int n) { int[] dp = new int[n]; dp[0] = 1; //用a,b,c 标记分别*2，*3，*5的数 //因为可能存在先加入了比较大的数,所以不能直接按顺序加入。分别标记上一次用了谁 int a=0, b=0, c = 0; for (int i = 1; i &lt; n; i++) { int numA = dp[a] * 2; int numB = dp[b] * 3; int numC = dp[c] * 5; //保证了当期那添加的是最小的 dp[i] = Math.min(numA, Math.min(numB, numC)); //可能会存在相等的情况，都加 if(dp[i] == numA) a++; if(dp[i] == numB) b++; if(dp[i] == numC) c++; } return dp[n-1];}","link":"/2020/04/24/LeetCode/chou-shu-lcof/"},{"title":"二叉树中和为某一值的路径","text":"输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 示例:给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1返回: [ [5,4,11,2], [5,8,4,5]] 提示： 节点总数 &lt;= 10000 实际上就是先序遍历，记录路径，回退的时候记得remove掉叶子 解法1 ：7ms1234567891011121314151617181920212223242526class Solution { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); int sum; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) { this.sum = sum; lookSum(root, new ArrayList&lt;&gt;()); return result; } public void lookSum(TreeNode root,List&lt;Integer&gt; integerList){ if(root == null){ return; } //因为Java是传递的引用,我们不能共同用一个list。而是每次new一个，复用之前的路径 ArrayList&lt;Integer&gt; integerArrayList = new ArrayList&lt;&gt;(integerList); integerArrayList.add(root.val); if(root.left == null &amp;&amp; root.right == null){ if (integerArrayList.stream().mapToInt(Integer::intValue).sum() == sum) { result.add(integerArrayList); } return; } lookSum(root.left, integerArrayList); lookSum(root.right, integerArrayList); }} 执行用时：7 ms 内存消耗：42.2 MB 缺点： 每次都new了 每次都计算了数组了和了 stream 是要慢一点 优化 ：3ms12345678910111213141516171819202122232425class Solution { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); int sum; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) { this.sum = sum; lookSum(root, new ArrayList&lt;&gt;(),0); return result; } public void lookSum(TreeNode root,List&lt;Integer&gt; integerList,int cur_sum){ if(root == null){ return; } ArrayList&lt;Integer&gt; integerArrayList = new ArrayList&lt;&gt;(integerList); integerArrayList.add(root.val); if(root.left == null &amp;&amp; root.right == null){ if (cur_sum+root.val == sum) { result.add(integerArrayList); } return; } lookSum(root.left, integerArrayList,cur_sum+root.val); lookSum(root.right, integerArrayList, cur_sum + root.val); }} 执行用时：3 ms 内存消耗：42.9 MB缺点 不用每次都计算和了，把和标记下 每次都new有点不划算 优化 ：1ms12345678910111213141516171819202122232425262728class Solution { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); int sum; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) { this.sum = sum; lookSum(root, new ArrayList&lt;&gt;(),0); return result; } public void lookSum(TreeNode root,List&lt;Integer&gt; integerList,int cur_sum){ if(root == null){ return; } integerList.add(root.val); if(root.left == null &amp;&amp; root.right == null){ if (cur_sum+root.val == sum) { result.add(new ArrayList&lt;&gt;(integerList)); } //回退记得remove integerList.remove(integerList.size() - 1); return; } lookSum(root.left, integerList,cur_sum+root.val); lookSum(root.right, integerList, cur_sum + root.val); //回退记得remove integerList.remove(integerList.size() - 1); }} 执行用时：1 ms 内存消耗：39.7 MB","link":"/2020/04/27/LeetCode/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/"},{"title":"二叉搜索树的后序遍历序列","text":"输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。 参考以下这颗二叉搜索树： 5 / \\ 2 6 / \\ 1 3示例 1： 输入: [1,6,3,2,5]输出: false 示例 2： 输入: [1,3,2,6,5]输出: true 提示： 数组长度 &lt;= 1000 递归二叉搜索树的，中序遍历 左 根 右 是升序的，也就是左比根小，右比根大。 后续遍历结合二叉树的特点就是 最后一个是根，根的前面，一部分连续小于根，后面一部分连续大于根。 满足条件，再递归判断左右子树， 12345678910111213141516171819202122232425262728 class Solution { public boolean verifyPostorder(int[] postorder) { return recur(postorder,0,postorder.length-1); } //当前这颗树，开始和结束的点 public boolean recur(int[] postorder,int start ,int end ){ //后续遍历，最后一个就是根 if (start &gt;= end) { return true; } //有连续的一部分小于根, 找到小于的界限 int cur = start; while (postorder[cur] &lt; postorder[end]) cur++; //左子树的界限 int left = cur-1; //从界限开始，有连续的一部分大于根 while (postorder[cur]&gt;postorder[end]) cur++; //刚好遇到根 &amp;&amp; 左子树 &amp;&amp; 右子树(右子树当然要去掉根) return cur == end &amp;&amp; recur(postorder, start, left) &amp;&amp; recur(postorder,left+1, end-1); }}","link":"/2020/05/01/LeetCode/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/"},{"title":"股票的最大利润","text":"假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ 示例 1: 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 限制： 0 &lt;= 数组长度 &lt;= 10^5 暴力法先按价值排序，并标记日期。从高价值开始遍历，如果满足日期前后关系,则这次遍历结束，更新最大值。 12345678910111213141516171819202122232425262728293031323334class Solution { class Tnode implements Comparable&lt;Tnode&gt;{ public Tnode(int vlaue, int index) { this.value = vlaue; this.index = index; } int value,index; @Override public int compareTo(Tnode o) { return o.value-value; } } public int maxProfit(int[] prices) { Tnode[] tnodes = new Tnode[prices.length]; for (int i = 0; i &lt; tnodes.length; i++) { tnodes[i] = new Tnode(prices[i], i); } //先排序 Arrays.sort(tnodes); int max = 0; for (int i = 0; i &lt; tnodes.length; i++) { for (int j = tnodes.length-1; j &gt;i ; j--) { if (tnodes[i].index &gt; tnodes[j].index) { max = Math.max(max, tnodes[i].value - tnodes[j].value); break; } } } return max; }} 1234200 / 200 个通过测试用例状态：通过执行用时：431 ms内存消耗：39.7 MB 动态规划 当前的可以获得最大价值，和前面可以获得的最大价值，与前面最低的价值相关。 1234567891011121314151617public int maxProfit(int[] prices) { //小于2天，不能交易 if (prices.length &lt; 2) { return 0; } int[] dp = new int[prices.length + 1]; dp[0] = 0; //标记到第i天，经过的最小值 int min = prices[0]; for (int i = 1; i &lt;= prices.length; i++) { //当前最大价值 max(上一次的，当天的价值减去之前的最小值) dp[i] = Math.max(dp[i - 1], prices[i-1] - min); min = Math.min(min, prices[i-1]); } return dp[prices.length]; } 12345200 / 200 个通过测试用例状态：通过执行用时：2 ms内存消耗：39.8 MB","link":"/2020/04/23/LeetCode/gu-piao-de-zui-da-li-run-lcof/"},{"title":"剪绳子","text":"给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m] 。请问 k[0]*k[1]*...*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 示例 1： 输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1 示例 2: 输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示： 2 &lt;= n &lt;= 58 1.数学推导我们都知道一个 “算术几何均值不等式” 当 a=b的时候，取相等，也就是ab的最大值了。 该推广的公式 推论 将绳子 以相等的长度等分为多段 ，得到的乘积最大。假设分为 段，每段长为 ，则有 , 得到的最大积 求函数 的最大值，我们转为 和 的关系 ，就是但是n是一个常数,转而求下面的最大值 补充一点，求一个已知函数的最大值，就是求导数，然后根据一阶导数为0的点就是驻点，如果驻点左右异的话，这个驻点就可能是极值点，极值点又可能是最值点。 先求驻点，就要先求导。但是求导基本公式里面是没有 这个形式的求导的 ，做个变化，两边取对数，因为对数函数是单调递增的，所以不影响原函数的单调性。 两边取对 两边对求导 再代入,化简 取 可得到 满足表达式，通常是猜值法，但是这个只能找到一个驻点，不能说明这个驻点是唯一的。那要证明证明这个驻点唯一呢？通常的做法可以是求二阶导，但是我们这个是个有实际意义的题，且x&gt;0。显然的正负取决于 ,1是个常数， 是单调的， 所以显然 也是单调的，那么就最多只能有一个零点，而恰好，我们猜到了是 取e左右极限，判断的正负 突然想起老师常说的一点不影响单调性，😀 e左边递增加，e的右边减少，可以看出这个是个极大值点，我们前面证明了只有一个驻点，也就最多只有一个极值点，也就最多只有一个极大值点，最大值就是在所有的极大值点选。恰好只有一个，那么最大值点就是了。 如果这是个数学问题，那么就是e了，交卷。但是这是个实际意义的题，x的取值是整数。所有在e的附件取值，代入函数 比较最大值即可。 证明完毕，取3最优。 优先取3 剩下 2 ，就用2 剩下 1 ，拿回来一个 3 因为 $31&lt;22$ 12345678910111213141516171819class Solution { public int cuttingRope(int n) { if (n &lt;= 3) { return n - 1; } int count = n / 3; int last = n % 3; switch (last){ case 0: return (int) Math.pow(3, count); case 1: return (int) Math.pow(3, count-1)*4; case 2: return (int) Math.pow(3, count)*2; } return 0; }} 执行用时 :0 ms, 在所有 Java 提交中击败了100.00% 的用户 内存消耗 :36.2 MB, 在所有 Java 提交中击败了100.00%的用户","link":"/2020/04/28/LeetCode/jian-sheng-zi-lcof/"},{"title":"礼物的最大价值","text":"在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 示例 1: 输入:[ [1,3,1], [1,5,1], [4,2,1] ]输出: 12 解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 提示： 0 &lt; grid.length &lt;= 200 0 &lt; grid[0].length &lt;= 200 1234567891011121314151617181920212223242526class Solution { public int maxValue(int[][] grid) { int m = grid.length; int n = grid[0].length; //第一行，只能从左到右，所有后面的等于前面的相加 for (int i = 1; i &lt; n; i++) { grid[0][i] += grid[0][i -1]; } //第一列，只能是从上到下 for (int i = 1; i &lt; m; i++) { grid[i][0] += grid[i - 1][0]; } //当前 i，j 只能是从上面来，或者从前面来 for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { grid[i][j] += Math.max(grid[i - 1][j], grid[i][j - 1]); } } //走到最后，就是最大的 return grid[m - 1][n - 1]; }}","link":"/2020/04/21/LeetCode/li-wu-de-zui-da-jie-zhi-lcof/"},{"title":"树的子结构","text":"输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 例如:给定的树 A: ` 3 / \\ 4 5 / \\ 1 2` 给定的树 B： ` 4 / 1`返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。 示例 1： 输入：A = [1,2,3], B = [3,1]输出：false 示例 2： 输入：A = [3,4,5,1,2], B = [4,1]输出：true 限制： 0 &lt;= 节点个数 &lt;= 10000 ##先序遍历，一次检查 子树B的根节点可能是树A的任意一节点 1234567891011121314151617181920212223242526272829 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public boolean isSubStructure(TreeNode A, TreeNode B) { if (A == null || B == null) { return false; } //当前根，左右子树 //本质上，这里就是先序遍历A数，然后遍历比较B数 return recursive(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B); } //以当前节点判断，B是不是子树 public boolean recursive(TreeNode A, TreeNode B){ if (B == null) { return true; } if (A==null||A.val!=B.val) return false; return recursive(A.left, B.left) &amp;&amp; recursive(A.right, B.right); }}","link":"/2020/05/05/LeetCode/shu-de-zi-jie-gou-lcof/"},{"title":"重建二叉树","text":"输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如，给出 前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7限制：0 &lt;= 节点个数 &lt;= 5000 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { //利用原理,先序遍历的第一个节点就是根。在中序遍历中通过根 区分哪些是左子树的，哪些是右子树的 //左右子树，递归 HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();//标记中序遍历 int[] preorder;//保留的先序遍历 public TreeNode buildTree(int[] preorder, int[] inorder) { this.preorder = preorder; for (int i = 0; i &lt; preorder.length; i++) { map.put(inorder[i], i); } return recursive(0,0,inorder.length-1); } /** * @param pre_root_idx 先序遍历的索引 * @param in_left_idx 中序遍历的索引 * @param in_right_idx 中序遍历的索引 */ public TreeNode recursive(int pre_root_idx, int in_left_idx, int in_right_idx) { //相等就是自己 if (in_left_idx &gt; in_right_idx) { return null; } //root_idx是在先序里面的 TreeNode root = new TreeNode(preorder[pre_root_idx]); // 有了先序的,再根据先序的，在中序中获 当前根的索引 int idx = map.get(preorder[pre_root_idx]); //左子树的根节点就是 左子树的(前序遍历）第一个，就是+1,左边边界就是left，右边边界是中间区分的idx-1 root.left = recursive(pre_root_idx + 1, in_left_idx, idx - 1); //由根节点在中序遍历的idx 区分成2段,idx 就是根 //右子树的根，就是右子树（前序遍历）的第一个,就是当前根节点 加上左子树的数量 // pre_root_idx 当前的根 左子树的长度 = 左子树的左边-右边 (idx-1 - in_left_idx +1) 。最后+1就是右子树的根了 root.right = recursive(pre_root_idx + (idx-1 - in_left_idx +1) + 1, idx + 1, in_right_idx); return root; }}","link":"/2020/04/20/LeetCode/zhong-jian-er-cha-shu-lcof/"},{"title":"字符串的排列","text":"输入一个字符串，打印出该字符串中字符的所有排列。 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 示例: 输入：s = “abc”输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”] 限制： 1 &lt;= s 的长度 &lt;= 8 暴力加剪枝，回溯实际可以类比二叉树的先序遍历DFS。不过二叉树有左右，我们可以区分。类比成比如8个字母，则有8层的数，我们每一层都暴力匹配一下所有的8个字母，但是我可以通过记忆知道前面走过的字母。这样就可以去掉一部分\b暴力。最后走到叶子的时候，回退。 12345678910111213141516171819202122232425262728293031323334353637383940//防止有重复的字母HashSet&lt;String&gt; stringArrayList = new HashSet&lt;&gt;();public String[] permutation(String s) { dfs(s, 0, new StringBuffer(), new HashSet&lt;&gt;()); String[] result = new String[stringArrayList.size()]; return stringArrayList.toArray(result);}public void dfs(String s, int cur, StringBuffer stringBuffer, HashSet&lt;Integer&gt; visited) { //走到最后一个了，添加 if (cur == s.length()) { stringArrayList.add(stringBuffer.toString()); return; } //每一层都尝试一下所有字母 //类别二叉树，可以区分左右。先左后右。所以这里重试所有的字母 for (int i = 0; i &lt; s.length(); i++) { //如果前面一层这个字母,被访问过了,就只能选下一个 if (visited.contains(i)) { continue; } //标记访问 visited.add(i); //添加进去，开始进入下一层 stringBuffer.append(s.charAt(i)); dfs(s, cur + 1, stringBuffer, visited); //回溯,回退到上一层，去掉这一层的标记 stringBuffer.deleteCharAt(stringBuffer.length() - 1); visited.remove(i); }}","link":"/2020/04/29/LeetCode/zi-fu-chuan-de-pai-lie-lcof/"},{"title":"数值的整数次方","text":"实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 示例 1: 输入: 2.00000, 10输出: 1024.00000 示例 2: 输入: 2.10000, 3输出: 9.26100 示例 3: 输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 递归 二分法求解123456789101112class Solution { public double myPow(double x, int n) { //基本情况 if(n==0) return 1; if(n==1) return x; if(n==-1) return 1/x; //先算n/2*n/2,有余数再补充余数 double a = myPow(x,n/2); double b = myPow(x,n%2); return a*a*b; }}","link":"/2020/05/06/LeetCode/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"},{"title":"数字序列中某一位的数字","text":"数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。 请写一个函数，求任意第n位对应的数字。 示例 1： 输入：n = 3输出：3 示例 2： 输入：n = 11输出：0 限制： 0 &lt;= n &lt; 2^31 找规律 ，限定范围要用long 12345678910111213141516171819202122232425262728293031/** * 首先，我们要明确的是，n是下标，从0开始的！ * 我们可以注意到规律 0~9有10个数字，10~99有90个数字，100~999有900个数字，so~ * @param n * @return */ public int findNthDigit(int n){ if (n &lt; 10) { return n; } //先找一下，在哪个数位范围。要用long long target = 9; int i = 1; while (n - target*i &gt; 0) { n = (int) (n - target*i); i = i + 1; target = target * 10; } //找到了在i位里面 long start = (int) Math.pow(10, i-1); System.out.println(start); //还剩下n个数字，接下来就是每个数字都是i位了 int count = (n-1) / i;//有几个数字,从0开始的，n-1 //目标数 long num = start + count; //所求数位为数字 numnum 的第 (n - 1) \\% digit(n−1)%digit 位 return String.valueOf(num).charAt((n - 1) % i) - '0'; }","link":"/2020/05/06/LeetCode/%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"title":"数组中的逆序对","text":"在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例 1: 输入: [7,5,6,4]输出: 5 限制： 0 &lt;= 数组长度 &lt;= 50000 题解利用归并排序的局部有序，就可以批量知道左右的大小关系。 如图，1小先走，则右边的全部比1大。所以只需要加上右边的就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 public int reversePairs(int[] nums) { if (nums == null || nums.length &lt; 2) { return 0; } int k = mergeSort(nums, 0, nums.length - 1); System.out.println(Arrays.toString(nums)); return k;}//先分成，2段，计算2段之前的逆序对private int mergeSort(int[] nums, int left, int right) { if (left == right) return 0; int mid = (left + right) / 2; int leftCount = mergeSort(nums, left, mid);//计算左边部分 int rightCount = mergeSort(nums, mid+1, right);//计算右边部分 return leftCount+rightCount+merger(nums, left, mid, right);}//真实merge,计算以mid分界的逆序对private int merger(int[] nums,int left ,int mid,int right){ //最终归并的数组 int[] temp = new int[right - left + 1]; int count = 0; int p1 = left; int p2 = mid + 1; int i = 0; //以mid分界 while (p1 &lt;= mid &amp;&amp; p2 &lt;= right) { if (nums[p1] &lt;= nums[p2]) { //p1比较小，p1入队 temp[i++] = nums[p1++]; }else { //p2入队 temp[i++] = nums[p2++]; //加上左边的数，就逆序对数 count += mid - p1 +1 ; } } //接下来处理某一个有剩余的情况,谁剩下，谁全部移交到temp while (p1 &lt;= mid) { temp[i++] = nums[p1++]; } while (p2 &lt;= right) { temp[i++] = nums[p2++]; } //排序好的，copy到源数组 for (int j = 0; j &lt; temp.length; j++) { nums[left + j] = temp[j]; } return count;}","link":"/2020/05/13/LeetCode/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"title":"最长不含重复字符的子字符串","text":"给定一个字符串，请你找出其中不含有重复字符的 *最长子串 *的长度。 示例 1: 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 利用滑动窗口求解 1234567891011121314151617181920212223242526272829class Solution { public int lengthOfLongestSubstring(String s) { int head = 0; int max = 0; char[] chars = s.toCharArray(); //标记当前窗口 HashSet&lt;Character&gt; stringHashSet = new HashSet&lt;&gt;(); for (int tail = 0; tail &lt; chars.length; tail++) { //如果窗口不包含，则尾指针后移，更新max if (!stringHashSet.contains(chars[tail])) { max = Math.max(max, tail - head +1); }else { //如果包含，则跟新head值，直到不包含为止 while (stringHashSet.contains(chars[tail])) { stringHashSet.remove(chars[head]); head++; } } //加入 stringHashSet.add(chars[tail]); } return max; }}","link":"/2020/05/07/LeetCode/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"iOS如何安装旧版本app, app降级","text":"背景有时候，新的app版本去掉了某些功能或新加了某些功能是我们不想要的，例如新版本bilibili加了很多广告，还是想使用旧版本。大体有2个方法，都需要用到爱思助手。如果是Android则很方便，只需要搜索下载到对应的apk文件即可，但是iOS的ipa文件是和账号绑定的，别人下的ipa文件分享给你，也是需要对应的账号激活一次才能使用的。​ 方法一：直接使用爱思助手安装适用mac和windows的，通常只有国区app，无需对应的apple id账号。爱思助手官网：https://www.i4.cn/ 电脑下载安装，手机连接安装，手机版爱思助手 手机打开爱思助手app，搜索对应的app， 点击进入详情页，下拉，查看历史版本，点击安装对应的版本即可。 ​ ​ 方法二：用自己的账号去下载旧的ipa文件原理：在旧版本的iTunes支持下载ipa文件，我们点击下载的时候，通过中间代理，修改掉对应的版本号，以此来下载对应版本的app的ipa的文件。下载好的ipa文件，最后通过爱思助手，手动安装一次，登陆对应的账号即可。​ 要求：必须windows环境，测试Mac版12.6 就算成功安装了，也无法下载ipa文件。mac用户可以通过虚拟机来解决。工具：Fiddler抓包拦截, iTunes必须12.6及以下iTunes 12.6 旧版下载：https://secure-appldnld.apple.com/itunes12/091-87819-20180912-69177170-B085-11E8-B6AB-C1D03409AD2A6/iTunes64Setup.exehttps://secure-appldnld.apple.com/itunes12/091-33626-20170922-F51D3530-A003-11E7-8324-03D19A97A551/iTunes64Setup.exe​ 我怎么知道对应的版本号呢？去app历史版本好查询下载 https://tools.lancely.tech/apple/app-search​ 先安装上面的工具，成功登陆一下iTunes，以后安装你下载的ipa文件，是需要这次的apple id的。搜索一下app，随便点击下载一个是不是可以的。 可以先去查询你想要下载的版本对应版本号 https://tools.lancely.tech/apple/app-search 打开Fiddler，先在tools-&gt;option里面点开https 拦截下载的断点：bpu MZBuy.woa 搜索对应的app 去filddler里面查看断点，修改版本号好后，点击run fillddler里命中了几次，你就修改几次，点击绿色的run之后，itunnes里面就会出现下载了，等一会儿即可，如果没有出现下载，重新触发一次即可 最后去找到下载好的ipa文件通过爱思助手手动安装一次，即可 下载好的ipa文件，自己可以重复使用，也可以分享使用，但是需要你下载时候的apple id。","link":"/2022/02/13/%E5%88%86%E4%BA%AB/ios-download-old-app/"},{"title":"矩阵中的路径","text":"请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。 [[“a”,”b“,”c”,”e”],[“s”,” f“,”c“,”s”],[“a”,”d”,” e“,”e”]] 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 示例 1： 输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”输出：true 示例 2： 输入：board = [[“a”,”b”],[“c”,”d”]], word = “abcd”输出：false 提示： 1 &lt;= board.length &lt;= 200 1 &lt;= board[i].length &lt;= 200 解答遍历每一个起点。从每一个起点开始尝试走 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution { public boolean exist(char[][] board, String word) { char[] chars = word.toCharArray(); //依次判断，每一个起点 for (int i = 0; i &lt; board.length; i++) { for (int j = 0; j &lt; board[i].length; j++) { //每次都从当前节点，从k=0开始尝试，只要有满足一条路径，return true if (dfs(board, i, j, chars, 0)) { return true; } } } //都不吗满足 return false; } //当前匹配的节点K public boolean dfs(char[][] board,int i,int j,char[] chars,int k){ //越界了 if(i &gt;= board.length || i &lt; 0 || j &gt;= board[0].length || j &lt; 0) return false; //当前k不满足，说明这条路走不通 if (board[i][j] != chars[k]) { return false; } //说明当前满足条件，实际上K+1 //走到，最后一个了K，满足条件 if (k+1 == chars.length) { return true; } //不是走到的最后一个，还要继续判断，依次，上下左右尝试着走 //这个做个标记，回溯，剪枝 char temp = board[i][j]; //标记当前路径，走过了 board[i][j] = '\\n'; boolean res = dfs(board, i + 1, j, chars,k + 1) || dfs(board, i - 1, j, chars,k + 1) || dfs(board, i, j + 1, chars,k + 1) || dfs(board, i , j - 1, chars,k + 1); //回退的时候，去掉标记 board[i][j] = temp; return res; }}","link":"/2020/05/10/LeetCode/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"},{"title":"关于Spark 集群中调度GPU的一些实验","text":"自己毕设做了一些Spark 调用GPU 相关的实验，自己也在网上找到了一些资料，也写下来分享一些自己的做法。目前Spark(2.3) 还不支持直接调用GPU , 需要自己通过JNI的方式实现调用GPU来做一些加速计算。通常是自己定义好接口，在用NVCC生成动态链接库，然后在Spark中调用。 自己做的一些尝试 1.通过Docker 做到 GPU 容器化，虚拟化。若GPU支持MPS，建议开启MPS。 一个容器成为一个Spark计算节点。 2.为了更好的扩展和调度，采用上面的镜像。在K8S中建立Spark集群，可以通过副本集快速扩容。 3.可以预估单个计算任务，需要的资源，合理的指定每个GPU node 部署的 单个SparkGPU容器的数量。若需要更细粒度的管理每个容器分配的GPU资源，可以查看阿里云开源的一个K8S插件，支持MB级别的分配（https://github.com/nvidia/k8s-device-plugin） 4.总结起来就是，我做的是把每张不同的GPU卡，通过Docker虚拟化做到细粒度的量化，因为每张卡的计算能力不同，这样可以通过K8S，快速给不同的节点部署不同个数的容器实例，在容器实例中启动Spark，再对saprk层面做公平的计算分配。","link":"/2019/06/28/%E6%A1%86%E6%9E%B6/gpuonspark/"},{"title":"K8S安装","text":"1.每个节点安装k8s kubelet kubeadm kubectl，注意与docker版本是否兼容 sudo curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - sudo apt update 查看源中的软件版本 sudo apt-cache madison kubelet sudo apt install kubelet=1.14.0-00 kubeadm=1.14.0-00 kubectl=1.14.0-00 2.master节点列出需要的镜像 kubeadm config images list k8s.gcr.io/kube-apiserver:v1.14.0 k8s.gcr.io/kube-controller-manager:v1.14.0 k8s.gcr.io/kube-scheduler:v1.14.0 k8s.gcr.io/kube-proxy:v1.14.0 k8s.gcr.io/pause:3.1 k8s.gcr.io/etcd:3.3.10 k8s.gcr.io/coredns:1.3.1 3.需要翻墙，所以采用镜像下载，然后重新tag docker pull mirrorgooglecontainers/kube-apiserver:v1.14.0 docker pull mirrorgooglecontainers/kube-controller-manager:v1.14.0 docker pull mirrorgooglecontainers/kube-scheduler:v1.14.0 docker pull mirrorgooglecontainers/kube-proxy:v1.14.0 docker pull mirrorgooglecontainers/pause:3.1 docker pull mirrorgooglecontainers/etcd:3.3.10 docker pull coredns/coredns:1.3.1 docker tag mirrorgooglecontainers/kube-apiserver:v1.14.0 k8s.gcr.io/kube-apiserver:v1.14.0 docker tag mirrorgooglecontainers/kube-controller-manager:v1.14.0 k8s.gcr.io/kube-controller-manager:v1.14.0 docker tag mirrorgooglecontainers/kube-scheduler:v1.14.0 k8s.gcr.io/kube-scheduler:v1.14.0 docker tag mirrorgooglecontainers/kube-proxy:v1.14.0 k8s.gcr.io/kube-proxy:v1.14.0 docker tag mirrorgooglecontainers/pause:3.1 k8s.gcr.io/pause:3.1 docker tag mirrorgooglecontainers/etcd:3.3.10 k8s.gcr.io/etcd:3.3.10 docker tag coredns/coredns:1.3.1 k8s.gcr.io/coredns:1.3.1 4.初始化Kubernetes sudo kubeadm init –kubernetes-version=v1.14.0 –pod-network-cidr=10.244.0.0/16 –kubernetes-version 用来指定版本 –pod-network-cidr 用于后期采用flannel作为网络组建而准备 –apiserver-advertise-address 如果机器上只有单个网卡，可以不进行指定 [ERROR Swap]: running with swap on is not supported. Please disable swap 关闭swap 禁用命令 sudo swapoff -a 启用命令 sudo swapon -a 查看交换分区的状态 sudo free -m Your Kubernetes control-plane has initialized successfully! To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config You should now deploy a pod network to the cluster. Run “kubectl apply -f [podnetwork].yaml” with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/ Then you can join any number of worker nodes by running the following on each as root: kubeadm join 172.16.121.6:6443 –token d1m708.8w7qwnomcecapizk –discovery-token-ca-cert-hash sha256:01e71d90ca6e7ca5e9359519d1eb42d95c8783c764a53f6048697c586042586f 6.安装网络插件flannel https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml kubectl apply -f kube-flannel.yml kubectl get cs检查 7.节点安装 加载内核模块 sudo modprobe ip_vs ip_vs_rr ip_vs_wrr ip_vs_sh 8.节点加入 kubeadm join 172.16.121.6:6443 –token d1m708.8w7qwnomcecapizk –discovery-token-ca-cert-hash sha256m:01e71d90ca6e7ca5e9359519d1eb42d95c8783c764a53f6048697c586042586f [WARNING IsDockerSystemdCheck]: detected “cgroupfs” as the Docker cgroup driver. The recommended driver is “systemd”. Please follow the guide at https://kubernetes.io/docs/setup/cri/ error execution phase preflight: [preflight] Some fatal errors occurred: [ERROR Swap]: running with swap on is not supported. Please disable swap 关闭swap sudo swapoff -a 修改cgroup vim /etc/default/kubelet KUBELET_EXTRA_ARGS=–cgroup-driver=cgroupfs systemctl daemon-reload systemctl restart kubelet 9.节点删除 在master kubectl drain –delete-local-data –force –ignore-daemonsets kubectl delete node 然后使用 节点 kubeadm reset 10.journalctl -f -u kubelet 查看日志 kubectl logs -f coredns-99b9bb8bd-47mvf -n kube-system kubectl get pods -n kube-system 11.配置dashborad https://blog.csdn.net/AtlanSI/article/details/88544500 master kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml 所有node节点上 docker pull mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.10.1 docker tag mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.10.1 k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1 docker pull mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.10.1 docker tag mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.10.1 k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1 kubectl get pods -n kube-system 查看 [root@C7-1 ~]# kubectl get svc -n kube-system NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kube-dns ClusterIP 10.96.0.10 53/UDP,53/TCP 15d kubernetes-dashboard ClusterIP 10.106.249.245 443/TCP 10m [root@C7-1 ~]# kubectl patch svc kubernetes-dashboard -p ‘{“spec”:{“type”:”NodePort”}}’ -n kube-system [root@C7-1 ~]# kubectl get svc -n kube-system NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kube-dns ClusterIP 10.96.0.10 53/UDP,53/TCP 15d kubernetes-dashboard NodePort 10.106.249.245 443:30115/TCP 147m kubernetes-dashboard NodePort 10.99.200.36 443:32357/TCP 98m 12.Forwarding loop detected in “.” zone. Exiting. See 修改/etc/resolve.conf nameserver 114.114.114.114 kubectl delete pod coredns-fb8b8dccf-7vqfw -n kube-system 删除节点","link":"/2019/05/21/%E6%A1%86%E6%9E%B6/k8sinstall/"},{"title":"C++：如何将类成员函数传递给pthread_create（）？","text":"https://thispointer.com/c-how-to-pass-class-member-function-to-pthread_create/ 1int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg); 接受一个参数和返回值都是void * 的函数 class Task 123456class Task { public: void * execute(); static void * threadFunc(void *); }; 非静态成员函数传递给pthread_create（） 编译器将class（this指针）的指针作为每个成员函数中的第一个参数传递。因此，将指向类Task的对象的指针作为参数传递 1234567typedef void * (*THREADFUNCPTR)(void *); // Pointer to object of class Task Task * taskPtr = new Task(); //Thread ID pthread_t threadId; // Create thread using memeber function as startup routine pthread_create(&amp;threadId, NULL, (THREADFUNCPTR) &amp;Task::execute,taskPtr); 将静态成员函数传递给pthread_create（） 由于静态函数与任何对象都没有关联，因此编译器不会将此指针传递给它。所以，我们不需要传递任何指针作为参数。只是传递NULL即 123typedef void * (*THREADFUNCPTR)(void *); // Create pthread using static function as startup routine pthread_create(&amp;threadId, NULL, (THREADFUNCPTR) &amp;Task::threadFunc, NULL);","link":"/2019/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c-pthread/"},{"title":"C++ 强&#x2F;弱指针","text":"引用计数法 强指针 会修改引用计数。弱指针，不会修改引用计数 参考 https://www.cnblogs.com/hellokitty2/p/10646353.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt; using namespace std; //参考 https://www.cnblogs.com/hellokitty2/p/10646353.html //基类实现 引用的计数的功能 // 缺陷 这是非线程安全的 class RefBase { private: int refcount = 0; public: RefBase() {} void incStrong(void) { refcount++; } void decStrong(void) { refcount--; } int getStrong(void) { return refcount; } }; //模板类 实现 指针引用其他类， // 因为需要调用对象的方法，所以其他类需要实现基类 template&lt;typename T&gt; class sp { private: T *p; public: sp() : p(NULL) { cout &lt;&lt; \"sp()\" &lt;&lt; endl; } //构造函数 引用加一 sp(T *p) { cout &lt;&lt; \"sp(T *p)\" &lt;&lt; endl; this-&gt;p = p; this-&gt;p-&gt;incStrong(); } //拷贝函数 引用加一 sp(const sp &amp;other) { cout &lt;&lt; \"sp(const sp &amp; other)\" &lt;&lt; endl; this-&gt;p = other.p; this-&gt;p-&gt;incStrong(); } //析构函数 引用减一 ~sp() { cout &lt;&lt; \"~sp()\" &lt;&lt; endl; this-&gt;p-&gt;decStrong(); // 当引用减少到0的时候 就释放对象 if (!this-&gt;p-&gt;getStrong()) { delete p; //自动调用 ~Person() cout &lt;&lt; \"delete p\" &lt;&lt; endl; } } //操作符重载，对指针sp调用的时候，等价于p在调用 T *operator-&gt;() { return this-&gt;p; } //操作符重载，对指针sp调用的时候，等价于p在调用 T &amp;operator*() { return *(this-&gt;p); } }; class Person : public RefBase { public: Person() { cout &lt;&lt; \"Person()\" &lt;&lt; endl; } ~Person() { cout &lt;&lt; \"~Person()\" &lt;&lt; endl; } }; int main() { cout &lt;&lt; \"\"; sp&lt;Person&gt; p1 = new Person(); sp&lt;Person&gt; p2 = p1; } log 1234567Person() sp(T *p) sp(const sp &amp; other) ~sp() ~sp() ~Person() delete p C++内存管理 new/delete是C++的操作符，而malloc/free是C中的函数 new/delete是保留字，不需要头文件支持；malloc/free需要头文件库函数支持 free只是释放了malloc所申请的内存，并没有改变指针的值 new 做了2件事。先申请空间，再调用构造函数。 delete 做了2件事件。先调用析构函数，再释放空间。 注意 new[] 与 delete[] 配对使用，如果先 ptr=new object[] 创建多个对象，直接调用 delete ptr，只会调用和释放一个，剩下的不会释放，造成内存泄漏。123Cat * ptr= new Cat[5];delete(ptr);//错误，只会回收一个delete[] (ptr);//正确","link":"/2019/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/C-ptr/"},{"title":"Cache与虚存的异同","text":"虚拟存储器虚拟存储器是一个容量非常大的存储器的逻辑模型，不是任何实际的物理存储器。虚拟存储器指的是主存——外存层次。它以透明的方式给用户提供 了一个比实际主存空间大得多的程序地址空间。 实地址与虚地址用户编制程序时使用的地址称为虚地址或逻辑地址。其对应的存储空间称为虚存空间或逻辑地址空间；而计算机物理内存的访问地址则称为实地址或物理地址，其对应的存储空间称为物理存储空间或主存空间。程序进行虚地址到实地址转换的过程称为程序再定位。 虚存的访问过程每次访存是，首先判断该虚地址所对弈的部分是否在实存中，如果是，则进行地址转换并用实地址访问主存；否则，按照某种算法将辅存中的部分程序调度进内存，再按同样的方法访问主存。 cache与虚存的异同在三级存储体系中 ，cache-主存和主存-辅存这两个存储层次有许多相同点：（1）出发点相同：二者都是为了提高存储系统的性能价格比而购置的分层存储体系，都力图使存储系统的性能接近高速存储器，而价格和容量接近低速存储器。（2）原理相同：都是利用了程序运行时的局部性原理吧最近常用的信息块从相对慢速而大容量的存储器调入相对高速而小容量的存储器。（3）侧重点不同：cache主要解决主存与CPU的速度差异问题；而就性能价格比的提高而言，虚存主要是解决存储容量问题。（4）数据通路不同：CPU与cache和主存之间均有直接访问通路，cache不命中时可直接访问主存，而虚存所一栏的辅存与CPU之间不存在直接的数据通路，而主存不命中时只能通过调页解决，CPU最终还是要访问主存。（5）透明性不同：cache的管理完全有硬件完成，对系统程序员和应用程序员均透明；而虚存管理由软件（操作系统）和硬件共同完成，由于软件的介入，虚存对实现存储管理的系统程序员不透明，而支队应用程序员透明。（6）未命中时的损失不同：由于主存的存取时间是cache的存取时间的5-10倍，而主存的存取速度通常比辅存的存取速度快上千倍，故主存未命中时系统的性能损失要远岛屿cache未命中时的损失。","link":"/2019/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/huancunandxucun/"},{"title":"I&#x2F;O多路复用的技术","text":"1. 事件驱动 select() 模型 用法 select()函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定时间后才唤醒它 12345678#include &lt;sys/select.h&gt;#include &lt;sys/time.h&gt;// 返回值：若有就绪描述符，则返回就绪描述符数目；若超时则返回0，出错返回-1int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);//maxfdp1: 指定待测试的描述符个数，它的值是待测试的最大描述符加1//readset、writeset、exceptset：指定让内核测试读、写、异常条件的描述符 描述符的就绪条件： 可读条件： 1.该套接字接收缓冲区中的数据字节数大于等于套接字接收缓冲区低水位标记的当前大小 2.该连接的读半部关闭(即接收了FIN的TCP连接) 3.该套接字是一个监听套接字且已完成的连接数不为0 4.该套接字上有一个套接字错误待处理 可写条件： 1.该套接字发送缓冲区中的可用空间字节数大于等于套接字发送缓冲区低水位标记的当前大小 2.该连接的写半部关闭 3.使用非阻塞式connect的套接字已建立连接，或者connect已经以失败告终 4.该套接字上有一个套接字错误待处理 异常条件：该套接字存在带外数据或者仍处于带外标记 优点 目前几乎在所有的平台上支持 缺点 1.每次调用 select()，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大，同时每次调用 select() 都需要在内核遍历传递进来的所有 fd，这个开销在 fd 很多时也很大。 2.单个进程能够监视的文件描述符的数量存在最大限制，32位机默认是1024个，64位机默认是2048。可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低 2 事件驱动 poll() 模型 用法 #include &lt;poll.h&gt; int poll(struct pollfd *fds, nfds_t nfds, int timeout); 对应参数 传入一个文件描述符结构体数组，个数，等待的时间 pollfd结构体12345struct pollfd{ int fd; //文件描述符 short events; //需要等待的事件 short revents; //实际发生的事件，操作系统回写 }; 事件 优点 采用链表的方式替换原有fd_set数据结构,poll() 没有最大文件描述符数量的限制 缺点 poll() 和 select() 同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。 3 事件驱动 epoll() 模型 引用 select、poll、epoll的原理与区别 来自 https://blog.csdn.net/nanxiaotao/article/details/90612404 参考 epoll原理图解 https://blog.csdn.net/qq_35433716/article/details/85345907 用法 12345#include &lt;sys/epoll.h&gt; int epoll_create(int size); int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); int epoll_wait(int epfd, struct epoll_event *event, int maxevents, int timeout); epoll的两种工作方式：1.水平触发（LT）2.边缘触发（ET） ET模式只支持非阻塞的读写：为了保证数据的完整性。 LT模式：若就绪的事件一次没有处理完要做的事件，就会一直去处理。即就会将没有处理完的事件继续放回到就绪队列之中（即那个内核中的链表），一直进行处理。 ET模式：就绪的事件只能处理一次，若没有处理完会在下次的其它事件就绪时再进行处理。而若以后再也没有就绪的事件，那么剩余的那部分数据也会随之而丢失 优点 本质的改进在于epoll采用基于事件的就绪通知方式 epoll也需要将文件描述符先拷贝进内存，但是它只做一次 epoll_create()就好像先在内核中开辟出一个固定大小的空的文件描述符集合，之后再将相应的文件描述符放进去或者从中将某一个文件描述符删掉。 只关心“活跃”的链接，无需遍历全部描述符集合 能够处理大量的链接请求(系统可以打开的文件数目) 在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。 epoll(市场用的最多，如果单单连接不做任何事 1G内核内存可以支持10W连接) epoll 现在是线程安全的 缺点 只有linux支持","link":"/2019/04/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/ioselect/"},{"title":"深挖CAS的底层实现","text":"前言 代码层面，所有的锁在cpu层面都是一条条的指令，所有最终所有的锁，都要考底层指令的支持，CAS是代码层面比较常用的一种“无锁”,实际对应于cpu里面的几条指令，当然一个cpu有多个核下是如何解决锁的。在单核的时候，还可以通过关闭中断，来阻止操作系统调度。但是在多核的情况下，各个cpu是并行执行的，因此这个时候，就会出现，同时获取到锁的状态，而这个时候，通过禁止中断，是没有效果的，就需要引入一种机制实现多核本地缓存失效和内存全局的锁，涉及多级缓存的失效与同步，其实在计算机组成原理与操作系统里面有学的。 X86平台 基于JVM unsafe.compareAndSwapInt 可以看到jdk里面的都是native实现 12345public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5); public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6); 可以在openjdk的源码src/share/vm/prims/unsafe.cpp里找到对应的C层面的调用 123456UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) UnsafeWrapper(\"Unsafe_CompareAndSwapInt\"); oop p = JNIHandles::resolve(obj); jint* addr = (jint *) index_oop_from_field_offset_long(p, offset); return (jint)(Atomic::cmpxchg(x, addr, e)) == e;UNSAFE_END 我们可以通过c++的atmoic库进行调试，发现汇编层面 123456789untitled1`atomic_worker:-&gt; 0x10ce7fbed &lt;+157&gt;: lock 0x10ce7fbee &lt;+158&gt;: cmpxchgb %cl, (%rdx) 0x10ce7fbf1 &lt;+161&gt;: sete %cl 0x10ce7fbf4 &lt;+164&gt;: testb $0x1, %cl 0x10ce7fbf7 &lt;+167&gt;: movb %cl, -0x65(%rbp) 0x10ce7fbfa &lt;+170&gt;: movb %al, -0x66(%rbp) 0x10ce7fbfd &lt;+173&gt;: jne 0x10ce7fc8f ; &lt;+319&gt; [inlined] std::__1::__atomic_base&lt;bool, false&gt;::compare_exchange_strong(bool&amp;, bool, std::__1::memory_order) + 249 at main.cpp:30 0x10ce7fc03 &lt;+179&gt;: jmp 0x10ce7fc86 ; &lt;+310&gt; [inlined] std::__1::__atomic_base&lt;bool, false&gt;::compare_exchange_strong(bool&amp;, bool, std::__1::memory_order) + 240 at main.cpp:30 lock与cmpxchgb lock 并不是单独的一条可执行指令，你debug 使用next i 会发现是2条一起走了 LOCK前缀可确保CPU在操作期间对适当的高速缓存行具有排他性所有权，并提供某些其他排序保证。 这可以通过声明总线锁定来实现，但是CPU会尽可能避免这种情况。 如果总线被锁定，则仅在锁定指令期间。 cmpxchgb 系列就是真正的底层CAS的支持 ARM平台 基于android art CompareAndSetWeakAcquire123456// Atomically replace the value with desired_value if it matches the expected_value. Prior writes // made to other memory locations by the thread that did the release become visible in this // thread. bool CompareAndSetWeakAcquire(T expected_value, T desired_value) { return this-&gt;compare_exchange_weak(expected_value, desired_value, std::memory_order_acquire); } 通过ASdebug 得到native汇编 123456-&gt; 0x7ea6aa6964 &lt;+220&gt;: ldaxr w10, [x22] //比较 0x7ea6aa6968 &lt;+224&gt;: cmp w10, w9 //bne: 数据跳转指令，道标志寄存器中Z标志位不等于零时, 跳转到BNE后标签处 0x7ea6aa696c &lt;+228&gt;: b.ne 0x7ea6aa693c ; &lt;+180&gt; [inlined] std::__1::__atomic_base&lt;int, false&gt;::compare_exchange_weak(int&amp;, int, std::__1::memory_order) at atomic.h:159 0x7ea6aa6970 &lt;+232&gt;: stxr w9, w8, [x22] ldaxr stxrLoad-acquire exclusive register ARMV8下的CAS并不是一条指令OK Load-Acquire Exclusive Register derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses see Load/Store addressing modes. 内存访问是原子的。PE将要访问的物理地址标记为互斥访问 LDXR指令，将状态从open状态切换到exclusive状态，STXR指令，将状态从exclusive状态切换到open状态，这个就表示store exclusive操作成功。 为了解决多核情况下的锁竞争问题，arm引入了exclusive操作，并添加了相应的指令 exclusive的操作的核心，就是会将锁，用一个状态机进行维护，该状态机有2种状态，open状态和exclusive状态。要想成功的对锁进行上锁，状态必须要从exclusive状态切换到open状态，其他状态，都是失败的。 要达到目的，显然exclusive是对每个CPU核都是有效的 通过ldaxr/stxr指令实现在SMP系统中多核共享内存的互斥访问，也就是说原子操作是由独占访问指令”Load-Exclusive and Store-Exclusive”来实现的，其中最核心的地方在于系统通过exclusive monitor(一种简单的状态机)来监控独占访问。ldaxr/stxr可以保证任何情况下（包括被中断）的访问原子性。 STXR指令和普通的STR指令，不同的是，该指令有返回值，表示store exclusive是否成功。如果成功，ws为0，不成功，ws为1 参考 部分转载 http://www.lujun.org.cn/?p=4097 http://shell-storm.org/armv8-a/ISA_v85A_A64_xml_00bet8/from-ISA_v84A_A64_xml_00bet7/ldaxr.html https://www.cnblogs.com/i-arm-rex/p/6736170.html","link":"/2020/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%B7%B1%E6%8C%96CAS%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"title":"项目如何生成模块关系图？","text":"效果图如下 Gradle Task123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116task projectDependencyGraph { doLast { def dot = new File(rootProject.buildDir, 'reports/dependency-graph/project.dot') dot.parentFile.mkdirs() dot.delete() dot &lt;&lt; 'digraph {\\n' dot &lt;&lt; \" graph [label=\\\"${rootProject.name}\\\\n \\\",labelloc=t,fontsize=30,ranksep=1.4];\\n\" dot &lt;&lt; ' node [style=filled, fillcolor=\"#bbbbbb\"];\\n' dot &lt;&lt; ' rankdir=TB;\\n' def rootProjects = [] def queue = [rootProject] while (!queue.isEmpty()) { def project = queue.remove(0) rootProjects.add(project) queue.addAll(project.childProjects.values()) } def projects = new LinkedHashSet&lt;Project&gt;() def dependencies = new LinkedHashMap&lt;Tuple2&lt;Project, Project&gt;, List&lt;String&gt;&gt;() def multiplatformProjects = [] def jsProjects = [] def androidProjects = [] def javaProjects = [] queue = [rootProject] while (!queue.isEmpty()) { def project = queue.remove(0) queue.addAll(project.childProjects.values()) if (project.plugins.hasPlugin('org.jetbrains.kotlin.multiplatform')) { multiplatformProjects.add(project) } if (project.plugins.hasPlugin('org.jetbrains.kotlin.js')) { jsProjects.add(project) } if (project.plugins.hasPlugin('com.android.library') || project.plugins.hasPlugin('com.android.application')) { androidProjects.add(project) } if (project.plugins.hasPlugin('java-library') || project.plugins.hasPlugin('java')) { javaProjects.add(project) } project.configurations.all { config -&gt; config.dependencies .withType(ProjectDependency) .collect { it.dependencyProject } .each { dependency -&gt; projects.add(project) projects.add(dependency) rootProjects.remove(dependency) def graphKey = new Tuple2&lt;Project, Project&gt;(project, dependency) def traits = dependencies.computeIfAbsent(graphKey) { new ArrayList&lt;String&gt;() } if (config.name.toLowerCase().endsWith('implementation')) { traits.add('style=dotted') } } } } projects = projects.sort { it.path } dot &lt;&lt; '\\n # Projects\\n\\n' for (project in projects) { def traits = [] if (rootProjects.contains(project)) { traits.add('shape=box') } if (multiplatformProjects.contains(project)) { traits.add('fillcolor=\"#ffd2b3\"') } else if (jsProjects.contains(project)) { traits.add('fillcolor=\"#ffffba\"') } else if (androidProjects.contains(project)) { traits.add('fillcolor=\"#baffc9\"') } else if (javaProjects.contains(project)) { traits.add('fillcolor=\"#ffb3ba\"') } else { traits.add('fillcolor=\"#eeeeee\"') } dot &lt;&lt; \" \\\"${project.path}\\\" [${traits.join(\", \")}];\\n\" } dot &lt;&lt; '\\n {rank = same;' for (project in projects) { if (rootProjects.contains(project)) { dot &lt;&lt; \" \\\"${project.path}\\\";\" } } dot &lt;&lt; '}\\n' dot &lt;&lt; '\\n # Dependencies\\n\\n' dependencies.forEach { key, traits -&gt; dot &lt;&lt; \" \\\"${key.first.path}\\\" -&gt; \\\"${key.second.path}\\\"\" if (!traits.isEmpty()) { dot &lt;&lt; \" [${traits.join(\", \")}]\" } dot &lt;&lt; '\\n' } dot &lt;&lt; '}\\n' def p = 'dot -Tpng -O project.dot'.execute([], dot.parentFile) p.waitFor() if (p.exitValue() != 0) { throw new RuntimeException(p.errorStream.text) } println(\"Project module dependency graph created at ${dot.absolutePath}.png\") }} 依赖安装生成的项目依赖描述文件转图片，依赖 graphviz,需要手动安装一下 Linux, 根于包管理器自选 apt install graphviz yum install graphviz Mac，根于包管理器自选 port install graphviz brew install graphviz 来源 GitHub Gradle任务","link":"/2021/07/10/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/android_project_graph/"},{"title":"JVM参数","text":"1.参数级别其一是标准参数（-）所有的JVM实现都必须实现这些参数的功能，而且向后兼容； 其二是非标准参数（-X）默认jvm实现这些参数的功能，但是并不保证所有jvm实现都满足，且不保证向后兼容； 其三是非Stable参数（-XX）此类参数各个jvm实现会有所不同，将来可能会随时取消，需要慎重使用； 2.在命令行中可以输出所有XX参数和值-XX:+PrintCommandLineFlags1234567-XX:InitialHeapSize=264819328-XX:MaxHeapSize=4237109248 -XX:+PrintCommandLineFlags-XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC -XX:+PrintFlagsFinal and -XX:+PrintFlagsInitial3 .常见参数BiasedLockingBulkRebiasThreshold = 20 偏置锁定批量重新偏置阈值同一个类的对象，撤销偏向锁升级为轻量级锁 次数达到20，批量重新偏向到当前线程。BiasedLockingBulkRevokeThreshold = 40 偏置锁定批量撤销阈值同一个类的对象，撤销偏向锁升级为轻量级锁 次数超过40，全部批量撤销，升级为轻量级锁。-XX:+PrintGCDetails -XX:BiasedLockingStartupDelay=0 -XX:+TraceBiasedLocking -XX:+PrintGCApplicationStoppedTime 4 .附录728行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728 intx ActiveProcessorCount = -1 {product} uintx AdaptiveSizeDecrementScaleFactor = 4 {product} uintx AdaptiveSizeMajorGCDecayTimeScale = 10 {product} uintx AdaptiveSizePausePolicy = 0 {product} uintx AdaptiveSizePolicyCollectionCostMargin = 50 {product} uintx AdaptiveSizePolicyInitializingSteps = 20 {product} uintx AdaptiveSizePolicyOutputInterval = 0 {product} uintx AdaptiveSizePolicyWeight = 10 {product} uintx AdaptiveSizeThroughPutPolicy = 0 {product} uintx AdaptiveTimeWeight = 25 {product} bool AdjustConcurrency = false {product} bool AggressiveHeap = false {product} bool AggressiveOpts = false {product} intx AliasLevel = 3 {C2 product} bool AlignVector = true {C2 product} intx AllocateInstancePrefetchLines = 1 {product} intx AllocatePrefetchDistance = -1 {product} intx AllocatePrefetchInstr = 0 {product} intx AllocatePrefetchLines = 3 {product} intx AllocatePrefetchStepSize = 16 {product} intx AllocatePrefetchStyle = 1 {product} bool AllowJNIEnvProxy = false {product} bool AllowNonVirtualCalls = false {product} bool AllowParallelDefineClass = false {product} bool AllowUserSignalHandlers = false {product} bool AlwaysActAsServerClassMachine = false {product} bool AlwaysCompileLoopMethods = false {product} bool AlwaysLockClassLoader = false {product} bool AlwaysPreTouch = false {product} bool AlwaysRestoreFPU = false {product} bool AlwaysTenure = false {product} bool AssertOnSuspendWaitFailure = false {product} bool AssumeMP = false {product} intx AutoBoxCacheMax = 128 {C2 product} uintx AutoGCSelectPauseMillis = 5000 {product} intx BCEATraceLevel = 0 {product} intx BackEdgeThreshold = 100000 {pd product} bool BackgroundCompilation = true {pd product} uintx BaseFootPrintEstimate = 268435456 {product} intx BiasedLockingBulkRebiasThreshold = 20 {product} intx BiasedLockingBulkRevokeThreshold = 40 {product} intx BiasedLockingDecayTime = 25000 {product} intx BiasedLockingStartupDelay = 4000 {product} bool BindGCTaskThreadsToCPUs = false {product} bool BlockLayoutByFrequency = true {C2 product} intx BlockLayoutMinDiamondPercentage = 20 {C2 product} bool BlockLayoutRotateLoops = true {C2 product} bool BranchOnRegister = false {C2 product} bool BytecodeVerificationLocal = false {product} bool BytecodeVerificationRemote = true {product} bool C1OptimizeVirtualCallProfiling = true {C1 product} bool C1ProfileBranches = true {C1 product} bool C1ProfileCalls = true {C1 product} bool C1ProfileCheckcasts = true {C1 product} bool C1ProfileInlinedCalls = true {C1 product} bool C1ProfileVirtualCalls = true {C1 product} bool C1UpdateMethodData = true {C1 product} intx CICompilerCount = 2 {product} bool CICompilerCountPerCPU = false {product} bool CITime = false {product} bool CMSAbortSemantics = false {product} uintx CMSAbortablePrecleanMinWorkPerIteration = 100 {product} intx CMSAbortablePrecleanWaitMillis = 100 {manageable} uintx CMSBitMapYieldQuantum = 10485760 {product} uintx CMSBootstrapOccupancy = 50 {product} bool CMSClassUnloadingEnabled = true {product} uintx CMSClassUnloadingMaxInterval = 0 {product} bool CMSCleanOnEnter = true {product} bool CMSCompactWhenClearAllSoftRefs = true {product} uintx CMSConcMarkMultiple = 32 {product} bool CMSConcurrentMTEnabled = true {product} uintx CMSCoordinatorYieldSleepCount = 10 {product} bool CMSDumpAtPromotionFailure = false {product} bool CMSEdenChunksRecordAlways = true {product} uintx CMSExpAvgFactor = 50 {product} bool CMSExtrapolateSweep = false {product} uintx CMSFullGCsBeforeCompaction = 0 {product} uintx CMSIncrementalDutyCycle = 10 {product} uintx CMSIncrementalDutyCycleMin = 0 {product} bool CMSIncrementalMode = false {product} uintx CMSIncrementalOffset = 0 {product} bool CMSIncrementalPacing = true {product} uintx CMSIncrementalSafetyFactor = 10 {product} uintx CMSIndexedFreeListReplenish = 4 {product} intx CMSInitiatingOccupancyFraction = -1 {product} uintx CMSIsTooFullPercentage = 98 {product} double CMSLargeCoalSurplusPercent = 0.950000 {product} double CMSLargeSplitSurplusPercent = 1.000000 {product} bool CMSLoopWarn = false {product} uintx CMSMaxAbortablePrecleanLoops = 0 {product} intx CMSMaxAbortablePrecleanTime = 5000 {product} uintx CMSOldPLABMax = 1024 {product} uintx CMSOldPLABMin = 16 {product} uintx CMSOldPLABNumRefills = 4 {product} uintx CMSOldPLABReactivityFactor = 2 {product} bool CMSOldPLABResizeQuicker = false {product} uintx CMSOldPLABToleranceFactor = 4 {product} bool CMSPLABRecordAlways = true {product} uintx CMSParPromoteBlocksToClaim = 16 {product} bool CMSParallelInitialMarkEnabled = true {product} bool CMSParallelRemarkEnabled = true {product} bool CMSParallelSurvivorRemarkEnabled = true {product} uintx CMSPrecleanDenominator = 3 {product} uintx CMSPrecleanIter = 3 {product} uintx CMSPrecleanNumerator = 2 {product} bool CMSPrecleanRefLists1 = true {product} bool CMSPrecleanRefLists2 = false {product} bool CMSPrecleanSurvivors1 = false {product} bool CMSPrecleanSurvivors2 = true {product} uintx CMSPrecleanThreshold = 1000 {product} bool CMSPrecleaningEnabled = true {product} bool CMSPrintChunksInDump = false {product} bool CMSPrintEdenSurvivorChunks = false {product} bool CMSPrintObjectsInDump = false {product} uintx CMSRemarkVerifyVariant = 1 {product} bool CMSReplenishIntermediate = true {product} uintx CMSRescanMultiple = 32 {product} uintx CMSSamplingGrain = 16384 {product} bool CMSScavengeBeforeRemark = false {product} uintx CMSScheduleRemarkEdenPenetration = 50 {product} uintx CMSScheduleRemarkEdenSizeThreshold = 2097152 {product} uintx CMSScheduleRemarkSamplingRatio = 5 {product} double CMSSmallCoalSurplusPercent = 1.050000 {product} double CMSSmallSplitSurplusPercent = 1.100000 {product} bool CMSSplitIndexedFreeListBlocks = true {product} intx CMSTriggerInterval = -1 {manageable} uintx CMSTriggerRatio = 80 {product} intx CMSWaitDuration = 2000 {manageable} uintx CMSWorkQueueDrainThreshold = 10 {product} bool CMSYield = true {product} uintx CMSYieldSleepCount = 0 {product} uintx CMSYoungGenPerWorker = 67108864 {pd product} uintx CMS_FLSPadding = 1 {product} uintx CMS_FLSWeight = 75 {product} uintx CMS_SweepPadding = 1 {product} uintx CMS_SweepTimerThresholdMillis = 10 {product} uintx CMS_SweepWeight = 75 {product} bool CheckEndorsedAndExtDirs = false {product} bool CheckJNICalls = false {product} bool ClassUnloading = true {product} bool ClassUnloadingWithConcurrentMark = true {product} intx ClearFPUAtPark = 0 {product} bool ClipInlining = true {product} uintx CodeCacheExpansionSize = 65536 {pd product} uintx CodeCacheMinimumFreeSpace = 512000 {product} bool CollectGen0First = false {product} bool CompactFields = true {product} intx CompilationPolicyChoice = 0 {product}ccstrlist CompileCommand = {product} ccstr CompileCommandFile = {product}ccstrlist CompileOnly = {product} intx CompileThreshold = 10000 {pd product} bool CompilerThreadHintNoPreempt = true {product} intx CompilerThreadPriority = -1 {product} intx CompilerThreadStackSize = 0 {pd product} uintx CompressedClassSpaceSize = 1073741824 {product} uintx ConcGCThreads = 0 {product} intx ConditionalMoveLimit = 3 {C2 pd product} intx ContendedPaddingWidth = 128 {product} bool ConvertSleepToYield = true {pd product} bool ConvertYieldToSleep = false {product} bool CrashOnOutOfMemoryError = false {product} bool CreateMinidumpOnCrash = false {product} bool CriticalJNINatives = true {product} bool DTraceAllocProbes = false {product} bool DTraceMethodProbes = false {product} bool DTraceMonitorProbes = false {product} bool Debugging = false {product} uintx DefaultMaxRAMFraction = 4 {product} intx DefaultThreadPriority = -1 {product} intx DeferPollingPageLoopCount = -1 {product} intx DeferThrSuspendLoopCount = 4000 {product} bool DeoptimizeRandom = false {product} bool DisableAttachMechanism = false {product} bool DisableExplicitGC = false {product} bool DisplayVMOutputToStderr = false {product} bool DisplayVMOutputToStdout = false {product} bool DoEscapeAnalysis = true {C2 product} bool DontCompileHugeMethods = true {product} bool DontYieldALot = false {pd product} ccstr DumpLoadedClassList = {product} bool DumpReplayDataOnError = true {product} bool DumpSharedSpaces = false {product} bool EagerXrunInit = false {product} intx EliminateAllocationArraySizeLimit = 64 {C2 product} bool EliminateAllocations = true {C2 product} bool EliminateAutoBox = true {C2 product} bool EliminateLocks = true {C2 product} bool EliminateNestedLocks = true {C2 product} intx EmitSync = 0 {product} bool EnableContended = true {product} bool EnableResourceManagementTLABCache = true {product} bool EnableSharedLookupCache = true {product} bool EnableTracing = false {product} uintx ErgoHeapSizeLimit = 0 {product} ccstr ErrorFile = {product} ccstr ErrorReportServer = {product} double EscapeAnalysisTimeout = 20.000000 {C2 product} bool EstimateArgEscape = true {product} bool ExitOnOutOfMemoryError = false {product} bool ExplicitGCInvokesConcurrent = false {product} bool ExplicitGCInvokesConcurrentAndUnloadsClasses = false {product} bool ExtendedDTraceProbes = false {product} ccstr ExtraSharedClassListFile = {product} bool FLSAlwaysCoalesceLarge = false {product} uintx FLSCoalescePolicy = 2 {product} double FLSLargestBlockCoalesceProximity = 0.990000 {product} bool FailOverToOldVerifier = true {product} bool FastTLABRefill = true {product} intx FenceInstruction = 0 {ARCH product} intx FieldsAllocationStyle = 1 {product} bool FilterSpuriousWakeups = true {product} ccstr FlightRecorderOptions = {product} bool ForceNUMA = false {product} bool ForceTimeHighResolution = false {product} intx FreqInlineSize = 325 {pd product} double G1ConcMarkStepDurationMillis = 10.000000 {product} uintx G1ConcRSHotCardLimit = 4 {product} uintx G1ConcRSLogCacheSize = 10 {product} intx G1ConcRefinementGreenZone = 0 {product} intx G1ConcRefinementRedZone = 0 {product} intx G1ConcRefinementServiceIntervalMillis = 300 {product} uintx G1ConcRefinementThreads = 0 {product} intx G1ConcRefinementThresholdStep = 0 {product} intx G1ConcRefinementYellowZone = 0 {product} uintx G1ConfidencePercent = 50 {product} uintx G1HeapRegionSize = 0 {product} uintx G1HeapWastePercent = 5 {product} uintx G1MixedGCCountTarget = 8 {product} intx G1RSetRegionEntries = 0 {product} uintx G1RSetScanBlockSize = 64 {product} intx G1RSetSparseRegionEntries = 0 {product} intx G1RSetUpdatingPauseTimePercent = 10 {product} intx G1RefProcDrainInterval = 10 {product} uintx G1ReservePercent = 10 {product} uintx G1SATBBufferEnqueueingThresholdPercent = 60 {product} intx G1SATBBufferSize = 1024 {product} intx G1UpdateBufferSize = 256 {product} bool G1UseAdaptiveConcRefinement = true {product} uintx GCDrainStackTargetSize = 64 {product} uintx GCHeapFreeLimit = 2 {product} uintx GCLockerEdenExpansionPercent = 5 {product} bool GCLockerInvokesConcurrent = false {product} uintx GCLogFileSize = 8192 {product} uintx GCPauseIntervalMillis = 0 {product} uintx GCTaskTimeStampEntries = 200 {product} uintx GCTimeLimit = 98 {product} uintx GCTimeRatio = 99 {product} uintx HeapBaseMinAddress = 2147483648 {pd product} bool HeapDumpAfterFullGC = false {manageable} bool HeapDumpBeforeFullGC = false {manageable} bool HeapDumpOnOutOfMemoryError = false {manageable} ccstr HeapDumpPath = {manageable} uintx HeapFirstMaximumCompactionCount = 3 {product} uintx HeapMaximumCompactionInterval = 20 {product} uintx HeapSizePerGCThread = 87241520 {product} bool IgnoreEmptyClassPaths = false {product} bool IgnoreUnrecognizedVMOptions = false {product} uintx IncreaseFirstTierCompileThresholdAt = 50 {product} bool IncrementalInline = true {C2 product} uintx InitialBootClassLoaderMetaspaceSize = 4194304 {product} uintx InitialCodeCacheSize = 2555904 {pd product} uintx InitialHeapSize = 0 {product} uintx InitialRAMFraction = 64 {product} double InitialRAMPercentage = 1.562500 {product} uintx InitialSurvivorRatio = 8 {product} uintx InitialTenuringThreshold = 7 {product} uintx InitiatingHeapOccupancyPercent = 45 {product} bool Inline = true {product} ccstr InlineDataFile = {product} intx InlineSmallCode = 1000 {pd product} bool InlineSynchronizedMethods = true {C1 product} bool InsertMemBarAfterArraycopy = true {C2 product} intx InteriorEntryAlignment = 16 {C2 pd product} intx InterpreterProfilePercentage = 33 {product} bool JNIDetachReleasesMonitors = true {product} bool JavaMonitorsInStackTrace = true {product} intx JavaPriority10_To_OSPriority = -1 {product} intx JavaPriority1_To_OSPriority = -1 {product} intx JavaPriority2_To_OSPriority = -1 {product} intx JavaPriority3_To_OSPriority = -1 {product} intx JavaPriority4_To_OSPriority = -1 {product} intx JavaPriority5_To_OSPriority = -1 {product} intx JavaPriority6_To_OSPriority = -1 {product} intx JavaPriority7_To_OSPriority = -1 {product} intx JavaPriority8_To_OSPriority = -1 {product} intx JavaPriority9_To_OSPriority = -1 {product} bool LIRFillDelaySlots = false {C1 pd product} uintx LargePageHeapSizeThreshold = 134217728 {product} uintx LargePageSizeInBytes = 0 {product} bool LazyBootClassLoader = true {product} intx LiveNodeCountInliningCutoff = 40000 {C2 product} bool LogCommercialFeatures = false {product} intx LoopMaxUnroll = 16 {C2 product} intx LoopOptsCount = 43 {C2 product} intx LoopUnrollLimit = 60 {C2 pd product} intx LoopUnrollMin = 4 {C2 product} bool LoopUnswitching = true {C2 product} bool ManagementServer = false {product} uintx MarkStackSize = 4194304 {product} uintx MarkStackSizeMax = 536870912 {product} uintx MarkSweepAlwaysCompactCount = 4 {product} uintx MarkSweepDeadRatio = 5 {product} intx MaxBCEAEstimateLevel = 5 {product} intx MaxBCEAEstimateSize = 150 {product} uintx MaxDirectMemorySize = 0 {product} bool MaxFDLimit = true {product} uintx MaxGCMinorPauseMillis = 4294967295 {product} uintx MaxGCPauseMillis = 4294967295 {product} uintx MaxHeapFreeRatio = 70 {manageable} uintx MaxHeapSize = 130862280 {product} intx MaxInlineLevel = 9 {product} intx MaxInlineSize = 35 {product} intx MaxJNILocalCapacity = 65536 {product} intx MaxJavaStackTraceDepth = 1024 {product} intx MaxJumpTableSize = 65000 {C2 product} intx MaxJumpTableSparseness = 5 {C2 product} intx MaxLabelRootDepth = 1100 {C2 product} intx MaxLoopPad = 15 {C2 product} uintx MaxMetaspaceExpansion = 5452592 {product} uintx MaxMetaspaceFreeRatio = 70 {product} uintx MaxMetaspaceSize = 4294967295 {product} uintx MaxNewSize = 4294967295 {product} intx MaxNodeLimit = 80000 {C2 product} uint64_t MaxRAM = 0 {pd product} uintx MaxRAMFraction = 4 {product} double MaxRAMPercentage = 25.000000 {product} intx MaxRecursiveInlineLevel = 1 {product} uintx MaxTenuringThreshold = 15 {product} intx MaxTrivialSize = 6 {product} intx MaxVectorSize = 32 {C2 product} uintx MetaspaceSize = 21810376 {pd product} bool MethodFlushing = true {product} uintx MinHeapDeltaBytes = 170392 {product} uintx MinHeapFreeRatio = 40 {manageable} intx MinInliningThreshold = 250 {product} intx MinJumpTableSize = 10 {C2 pd product} uintx MinMetaspaceExpansion = 340784 {product} uintx MinMetaspaceFreeRatio = 40 {product} uintx MinRAMFraction = 2 {product} double MinRAMPercentage = 50.000000 {product} uintx MinSurvivorRatio = 3 {product} uintx MinTLABSize = 2048 {product} intx MonitorBound = 0 {product} bool MonitorInUseLists = false {product} intx MultiArrayExpandLimit = 6 {C2 product} bool MustCallLoadClassInternal = false {product} uintx NUMAChunkResizeWeight = 20 {product} uintx NUMAInterleaveGranularity = 2097152 {product} uintx NUMAPageScanRate = 256 {product} uintx NUMASpaceResizeRate = 1073741824 {product} bool NUMAStats = false {product} ccstr NativeMemoryTracking = off {product} bool NeedsDeoptSuspend = false {pd product} bool NeverActAsServerClassMachine = false {pd product} bool NeverTenure = false {product} uintx NewRatio = 2 {product} uintx NewSize = 1363144 {product} uintx NewSizeThreadIncrease = 5320 {pd product} intx NmethodSweepActivity = 10 {product} intx NmethodSweepCheckInterval = 5 {product} intx NmethodSweepFraction = 16 {product} intx NodeLimitFudgeFactor = 2000 {C2 product} uintx NumberOfGCLogFiles = 0 {product} intx NumberOfLoopInstrToAlign = 4 {C2 product} intx ObjectAlignmentInBytes = 8 {lp64_product} uintx OldPLABSize = 1024 {product} uintx OldPLABWeight = 50 {product} uintx OldSize = 5452592 {product} bool OmitStackTraceInFastThrow = true {product}ccstrlist OnError = {product}ccstrlist OnOutOfMemoryError = {product} intx OnStackReplacePercentage = 140 {pd product} bool OptimizeFill = true {C2 product} bool OptimizePtrCompare = true {C2 product} bool OptimizeStringConcat = true {C2 product} bool OptoBundling = false {C2 pd product} intx OptoLoopAlignment = 16 {pd product} bool OptoScheduling = false {C2 pd product} uintx PLABWeight = 75 {product} bool PSChunkLargeArrays = true {product} intx ParGCArrayScanChunk = 50 {product} uintx ParGCDesiredObjsFromOverflowList = 20 {product} bool ParGCTrimOverflow = true {product} bool ParGCUseLocalOverflow = false {product} uintx ParallelGCBufferWastePct = 10 {product} uintx ParallelGCThreads = 0 {product} bool ParallelGCVerbose = false {product} uintx ParallelOldDeadWoodLimiterMean = 50 {product} uintx ParallelOldDeadWoodLimiterStdDev = 80 {product} bool ParallelRefProcBalancingEnabled = true {product} bool ParallelRefProcEnabled = false {product} bool PartialPeelAtUnsignedTests = true {C2 product} bool PartialPeelLoop = true {C2 product} intx PartialPeelNewPhiDelta = 0 {C2 product} uintx PausePadding = 1 {product} intx PerBytecodeRecompilationCutoff = 200 {product} intx PerBytecodeTrapLimit = 4 {product} intx PerMethodRecompilationCutoff = 400 {product} intx PerMethodTrapLimit = 100 {product} bool PerfAllowAtExitRegistration = false {product} bool PerfBypassFileSystemCheck = false {product} intx PerfDataMemorySize = 32768 {product} intx PerfDataSamplingInterval = 50 {product} ccstr PerfDataSaveFile = {product} bool PerfDataSaveToFile = false {product} bool PerfDisableSharedMem = false {product} intx PerfMaxStringConstLength = 1024 {product} intx PreInflateSpin = 10 {pd product} bool PreferInterpreterNativeStubs = false {pd product} intx PrefetchCopyIntervalInBytes = -1 {product} intx PrefetchFieldsAhead = -1 {product} intx PrefetchScanIntervalInBytes = -1 {product} bool PreserveAllAnnotations = false {product} bool PreserveFramePointer = false {pd product} uintx PretenureSizeThreshold = 0 {product} bool PrintAdaptiveSizePolicy = false {product} bool PrintCMSInitiationStatistics = false {product} intx PrintCMSStatistics = 0 {product} bool PrintClassHistogram = false {manageable} bool PrintClassHistogramAfterFullGC = false {manageable} bool PrintClassHistogramBeforeFullGC = false {manageable} bool PrintCodeCache = false {product} bool PrintCodeCacheOnCompilation = false {product} bool PrintCommandLineFlags = false {product} bool PrintCompilation = false {product} bool PrintConcurrentLocks = false {manageable} intx PrintFLSCensus = 0 {product} intx PrintFLSStatistics = 0 {product} bool PrintFlagsFinal = false {product} bool PrintFlagsInitial = false {product} bool PrintGC = false {manageable} bool PrintGCApplicationConcurrentTime = false {product} bool PrintGCApplicationStoppedTime = false {product} bool PrintGCCause = true {product} bool PrintGCDateStamps = false {manageable} bool PrintGCDetails = false {manageable} bool PrintGCID = false {manageable} bool PrintGCTaskTimeStamps = false {product} bool PrintGCTimeStamps = false {manageable} bool PrintHeapAtGC = false {product rw} bool PrintHeapAtGCExtended = false {product rw} bool PrintHeapAtSIGBREAK = true {product} bool PrintJNIGCStalls = false {product} bool PrintJNIResolving = false {product} bool PrintOldPLAB = false {product} bool PrintOopAddress = false {product} bool PrintPLAB = false {product} bool PrintParallelOldGCPhaseTimes = false {product} bool PrintPromotionFailure = false {product} bool PrintReferenceGC = false {product} bool PrintSafepointStatistics = false {product} intx PrintSafepointStatisticsCount = 300 {product} intx PrintSafepointStatisticsTimeout = -1 {product} bool PrintSharedArchiveAndExit = false {product} bool PrintSharedDictionary = false {product} bool PrintSharedSpaces = false {product} bool PrintStringDeduplicationStatistics = false {product} bool PrintStringTableStatistics = false {product} bool PrintTLAB = false {product} bool PrintTenuringDistribution = false {product} bool PrintTieredEvents = false {product} bool PrintVMOptions = false {product} bool PrintVMQWaitTime = false {product} bool PrintWarnings = true {product} uintx ProcessDistributionStride = 4 {product} bool ProfileInterpreter = true {pd product} bool ProfileIntervals = false {product} intx ProfileIntervalsTicks = 100 {product} intx ProfileMaturityPercentage = 20 {product} bool ProfileVM = false {product} bool ProfilerPrintByteCodeStatistics = false {product} bool ProfilerRecordPC = false {product} uintx PromotedPadding = 3 {product} uintx QueuedAllocationWarningCount = 0 {product} uintx RTMRetryCount = 5 {ARCH product} bool RangeCheckElimination = true {product} intx ReadPrefetchInstr = 0 {ARCH product} bool ReassociateInvariants = true {C2 product} bool ReduceBulkZeroing = true {C2 product} bool ReduceFieldZeroing = true {C2 product} bool ReduceInitialCardMarks = true {C2 product} bool ReduceSignalUsage = false {product} intx RefDiscoveryPolicy = 0 {product} bool ReflectionWrapResolutionErrors = true {product} bool RegisterFinalizersAtInit = true {product} bool RelaxAccessControlCheck = false {product} ccstr ReplayDataFile = {product} bool RequireSharedSpaces = false {product} uintx ReservedCodeCacheSize = 50331648 {pd product} bool ResizeOldPLAB = true {product} bool ResizePLAB = true {product} bool ResizeTLAB = true {pd product} bool RestoreMXCSROnJNICalls = false {product} bool RestrictContended = true {product} bool RewriteBytecodes = true {pd product} bool RewriteFrequentPairs = true {pd product} intx SafepointPollOffset = 256 {C1 pd product} intx SafepointSpinBeforeYield = 2000 {product} bool SafepointTimeout = false {product} intx SafepointTimeoutDelay = 10000 {product} bool ScavengeBeforeFullGC = true {product} intx SelfDestructTimer = 0 {product} uintx SharedBaseAddress = 0 {product} ccstr SharedClassListFile = {product} uintx SharedMiscCodeSize = 122880 {product} uintx SharedMiscDataSize = 4194304 {product} uintx SharedReadOnlySize = 16777216 {product} uintx SharedReadWriteSize = 16777216 {product} bool ShowMessageBoxOnError = false {product} intx SoftRefLRUPolicyMSPerMB = 1000 {product} bool SpecialEncodeISOArray = true {C2 product} bool SplitIfBlocks = true {C2 product} intx StackRedPages = 1 {pd product} intx StackShadowPages = 6 {pd product} bool StackTraceInThrowable = true {product} intx StackYellowPages = 3 {pd product} bool StartAttachListener = false {product} intx StarvationMonitorInterval = 200 {product} bool StressLdcRewrite = false {product} uintx StringDeduplicationAgeThreshold = 3 {product} uintx StringTableSize = 60013 {product} bool SuppressFatalErrorMessage = false {product} uintx SurvivorPadding = 3 {product} uintx SurvivorRatio = 8 {product} intx SuspendRetryCount = 50 {product} intx SuspendRetryDelay = 5 {product} intx SyncFlags = 0 {product} ccstr SyncKnobs = {product} intx SyncVerbose = 0 {product} uintx TLABAllocationWeight = 35 {product} uintx TLABRefillWasteFraction = 64 {product} uintx TLABSize = 0 {product} bool TLABStats = true {product} uintx TLABWasteIncrement = 4 {product} uintx TLABWasteTargetPercent = 1 {product} uintx TargetPLABWastePct = 10 {product} uintx TargetSurvivorRatio = 50 {product} uintx TenuredGenerationSizeIncrement = 20 {product} uintx TenuredGenerationSizeSupplement = 80 {product} uintx TenuredGenerationSizeSupplementDecay = 2 {product} intx ThreadPriorityPolicy = 0 {product} bool ThreadPriorityVerbose = false {product} uintx ThreadSafetyMargin = 52428800 {product} intx ThreadStackSize = 0 {pd product} uintx ThresholdTolerance = 10 {product} intx Tier0BackedgeNotifyFreqLog = 10 {product} intx Tier0InvokeNotifyFreqLog = 7 {product} intx Tier0ProfilingStartPercentage = 200 {product} intx Tier23InlineeNotifyFreqLog = 20 {product} intx Tier2BackEdgeThreshold = 0 {product} intx Tier2BackedgeNotifyFreqLog = 14 {product} intx Tier2CompileThreshold = 0 {product} intx Tier2InvokeNotifyFreqLog = 11 {product} intx Tier3BackEdgeThreshold = 60000 {product} intx Tier3BackedgeNotifyFreqLog = 13 {product} intx Tier3CompileThreshold = 2000 {product} intx Tier3DelayOff = 2 {product} intx Tier3DelayOn = 5 {product} intx Tier3InvocationThreshold = 200 {product} intx Tier3InvokeNotifyFreqLog = 10 {product} intx Tier3LoadFeedback = 5 {product} intx Tier3MinInvocationThreshold = 100 {product} intx Tier4BackEdgeThreshold = 40000 {product} intx Tier4CompileThreshold = 15000 {product} intx Tier4InvocationThreshold = 5000 {product} intx Tier4LoadFeedback = 3 {product} intx Tier4MinInvocationThreshold = 600 {product} bool TieredCompilation = true {pd product} intx TieredCompileTaskTimeout = 50 {product} intx TieredRateUpdateMaxTime = 25 {product} intx TieredRateUpdateMinTime = 1 {product} intx TieredStopAtLevel = 4 {product} bool TimeLinearScan = false {C1 product} bool TraceBiasedLocking = false {product} bool TraceClassLoading = false {product rw} bool TraceClassLoadingPreorder = false {product} bool TraceClassPaths = false {product} bool TraceClassResolution = false {product} bool TraceClassUnloading = false {product rw} bool TraceDynamicGCThreads = false {product} bool TraceGen0Time = false {product} bool TraceGen1Time = false {product} ccstr TraceJVMTI = {product} bool TraceLoaderConstraints = false {product rw} bool TraceMetadataHumongousAllocation = false {product} bool TraceMonitorInflation = false {product} bool TraceParallelOldGCTasks = false {product} intx TraceRedefineClasses = 0 {product} bool TraceSafepointCleanupTime = false {product} bool TraceSharedLookupCache = false {product} bool TraceSuspendWaitFailures = false {product} intx TrackedInitializationLimit = 50 {C2 product} bool TransmitErrorReport = false {product} bool TrapBasedNullChecks = false {pd product} bool TrapBasedRangeChecks = false {C2 pd product} intx TypeProfileArgsLimit = 2 {product} uintx TypeProfileLevel = 111 {pd product} intx TypeProfileMajorReceiverPercent = 90 {C2 product} intx TypeProfileParmsLimit = 2 {product} intx TypeProfileWidth = 2 {product} intx UnguardOnExecutionViolation = 0 {product} bool UnlinkSymbolsALot = false {product} bool Use486InstrsOnly = false {ARCH product} bool UseAES = false {product} bool UseAESIntrinsics = false {product} intx UseAVX = 99 {ARCH product} bool UseAdaptiveGCBoundary = false {product} bool UseAdaptiveGenerationSizePolicyAtMajorCollection = true {product} bool UseAdaptiveGenerationSizePolicyAtMinorCollection = true {product} bool UseAdaptiveNUMAChunkSizing = true {product} bool UseAdaptiveSizeDecayMajorGCCost = true {product} bool UseAdaptiveSizePolicy = true {product} bool UseAdaptiveSizePolicyFootprintGoal = true {product} bool UseAdaptiveSizePolicyWithSystemGC = false {product} bool UseAddressNop = false {ARCH product} bool UseAltSigs = false {product} bool UseAutoGCSelectPolicy = false {product} bool UseBMI1Instructions = false {ARCH product} bool UseBMI2Instructions = false {ARCH product} bool UseBiasedLocking = true {product} bool UseBimorphicInlining = true {C2 product} bool UseBoundThreads = true {product} bool UseCLMUL = false {ARCH product} bool UseCMSBestFit = true {product} bool UseCMSCollectionPassing = true {product} bool UseCMSCompactAtFullCollection = true {product} bool UseCMSInitiatingOccupancyOnly = false {product} bool UseCRC32Intrinsics = false {product} bool UseCodeCacheFlushing = true {product} bool UseCompiler = true {product} bool UseCompilerSafepoints = true {product} bool UseCompressedClassPointers = false {lp64_product} bool UseCompressedOops = false {lp64_product} bool UseConcMarkSweepGC = false {product} bool UseCondCardMark = false {C2 product} bool UseCountLeadingZerosInstruction = false {ARCH product} bool UseCountTrailingZerosInstruction = false {ARCH product} bool UseCountedLoopSafepoints = false {C2 product} bool UseCounterDecay = true {product} bool UseDivMod = true {C2 product} bool UseDynamicNumberOfGCThreads = false {product} bool UseFPUForSpilling = false {C2 product} bool UseFastAccessorMethods = true {product} bool UseFastEmptyMethods = true {product} bool UseFastJNIAccessors = true {product} bool UseFastStosb = false {ARCH product} bool UseG1GC = false {product} bool UseGCLogFileRotation = false {product} bool UseGCOverheadLimit = true {product} bool UseGCTaskAffinity = false {product} bool UseHeavyMonitors = false {product} bool UseInlineCaches = true {product} bool UseInterpreter = true {product} bool UseJumpTables = true {C2 product} bool UseLWPSynchronization = true {product} bool UseLargePages = false {pd product} bool UseLargePagesInMetaspace = false {product} bool UseLargePagesIndividualAllocation := false {pd product} bool UseLockedTracing = false {product} bool UseLoopCounter = true {product} bool UseLoopInvariantCodeMotion = true {C1 product} bool UseLoopPredicate = true {C2 product} bool UseMathExactIntrinsics = true {C2 product} bool UseMaximumCompactionOnSystemGC = true {product} bool UseMembar = false {pd product} bool UseMontgomeryMultiplyIntrinsic = false {C2 product} bool UseMontgomerySquareIntrinsic = false {C2 product} bool UseMulAddIntrinsic = false {C2 product} bool UseMultiplyToLenIntrinsic = false {C2 product} bool UseNUMA = false {product} bool UseNUMAInterleaving = false {product} bool UseNewLongLShift = false {ARCH product} bool UseOSErrorReporting = false {pd product} bool UseOldInlining = true {C2 product} bool UseOnStackReplacement = true {pd product} bool UseOnlyInlinedBimorphic = true {C2 product} bool UseOptoBiasInlining = true {C2 product} bool UsePSAdaptiveSurvivorSizePolicy = true {product} bool UseParNewGC = false {product} bool UseParallelGC = false {product} bool UseParallelOldGC = false {product} bool UsePerfData = true {product} bool UsePopCountInstruction = false {product} bool UseRDPCForConstantTableBase = false {C2 product} bool UseRTMDeopt = false {ARCH product} bool UseRTMLocking = false {ARCH product} bool UseSHA = false {product} bool UseSHA1Intrinsics = false {product} bool UseSHA256Intrinsics = false {product} bool UseSHA512Intrinsics = false {product} intx UseSSE = 99 {product} bool UseSSE42Intrinsics = false {product} bool UseSerialGC = false {product} bool UseSharedSpaces = true {product} bool UseSignalChaining = true {product} bool UseSquareToLenIntrinsic = false {C2 product} bool UseStoreImmI16 = true {ARCH product} bool UseStringDeduplication = false {product} bool UseSuperWord = true {C2 product} bool UseTLAB = true {pd product} bool UseThreadPriorities = true {pd product} bool UseTypeProfile = true {product} bool UseTypeSpeculation = true {C2 product} bool UseUTCFileTimestamp = true {product} bool UseUnalignedLoadStores = false {ARCH product} bool UseVMInterruptibleIO = false {product} bool UseXMMForArrayCopy = false {product} bool UseXmmI2D = false {ARCH product} bool UseXmmI2F = false {ARCH product} bool UseXmmLoadAndClearUpper = true {ARCH product} bool UseXmmRegToRegMoveAll = false {ARCH product} bool VMThreadHintNoPreempt = false {product} intx VMThreadPriority = -1 {product} intx VMThreadStackSize = 0 {pd product} intx ValueMapInitialSize = 11 {C1 product} intx ValueMapMaxLoopSize = 8 {C1 product} intx ValueSearchLimit = 1000 {C2 product} bool VerifyMergedCPBytecodes = true {product} bool VerifySharedSpaces = false {product} intx WorkAroundNPTLTimedWaitHang = 1 {product} uintx YoungGenerationSizeIncrement = 20 {product} uintx YoungGenerationSizeSupplement = 80 {product} uintx YoungGenerationSizeSupplementDecay = 8 {product} uintx YoungPLABSize = 4096 {product} bool ZeroTLAB = false {product} intx hashCode = 5 {product}","link":"/2019/10/13/Java/JVM%E5%8F%82%E6%95%B0/"},{"title":"MacOS Python获取系统版本不对","text":"背景今天遇到个奇怪的问题，在conda安装软件，不能自动获取最新的版本，查看了一下info，发现里面获取的系统版本不对，开始怀疑是这个版本的问题，但是在deactive conda之后，获取的版本是正确的 1conda info 显示错误的版本在conda外面打印版本，是✅的于是代码查看了一下，Python 源码 123456789101112131415161718def mac_ver(release='', versioninfo=('', '', ''), machine=''): \"\"\" Get macOS version information and return it as tuple (release, versioninfo, machine) with versioninfo being a tuple (version, dev_stage, non_release_version). Entries which cannot be determined are set to the parameter values which default to ''. All tuple entries are strings. \"\"\" # First try reading the information from an XML file which should # always be present info = _mac_ver_xml() if info is not None: return info # If that also doesn't work return the default values return release, versioninfo, machine 其实就是读取的 /System/Library/CoreServices/SystemVersion.plist 1234567891011121314151617181920212223242526def _mac_ver_xml(): fn = '/System/Library/CoreServices/SystemVersion.plist' if not os.path.exists(fn): if 'SDKROOT' in os.environ: fn = os.environ['SDKROOT'] + fn if not os.path.exists(fn): return None else: return None try: import plistlib except ImportError: return None with open(fn, 'rb') as f: pl = plistlib.load(f) release = pl['ProductVersion'] versioninfo = ('', '', '') machine = os.uname().machine if machine in ('ppc', 'Power Macintosh'): # Canonical name machine = 'PowerPC' return release, versioninfo, machine 对比了2个环境的SystemVersion.plist，就是同一个，cat 出来的版本不一样conda deactive 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;ProductBuildVersion&lt;/key&gt; &lt;string&gt;22C65&lt;/string&gt; &lt;key&gt;ProductCopyright&lt;/key&gt; &lt;string&gt;1983-2022 Apple Inc.&lt;/string&gt; &lt;key&gt;ProductName&lt;/key&gt; &lt;string&gt;macOS&lt;/string&gt; &lt;key&gt;ProductUserVisibleVersion&lt;/key&gt; &lt;string&gt;13.1&lt;/string&gt; &lt;key&gt;ProductVersion&lt;/key&gt; &lt;string&gt;13.1&lt;/string&gt; &lt;key&gt;iOSSupportVersion&lt;/key&gt; &lt;string&gt;16.2&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; conda active 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;ProductBuildVersion&lt;/key&gt; &lt;string&gt;22C65&lt;/string&gt; &lt;key&gt;ProductCopyright&lt;/key&gt; &lt;string&gt;1983-2022 Apple Inc.&lt;/string&gt; &lt;key&gt;ProductName&lt;/key&gt; &lt;string&gt;Mac OS X&lt;/string&gt; &lt;key&gt;ProductUserVisibleVersion&lt;/key&gt; &lt;string&gt;10.16&lt;/string&gt; &lt;key&gt;ProductVersion&lt;/key&gt; &lt;string&gt;10.16&lt;/string&gt; &lt;key&gt;iOSSupportVersion&lt;/key&gt; &lt;string&gt;16.2&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; 都是cat的同一个路径文件，有点不理解了，都是同一个文件，为啥cat出来的内容不一样？简直反科学 同一个文件内容不一样？网上查了下https://stackoverflow.com/questions/69097567/macos-version-returned-as-10-16-instead-of-12-0https://eclecticlight.co/2020/08/13/macos-version-numbering-isnt-so-simple/大致是mac os考虑到，兼容性，在open的时候，hook掉了SystemVersion.plist，指向了 SystemVersionCompat.plis，同时留给了一个开关给我们控制，那就是环境变量SYSTEM_VERSION_COMPAT 解决办法控制环境变量 1export SYSTEM_VERSION_COMPAT = 0","link":"/2023/05/14/%E9%97%AE%E9%A2%98%E4%B8%8E%E7%BB%8F%E9%AA%8C/conda_macos_ver_python/"},{"title":"泛型的反序列化","text":"简化问题日常使用过程中，我们经常碰到泛型的序列化Json，但是有时候我们需要把一个Json反序列化成一个泛型对象，怎么做，你可能会想到这样做，例如在Gson中 1Gson().fromJson&lt;List&lt;String&gt;&gt;(JsonString, List&lt;String&gt;::class.java) 但是你这样写，其实会遇到一个错误 ** Only classes are allowed on the left hand side of a class literal**为什么会这样，因为泛型有类型擦除，泛型其实只是在编译的存在，运行的时候是不存在的，而反序列化需要再运行的时候获取到具体的类型，而类型却被擦除了，所以会报错，那么怎么办？ 泛型怎么反序列化成对象？看函数的参数类型 12345678910111213141516//这里要的是个classpublic &lt;T&gt; T fromJson(String json, Class&lt;T&gt; classOfT) throws JsonSyntaxException { // 都转成到这里 T object = fromJson(json, TypeToken.get(classOfT)); return Primitives.wrap(classOfT).cast(object); }// 其实需要的是一个TypeTokenpublic &lt;T&gt; T fromJson(String json, TypeToken&lt;T&gt; typeOfT) throws JsonSyntaxException { if (json == null) { return null; } StringReader reader = new StringReader(json); return fromJson(reader, typeOfT); } TypeToken实际上是私有的 123456789101112131415public class TypeToken&lt;T&gt; { @SuppressWarnings(\"unchecked\") protected TypeToken() { this.type = getTypeTokenTypeArgument(); this.rawType = (Class&lt;? super T&gt;) $Gson$Types.getRawType(type); this.hashCode = type.hashCode(); } @SuppressWarnings(\"unchecked\") private TypeToken(Type type) { this.type = $Gson$Types.canonicalize(Objects.requireNonNull(type)); this.rawType = (Class&lt;? super T&gt;) $Gson$Types.getRawType(this.type); this.hashCode = this.type.hashCode(); }} 我们可以通过构造Type来达到目的, 但是这个Type是接口，我们需要构造ParameterizedType 123public &lt;T&gt; T fromJson(String json, Type typeOfT) throws JsonSyntaxException { return (T) fromJson(json, TypeToken.get(typeOfT));} 1234567891011fun main(args: Array&lt;String&gt;) { Gson().fromJson&lt;List&lt;String&gt;&gt;(\"JsonString\", getType(List::class.java, String::class.java))}fun getType(raw: Class&lt;*&gt;, vararg args: Type) = object : ParameterizedType { //原始类型，例如List&lt;String&gt;，整体看来就是List override fun getRawType(): Type = raw // 泛型 参数，例如有多个 override fun getActualTypeArguments(): Array&lt;out Type&gt; = args //顶层类就是null，Type 对象，表示此类型是其成员之一的类型，例如Map接口就是Map.Entry的OwnerType. override fun getOwnerType(): Type? = null} 如果有多重泛型怎么写，getType可以嵌套调用的，通过Type构成Type 12//List&lt;List&lt;String&gt;&gt;getType(List::class.java, getType(List::class.java, String::class.java))","link":"/2023/05/14/%E9%97%AE%E9%A2%98%E4%B8%8E%E7%BB%8F%E9%AA%8C/typetojson/"},{"title":"解决 Compose Layout Inspector 不能用","text":"错误信息当你辛苦写完一个页面，打开Layout Inspector 发现不能使用 123Could not download androidx.compose.ui:ui:1.5.0-alphao1 from maven.google.com. Check the internet connection. For offline repositories (not common) please specify -Dappinspection.use.dev.jar=true as a custom VM property. 解决办法： 打开Help-&gt;Edit Custom VM Options 添加参数-Dappinspection.use.dev.jar=true 如果你只做这一步，你会发现会报另一个错误，提示找不到compose-ui-inspection.jar，所以我们继续往下修改 找到 grade androidx.compose.ui 的目录，例如可以在AndroidStudio的依赖里面看到 并打开目录 我们可以看到一个inspector.jar的文件 将inspector.ja复制到compose.jar 复制到AS的安装目录下的，例如macos下的，Applications/Android Studio.app/Contents/plugins/android/resources目录，并重命名为compose-ui-inspection.jar 重启一下Android Studio","link":"/2023/08/12/Android/compose_inspector/"},{"title":"Kotlin的变量重名问题","text":"问题背景以下是一个简化的问题，可以思考一下，以下代码会出现什么问题 12345678910111213interface Student { fun getName(): String}class Main : Student { private val name by lazy { \"name\" } override fun getName() = name}//测试，例如我要这样调用fun main() { println(Main().getName())} 实际上，上面的代码在IDE中，并没有任何提示和报错信息，只有在编译的时候才会出现如下错误， 123Platform declaration clash: The following declarations have the same JVM signature (getName()Ljava/lang/String;): fun `&lt;get-name&gt;`(): String defined in Main fun getName(): String defined in Main 大意是说，2个方法名重复了，为什么呢？ 解惑Kotlin与Java不同的之一，就是Kotlin会默认给变量添加get和set方法，默认的规则也是变量名前面直接添加get或set，如果我们在显示的写了一个方法名相同的函数，就有可能出现方法签名冲突，所以上面的情况就出现了方法名的冲突。如果我们去掉显示写的getName()，可以看到生成的函数 12345678public final class Main { private final Lazy name$delegate; //这个 get函数是自动生成的 private final String getName() { Lazy var1 = this.name$delegate; return (String)var1.getValue(); }} 解决办法既然我们定位到了问题的原因，那我们重新给自己的写的函数命名一下，是不是就可以了？这种方法是可以的，但是不够优雅，其实Kotlin给我提供了一下方法，去处理这种情况。 测试方法一：@JvmName 指定生成的函数名@JvmName 注解是 Kotlin 提供的一个用于指定在编译为 Java 字节码时生成的 Java 类或方法名称的注解。它允许你在 Kotlin 代码中为特定的元素指定一个不同于默认生成的 Java 名称。但是，在上面的代码中，你会遇到错误。 1This annotation is not applicable to target 'member property with delegate' 因为我们用了Lazy代理，我们需要用 @get:JvmName(“name”) 来处理这种情况。 测试方法二： @JvmField\u0000@JvmField 是 Kotlin 提供的一个注解，用于将属性暴露为公共的 Java 字段，而不是生成 getter 和 setter 方法。\u0000是不是这样就可以了？其实也会遇到一个错误，就是这里使用了代理类，代理类实际上是生成了函数，通过函数中转的，java并不会有一个同名Field, 而是一个Lazy name$delegate;如果是普通的属性，这个注解是可以的。 1JvmField cannot be applied to delegated property 这个问题的本质是Kotlin默认生成了get方法，那Kotlin就不能默认不生成get方法吗？其实对一个普通final feild是没有生成get和set，是直接访问变量的，自动生成get个set 常见的是var类型 方法三：可以添加前缀_添加前缀的方法，本质是让，变量不同名，但是代码可读性没有改变，个人认为是比较优雅的一种方式。@get:JvmName(“name”) 显得添加的信息更多，更打扰阅读。","link":"/2023/11/07/Android/kotlin_name_dup/"},{"title":"小心Kotlin下的构造函数NoSuchMethodException","text":"问题背景近期开发过程中，踩了一个坑, 只在release包下稳定复现，本地debug包 没有出现问题。 123Exception in thread \"main\" java.lang.NoSuchMethodException: a.x.&lt;init&gt;(s.x,s.e)at java.base/java.lang.Class.getConstructor0(Class.java:3585)at java.base/java.lang.Class.getDeclaredConstructor(Class.java:2754) 通过解混淆，定位源代码，和结合mapping文件，解包看看源代码，确实是少了目标函数 方法为什么会消失？在 Android 开发中，通常使用 ProGuard 来进行代码混淆和压缩，以减少应用程序的代码大小和防止逆向工程, ProGuard会移除一下没有引用到的方法和字段，如果我们要通过其他方式使用，需要对ProGuard声明保留某一些字段。根据经验，debug包和release包 的大多数问题都是混淆引起的。通过反射构建对象的时候，类的构造函数也是需要声明keep的需要小心，Kotlin的 直接接在类后面的够着函数，是没有置灰提示的，很容易漏掉，如果是直接声明的构造函数， 解决办法要么对每个类添加@Keep注解，或者添加包的规则。 12#对包下com.test.pkgname包下的类保留构造函数-keepclassmembers class com.test.pkgname.** { &lt;init&gt;(...)}","link":"/2023/10/14/Android/kotlin_android_init_no_method/"},{"title":"Android项目接入Rust","text":"背景本次讨论在已有的安卓项目工程中配置rust的方法，同时记录一下踩坑过程，首先本地pc端配置好rust的开发环境，配置rust的过程就默认你会了。 项目配置 项目结构在已有的项目，我们推荐新建一个module，这里不需要native module，就是普通的java module。 我们把rust工程可以放到module平级目录，或module下面都是可以的。 我们把所有rust相关的代码，全部放到rustsdk工程目录，可以单独打开，单独成仓库，单独维护。和这个rust相关的桥接层，我们全部放在本地的java module里面。 项目根grade配置主要的思路是参考https://github.com/mozilla/rust-android-gradle现在项目的跟目录下配置rust-android-gradle，具体的版本，可以参考github上最新的 12345678910buildscript { repositories { maven { url \"https://plugins.gradle.org/m2/\" } } dependencies { classpath \"org.mozilla.rust-android-gradle:plugin:0.9.3\" }} \u0000 module gradle配置先给模块添加插件， 1apply plugin: \"org.mozilla.rust-android-gradle.rust-android\" 然后主要的就是配置cargo这个dsl，具体的参数表意可以在github上面看\u0000需要主要的是，modlue 直到 sdk的目录，包含Cargo.toml的位置，libname需要和Cargo.toml文件里面指定的一致，其它按需配置即可。按需要添加交叉编译器 12rustup target add armv7-linux-androideabi # for armrustup target add aarch64-linux-android # for arm64 可选，每次编译的时候，触发一次rust的编译 12345tasks.configureEach { task -&gt; if ((task.name == 'javaPreCompileDebug' || task.name == 'javaPreCompileRelease')) { task.dependsOn 'cargoBuild' }} 或者项目目录下，手动 1./gradlew cargoBuild --stacktrace --info 上面基本安卓项目里面就配置完了。下面展示一个调用示例, java调一下rust。 1234567package com.example.mylibrary;public class Tools { static { System.loadLibrary(\"rust_sdk\"); } public native int addNum(int num1,int num2,);} Rust SDK配置 Cargo.toml配置1234567891011121314151617[package]name = \"rust_sdk\"version = \"0.1.0\"[dependencies]log = \"0.4.14\"jni-sys = \"0.3.0\"jni = \"0.21.1\"#可选，指定android下才添加依赖[target.'cfg(target_os = \"android\")'.dependencies]#ndk = { version = \"0.8.0\" }[lib]crate_type = [\"dylib\"]#指定源码文件path = \"src/lib.rs\" lib.rs123456789101112extern crate jni;extern crate jni_sys;use jni::JNIEnv;use jni::objects::JClass;use jni_sys::jint;#[allow(non_snake_case)]#[no_mangle]pub unsafe extern fn Java_com_example_mylibrary_Tools_addNum(_env: JNIEnv, _: JClass, numa: jint, numb: jint) -&gt; jint { numb + numa} 然后，在Android Studio里面编译app调用这个方法就ok了。这里会有目标so，可以用检查一下导出函数。 我没有直接把所有依赖放到 [target.’cfg(target_os = “android”)’.dependencies]下，是因为这样在pc端可以直接编译，检查错误，利于开发。 比起👇🏻新建mod的方法，目前ide，还支持的不是很友好，也不好编程，错误也不好检查。只有去编译目标产物的时候才会发现。而脱离目标平台的方法，一些逻辑我是可以提前测试验证的。 注意事项： java.lang.UnsatisfiedLinkError: dlopen failed: library “librustsdk.so” not found根据代码是用的什么loadLibrary方法，如果是 1System.loadLibrary(\"rust_sdk\"); 是不需要添加lib前缀的，尽管生成的lib文件带有前缀，例如 librust_sdk.so，还有需要留意你在grade里面指定的文件 1234567cargo { module = \"./../rust_sdk\" // Or whatever directory contains your Cargo.toml libname = \"rust_sdk\" // Or whatever matches Cargo.toml's [package] name. targets = [\"arm64\"] // See bellow for a longer list of options verbose = true profile = \"debug\"} java.lang.UnsatisfiedLinkError: No implementation found这个是方法找不到，需要查一下，方法名称和参数是不是对应得上，一个排查方法，就是去看so的导出函数，有没有。 123 ./ objdump -T librust_sdk.so | grep addNum000000000012e2ec g DF .text 0000000000000094 Java_com_example_mylibrary_Tools_addNum 还有一个很容易忽略的点，大坑 apk打包的流程如果是有缓存的话，并不会去检查so是否有更新，写完rust，直接就去编译apk，所以apk里面的so很有可能是旧的，如果是旧的，就需要重新rebuild一次，可以去检查一下。JNI的方法调用，推荐用方法名去做区分，不要用参数重载之类的方法，去做区分，如果你写了一个add函数，发现你多传一个参数，也是可以调的。","link":"/2023/12/02/Android/android_import_rust/"},{"title":"安卓逆向之重新打包","text":"安卓重新打包 下载工具https://apktool.org/ 解包和重新打包https://github.com/skylot/jadx 反编译查看 命令 解包1java -jar apktool_2.9.1.jar d firstTest.apk d=decode=解码这个命令会把firstTest.apk解出来一个smali文件夹 重新打包1java -jar apktool_2.9.1.jar b firstTest -o firstTest.apk b=build=编译 o=output=输出文件名 一般重新打包后安装是需要重新签名的，重新签名需要一个证书。 生成证书1keytool -genkeypair -v -keystore repack.keystore -keyalg RSA -keysize 2048 -validity 10000 -alias repack 密码和alias需要记住 重新签名1jarsigner -verbose -digestalg SHA1 -sigalg SHA1withRSA -keystore repack.keystore -signedjar firstTestSign.apk firstTest.apk repack","link":"/2022/12/17/Android/android_repack/"},{"title":"一种事件流埋点的实现方案","text":"问题背景：假定app端上有个场景，是一个有序的流程，在每个关键节点都是可能失败的。现存的方案是在每个关键节点都做一个埋点上报，有如下痛点： 埋点有丢失的情况，造成漏斗分析，后面比前面多的情况 DA数据分析侧，不方便分析整个流程，需要查询多个事件，再做关联，SQL过于复杂 RD侧也不能很好的处理反馈和关注问题 埋点方案改进方案：在app侧做整个事件流的打点，对整个事件流做一起的上报。接口设计：整个事件流在开始节，生成id，后续这个事件流中的所有打点都记录在这个id流中，记录的顺序就是发生的顺序。暴露一个接口，提供一个默认实现，开放部分方法可重写。提供基本的方法，新建记录，插入记录，和触发上报。数据格式: 采用json格式,大致格式如下，可自由增添加，后端用clickhouse方便处理josn数据 123456{ \"local_id\":\"\", \"server_id\":\"\", \"event\":[] \"extra\":{}} 问题点事件流ID怎么确定？由业务方指定，在newRecord的时候传入。端上的记录依赖local_id在记录产生的时候，就记录。在本地用KV的方式存储，不过本地持久化记录的value是需要加一些状态字段的，标记这条记录的状态。server_id是因为这个事件流在后面的某个阶段才会产生一个关联的id，在后端关联查询，例如的场景就是直播连麦主播和嘉宾的链接事件关联，就可以用这个抽象的server_id 数据的一致性？同一个事件流可能是在多个线程里面操作的， 某个线程get一次record(json)之后会，做个修改之后，会将这个更新保存下来。会存在一种情况，后面的提交修改可能会被前面的覆盖的情况。为了解决这个问题，我们的整体的思路是一个单线程模型，安卓里面使用HanderThread,所有的操作都是在一个线程里面提交，但是也是会有覆盖的情况，因为多线程操作，它的get和set可能是分离的。如果我们可以保证每个线程里面的操作get和set是连续的，那么就能解决这个问。既然要get和set是连续的，最简单的办法就是单线程中这2个操作是连续的就可以了，所以我们的模型规定了2个模型，一个是简单的获取值，这个接口可以是同步的或异步的返回都行，不涉及值的修改。如果是涉及值的修改，只提供异步的接口，单线程队列里面去处理回调，调用方，在回调里面进行值的修改。 12func sync getRecord(recordId:String):JSONfunc async editRecord(recordId:String，callback:JSON) 例如一个线程post了一个修改，在消息队列处理这个消息的时候，也就是回调里面拿到的record就是最新的，此刻这个线程被这个消息占有，可以在回调里面做对这个record的各种修改，在回调结束的时候，自动做保存。这些都我们框架设计的能力，业务调用方，只需要在回调里面写自定义的修改逻辑就可以了，可以不感知具体的实现。 自定义JSON的merge一个record的更新，其实是一个json的更新，所以这里需要定义json的合并规则，如果是数组类型的，就追加在后面，或者就是后面的替换前面的。 如何保证埋点不丢失？可以通过以下手段来保证记录的正确的，尽量多的上报到server做统计，app突然被kill？记录怎么办？利用的是mmap，把磁盘映射成内存的来访问，访问快，并且利用操作系统的机制，数据会尽可能的保留，计算app被突然kill，我们也可以获得一些有用信息，做问题分析。 首先灵活的配置方式主动触发上报的方式。利用record的时机场景，支持配置超时。例如这个事件流，正常的情况也就最多1分钟，超过1分钟，就主动触发上报。当然也支持业务调用主动触发上报。 轮训时间间隔，检查本地记录是否可以上报。 app启动的时候，支持定制的延时上报本地的记录。 添加日期过期机制，丢掉无用的数据，减少server分析压力。","link":"/2023/09/09/Android/seq_point_trace_report/"}],"tags":[{"name":"Bug","slug":"Bug","link":"/tags/Bug/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"分享","slug":"分享","link":"/tags/%E5%88%86%E4%BA%AB/"},{"name":"Spark","slug":"Spark","link":"/tags/Spark/"},{"name":"K8S","slug":"K8S","link":"/tags/K8S/"},{"name":"JNI","slug":"JNI","link":"/tags/JNI/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"计组","slug":"计组","link":"/tags/%E8%AE%A1%E7%BB%84/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"安装","slug":"安装","link":"/tags/%E5%AE%89%E8%A3%85/"},{"name":"Compose","slug":"Compose","link":"/tags/Compose/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Java","slug":"Android/Java","link":"/categories/Android/Java/"},{"name":"语言基础","slug":"语言基础","link":"/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"name":"Java","slug":"语言基础/Java","link":"/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/Java/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"Kotlin","slug":"语言基础/Kotlin","link":"/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/Kotlin/"},{"name":"分享","slug":"分享","link":"/categories/%E5%88%86%E4%BA%AB/"},{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"C++","slug":"语言基础/C","link":"/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"项目架构","slug":"项目架构","link":"/categories/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/"},{"name":"问题与经验","slug":"问题与经验","link":"/categories/%E9%97%AE%E9%A2%98%E4%B8%8E%E7%BB%8F%E9%AA%8C/"},{"name":"Kotlin","slug":"Android/Kotlin","link":"/categories/Android/Kotlin/"}]}